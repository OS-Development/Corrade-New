///////////////////////////////////////////////////////////////////////////
//  Copyright (C) Wizardry and Steamworks 2013 - License: GNU GPLv3      //
//  Please see: http://www.gnu.org/licenses/gpl.html for legal details,  //
//  rights of fair usage, the disclaimer and warranty conditions.        //
///////////////////////////////////////////////////////////////////////////

#region

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Management;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.ServiceProcess;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using AIMLbot;
using OpenMetaverse;
using OpenMetaverse.Assets;
using OpenMetaverse.Imaging;
using OpenMetaverse.Rendering;
using OpenMetaverse.StructuredData;
using Encoder = System.Drawing.Imaging.Encoder;
using Parallel = System.Threading.Tasks.Parallel;
using Path = System.IO.Path;
using ThreadState = System.Threading.ThreadState;
using Timer = System.Timers.Timer;

#endregion

namespace Corrade
{
    public partial class Corrade : ServiceBase
    {
        public delegate bool EventHandler(NativeMethods.CtrlType ctrlType);

        /// <summary>
        ///     Corrade notification types.
        /// </summary>
        [Flags]
        public enum Notifications : uint
        {
            [Description("alert")] NOTIFICATION_ALERT_MESSAGE = 1,
            [Description("region")] NOTIFICATION_REGION_MESSAGE = 2,
            [Description("group")] NOTIFICATION_GROUP_MESSAGE = 4,
            [Description("balance")] NOTIFICATION_BALANCE = 8,
            [Description("message")] NOTIFICATION_INSTANT_MESSAGE = 16,
            [Description("notice")] NOTIFICATION_GROUP_NOTICE = 32,
            [Description("local")] NOTIFICATION_LOCAL_CHAT = 64,
            [Description("dialog")] NOTIFICATION_SCRIPT_DIALOG = 128,
            [Description("friendship")] NOTIFICATION_FRIENDSHIP = 256,
            [Description("inventory")] NOTIFICATION_INVENTORY = 512,
            [Description("permission")] NOTIFICATION_SCRIPT_PERMISSION = 1024,
            [Description("lure")] NOTIFICATION_TELEPORT_LURE = 2048,
            [Description("effect")] NOTIFICATION_VIEWER_EFFECT = 4096,
            [Description("collision")] NOTIFICATION_MEAN_COLLISION = 8192,
            [Description("crossing")] NOTIFICATION_REGION_CROSSED = 16384,
            [Description("terse")] NOTIFICATION_TERSE_UPDATES = 32768,
            [Description("typing")] NOTIFICATION_TYPING = 65536,
            [Description("invite")] NOTIFICATION_GROUP_INVITE = 131072,
            [Description("economy")] NOTIFICATION_ECONOMY = 262144,
            [Description("membership")] NOTIFICATION_GROUP_MEMBERSHIP = 524288,
            [Description("url")] NOTIFICATION_LOAD_URL = 1048576,
            [Description("ownersay")] NOTIFICATION_OWNER_SAY = 2097152,
            [Description("regionsayto")] NOTIFICATION_REGION_SAY_TO = 4194304,
            [Description("objectim")] NOTIFICATION_OBJECT_INSTANT_MESSAGE = 8388608,
            [Description("rlv")] NOTIFICATION_RLV_MESSAGE = 16777216,
            [Description("debug")] NOTIFICATION_DEBUG_MESSAGE = 33554432,
            [Description("avatars")] NOTIFICATION_RADAR_AVATARS = 67108864,
            [Description("primitives")] NOTIFICATION_RADAR_PRIMITIVES = 134217728
        }

        public Corrade()
        {
            if (Environment.UserInteractive) return;
            try
            {
                InstalledServiceName = (string)
                    new ManagementObjectSearcher("SELECT * FROM Win32_Service where ProcessId = " +
                                                 Process.GetCurrentProcess().Id).Get()
                        .Cast<ManagementBaseObject>()
                        .First()["Name"];
            }
            catch (Exception)
            {
                InstalledServiceName = CORRADE_CONSTANTS.DEFAULT_SERVICE_NAME;
            }
            CorradeEventLog.Source = InstalledServiceName;
            CorradeEventLog.Log = CORRADE_CONSTANTS.LOG_FACILITY;
            ((ISupportInitialize) (CorradeEventLog)).BeginInit();
            if (!EventLog.SourceExists(CorradeEventLog.Source))
            {
                EventLog.CreateEventSource(CorradeEventLog.Source, CorradeEventLog.Log);
            }
            ((ISupportInitialize) (CorradeEventLog)).EndInit();
        }

        /// <summary>
        ///     Sweep for group members.
        /// </summary>
        private static void GroupMembershipSweep()
        {
            Queue<UUID> groupUUIDs = new Queue<UUID>();
            Queue<int> memberCount = new Queue<int>();
            // The total list of members.
            HashSet<UUID> groupMembers = new HashSet<UUID>();
            // New members that have joined the group.
            HashSet<UUID> joinedMembers = new HashSet<UUID>();
            // Members that have parted the group.
            HashSet<UUID> partedMembers = new HashSet<UUID>();

            ManualResetEvent GroupMembersReplyEvent = new ManualResetEvent(false);
            EventHandler<GroupMembersReplyEventArgs> HandleGroupMembersReplyDelegate = (sender, args) =>
            {
                lock (GroupMembersLock)
                {
                    if (!GroupMembers.ContainsKey(args.GroupID))
                    {
                        groupMembers.UnionWith(args.Members.Values.Select(o => o.ID));
                        GroupMembersReplyEvent.Set();
                        return;
                    }
                }
                object LockObject = new object();
                Parallel.ForEach(
                    args.Members.Values,
                    o =>
                    {
                        lock (GroupMembersLock)
                        {
                            if (GroupMembers[args.GroupID].Contains(o.ID)) return;
                        }
                        lock (LockObject)
                        {
                            joinedMembers.Add(o.ID);
                        }
                    });
                lock (GroupMembersLock)
                {
                    Parallel.ForEach(
                        GroupMembers[args.GroupID],
                        o =>
                        {
                            if (args.Members.Values.AsParallel().Any(p => p.ID.Equals(o))) return;
                            lock (LockObject)
                            {
                                partedMembers.Add(o);
                            }
                        });
                }
            };

            while (runGroupMembershipSweepThread)
            {
                Thread.Sleep(Configuration.MEMBERSHIP_SWEEP_INTERVAL);
                if (!Client.Network.Connected) continue;

                HashSet<UUID> currentGroups = new HashSet<UUID>();
                if (!GetCurrentGroups(Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref currentGroups))
                    continue;

                // Enqueue configured groups that are currently joined groups.
                groupUUIDs.Clear();
                object LockObject = new object();
                Parallel.ForEach(Configuration.GROUPS.AsParallel().Select(o => new {group = o, groupUUID = o.UUID})
                    .Where(p => currentGroups.Any(o => o.Equals(p.groupUUID)))
                    .Select(o => o.group), o =>
                    {
                        lock (LockObject)
                        {
                            groupUUIDs.Enqueue(o.UUID);
                        }
                    });


                // Bail if no configured groups are also joined.
                if (groupUUIDs.Count.Equals(0)) continue;

                // Get the last member count.
                memberCount.Clear();
                lock (GroupMembersLock)
                {
                    Parallel.ForEach(GroupMembers.AsParallel().SelectMany(
                        members => groupUUIDs,
                        (members, groupUUID) => new {members, groupUUID})
                        .Where(o => o.groupUUID.Equals(o.members.Key))
                        .Select(p => p.members), o =>
                        {
                            lock (LockObject)
                            {
                                memberCount.Enqueue(o.Value.Count);
                            }
                        });
                }

                do
                {
                    // Pause a second between group sweeps.
                    Thread.Sleep(1000);
                    // Dequeue the first group.
                    UUID groupUUID = groupUUIDs.Dequeue();
                    // Clear the total list of members.
                    groupMembers.Clear();
                    // Clear the members that have joined the group.
                    joinedMembers.Clear();
                    // Clear the members that have left the group.
                    partedMembers.Clear();
                    lock (ClientInstanceGroupsLock)
                    {
                        Client.Groups.GroupMembersReply += HandleGroupMembersReplyDelegate;
                        GroupMembersReplyEvent.Reset();
                        Client.Groups.RequestGroupMembers(groupUUID);
                        if (!GroupMembersReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                        {
                            Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                            continue;
                        }
                        Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                    }
                    lock (GroupMembersLock)
                    {
                        if (!GroupMembers.ContainsKey(groupUUID))
                        {
                            GroupMembers.Add(groupUUID, new HashSet<UUID>(groupMembers));
                            continue;
                        }
                    }
                    if (!memberCount.Count.Equals(0))
                    {
                        if (!memberCount.Dequeue().Equals(groupMembers.Count))
                        {
                            if (!joinedMembers.Count.Equals(0))
                            {
                                Parallel.ForEach(
                                    joinedMembers,
                                    o =>
                                    {
                                        string agentName = string.Empty;
                                        if (AgentUUIDToName(
                                            o,
                                            Configuration.SERVICES_TIMEOUT,
                                            ref agentName))
                                        {
                                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                                () =>
                                                    SendNotification(
                                                        Notifications.NOTIFICATION_GROUP_MEMBERSHIP,
                                                        new GroupMembershipEventArgs
                                                        {
                                                            AgentName = agentName,
                                                            AgentUUID = o,
                                                            Action = Action.JOINED
                                                        }),
                                                Configuration.MAXIMUM_NOTIFICATION_THREADS);
                                        }
                                    });
                            }
                            joinedMembers.Clear();
                            if (!partedMembers.Count.Equals(0))
                            {
                                Parallel.ForEach(
                                    partedMembers,
                                    o =>
                                    {
                                        string agentName = string.Empty;
                                        if (AgentUUIDToName(
                                            o,
                                            Configuration.SERVICES_TIMEOUT,
                                            ref agentName))
                                        {
                                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                                () =>
                                                    SendNotification(
                                                        Notifications.NOTIFICATION_GROUP_MEMBERSHIP,
                                                        new GroupMembershipEventArgs
                                                        {
                                                            AgentName = agentName,
                                                            AgentUUID = o,
                                                            Action = Action.PARTED
                                                        }),
                                                Configuration.MAXIMUM_NOTIFICATION_THREADS);
                                        }
                                    });
                            }
                        }
                        partedMembers.Clear();
                    }
                    lock (GroupMembersLock)
                    {
                        GroupMembers[groupUUID].Clear();
                        foreach (UUID member in groupMembers)
                        {
                            GroupMembers[groupUUID].Add(member);
                        }
                    }
                    groupMembers.Clear();
                } while (!groupUUIDs.Count.Equals(0) && runGroupMembershipSweepThread);
            }
        }

        private static bool ConsoleCtrlCheck(NativeMethods.CtrlType ctrlType)
        {
            // Set the user disconnect semaphore.
            ConnectionSemaphores['u'].Set();
            // Wait for threads to finish.
            Thread.Sleep(Configuration.SERVICES_TIMEOUT);
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Serialize an RLV message to a string.
        /// </summary>
        /// <returns>in order: behaviours, options, parameters</returns>
        private static IEnumerable<string> wasRLVToString(string message)
        {
            if (string.IsNullOrEmpty(message)) yield break;

            // Split all commands.
            string[] unpack = message.Split(RLV_CONSTANTS.CSV_DELIMITER[0]);
            // Pop first command to process.
            string first = unpack.First();
            // Remove command.
            unpack = unpack.AsParallel().Where(o => !o.Equals(first)).ToArray();
            // Keep rest of message.
            message = string.Join(RLV_CONSTANTS.CSV_DELIMITER, unpack);

            Match match = RLV_CONSTANTS.RLVRegEx.Match(first);
            if (!match.Success) goto CONTINUE;

            yield return match.Groups["behaviour"].ToString().ToLowerInvariant();
            yield return match.Groups["option"].ToString().ToLowerInvariant();
            yield return match.Groups["param"].ToString().ToLowerInvariant();

            CONTINUE:
            foreach (string slice in wasRLVToString(message))
            {
                yield return slice;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Combine multiple paths.
        /// </summary>
        /// <param name="paths">an array of paths</param>
        /// <returns>a combined path</returns>
        private static string wasPathCombine(params string[] paths)
        {
            if (paths.Length.Equals(0)) return string.Empty;
            return paths.Length < 2
                ? paths[0]
                : Path.Combine(Path.Combine(paths[0], paths[1]), wasPathCombine(paths.Skip(2).ToArray()));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Retrives all the attributes of type T from an enumeration.
        /// </summary>
        /// <returns>a list of type T attributes</returns>
        private static IEnumerable<T> wasGetEnumAttributes<T>()
        {
            return typeof (T).GetFields(BindingFlags.Static | BindingFlags.Public)
                .AsParallel().Select(o => wasGetAttributeFromEnumValue<T>((Enum) o.GetValue(null)));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Retrieves an attribute of type T from an enumeration.
        /// </summary>
        /// <returns>an attribute of type T</returns>
        private static T wasGetAttributeFromEnumValue<T>(Enum value)
        {
            return (T) value.GetType()
                .GetField(value.ToString())
                .GetCustomAttributes(typeof (T), false)
                .SingleOrDefault();
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Returns all the field descriptions of an enumeration.
        /// </summary>
        /// <returns>the field descriptions</returns>
        private static IEnumerable<string> wasGetEnumDescriptions<T>()
        {
            return typeof (T).GetFields(BindingFlags.Static | BindingFlags.Public)
                .AsParallel().Select(o => wasGetDescriptionFromEnumValue((Enum) o.GetValue(null)));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Get the description from an enumeration value.
        /// </summary>
        /// <param name="value">an enumeration value</param>
        /// <returns>the description or the empty string</returns>
        private static string wasGetDescriptionFromEnumValue(Enum value)
        {
            DescriptionAttribute attribute = value.GetType()
                .GetField(value.ToString())
                .GetCustomAttributes(typeof (DescriptionAttribute), false)
                .SingleOrDefault() as DescriptionAttribute;
            return attribute != null ? attribute.Description : string.Empty;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Get enumeration value from its description.
        /// </summary>
        /// <typeparam name="T">the enumeration type</typeparam>
        /// <param name="description">the description of a member</param>
        /// <returns>the value or the default of T if case no description found</returns>
        private static T wasGetEnumValueFromDescription<T>(string description)
        {
            var field = typeof (T).GetFields()
                .AsParallel().SelectMany(f => f.GetCustomAttributes(
                    typeof (DescriptionAttribute), false), (
                        f, a) => new {Field = f, Att = a}).SingleOrDefault(a => ((DescriptionAttribute) a.Att)
                            .Description.Equals(description));
            return field != null ? (T) field.Field.GetRawConstantValue() : default(T);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Get the description of structure member.
        /// </summary>
        /// <typeparam name="T">the type of the structure to search</typeparam>
        /// <param name="structure">the structure to search</param>
        /// <param name="item">the value of the item to search</param>
        /// <returns>the description or the empty string</returns>
        private static string wasGetStructureMemberDescription<T>(T structure, object item) where T : struct
        {
            var field = typeof (T).GetFields()
                .AsParallel().SelectMany(f => f.GetCustomAttributes(typeof (DescriptionAttribute), false),
                    (f, a) => new {Field = f, Att = a}).SingleOrDefault(f => f.Field.GetValue(structure).Equals(item));
            return field != null ? ((DescriptionAttribute) field.Att).Description : string.Empty;
        }

        /// <summary>
        ///     Can an inventory item be worn?
        /// </summary>
        /// <param name="item">item to check</param>
        /// <returns>true if the inventory item can be worn</returns>
        private static bool CanBeWorn(InventoryBase item)
        {
            return item is InventoryWearable || item is InventoryAttachment || item is InventoryObject;
        }

        /// <summary>
        ///     Resolves inventory links and returns a real inventory item that
        ///     the link is pointing to
        /// </summary>
        /// <param name="item">a link or inventory item</param>
        /// <returns>the real inventory item</returns>
        private static InventoryItem ResolveItemLink(InventoryItem item)
        {
            return item.IsLink() && Client.Inventory.Store.Contains(item.AssetUUID) &&
                   Client.Inventory.Store[item.AssetUUID] is InventoryItem
                ? Client.Inventory.Store[item.AssetUUID] as InventoryItem
                : item;
        }

        /// <summary>
        ///     Get current outfit folder links.
        /// </summary>
        /// <returns>a list of inventory items that can be part of appearance (attachments, wearables)</returns>
        private static List<InventoryItem> GetCurrentOutfitFolderLinks(InventoryFolder outfitFolder)
        {
            List<InventoryItem> ret = new List<InventoryItem>();
            if (outfitFolder == null) return ret;

            Client.Inventory.Store.GetContents(outfitFolder)
                .FindAll(b => CanBeWorn(b) && ((InventoryItem) b).AssetType.Equals(AssetType.Link))
                .ForEach(item => ret.Add((InventoryItem) item));

            return ret;
        }

        private static void Attach(InventoryItem item, AttachmentPoint point, bool replace)
        {
            lock (ClientInstanceInventoryLock)
            {
                InventoryItem realItem = ResolveItemLink(item);
                if (realItem == null) return;
                Client.Appearance.Attach(realItem, point, replace);
                AddLink(realItem,
                    Client.Inventory.Store[Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)] as
                        InventoryFolder);
            }
        }

        private static void Detach(InventoryItem item)
        {
            lock (ClientInstanceInventoryLock)
            {
                InventoryItem realItem = ResolveItemLink(item);
                if (realItem == null) return;
                RemoveLink(realItem,
                    Client.Inventory.Store[Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)] as
                        InventoryFolder);
                Client.Appearance.Detach(realItem);
            }
        }

        private static void Wear(InventoryItem item, bool replace)
        {
            lock (ClientInstanceInventoryLock)
            {
                InventoryItem realItem = ResolveItemLink(item);
                if (realItem == null) return;
                Client.Appearance.AddToOutfit(realItem, replace);
                AddLink(realItem,
                    Client.Inventory.Store[Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)] as
                        InventoryFolder);
            }
        }

        private static void UnWear(InventoryItem item)
        {
            lock (ClientInstanceInventoryLock)
            {
                InventoryItem realItem = ResolveItemLink(item);
                if (realItem == null) return;
                Client.Appearance.RemoveFromOutfit(realItem);
                InventoryItem link = GetCurrentOutfitFolderLinks(
                    Client.Inventory.Store[Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)] as
                        InventoryFolder)
                    .AsParallel()
                    .FirstOrDefault(o => o.AssetType.Equals(AssetType.Link) && o.Name.Equals(item.Name));
                if (link == null) return;
                RemoveLink(link,
                    Client.Inventory.Store[Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)] as
                        InventoryFolder);
            }
        }

        /// <summary>
        ///     Is the item a body part?
        /// </summary>
        /// <param name="item">the item to check</param>
        /// <returns>true if the item is a body part</returns>
        private static bool IsBodyPart(InventoryItem item)
        {
            InventoryItem realItem = ResolveItemLink(item);
            if (!(realItem is InventoryWearable)) return false;
            WearableType t = ((InventoryWearable) realItem).WearableType;
            return t.Equals(WearableType.Shape) ||
                   t.Equals(WearableType.Skin) ||
                   t.Equals(WearableType.Eyes) ||
                   t.Equals(WearableType.Hair);
        }

        /// <summary>
        ///     Creates a new current outfit folder link.
        /// </summary>
        /// <param name="item">item to be linked</param>
        /// <param name="outfitFolder">the outfit folder</param>
        private static void AddLink(InventoryItem item, InventoryFolder outfitFolder)
        {
            if (outfitFolder == null) return;

            bool linkExists = null !=
                              GetCurrentOutfitFolderLinks(outfitFolder)
                                  .Find(itemLink => itemLink.AssetUUID.Equals(item.UUID));

            if (linkExists) return;

            string description = (item.InventoryType.Equals(InventoryType.Wearable) && !IsBodyPart(item))
                ? string.Format("@{0}{1:00}", (int) ((InventoryWearable) item).WearableType, 0)
                : string.Empty;
            Client.Inventory.CreateLink(Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder), item.UUID,
                item.Name, description, AssetType.Link,
                item.InventoryType, UUID.Random(), (success, newItem) =>
                {
                    if (success)
                    {
                        Client.Inventory.RequestFetchInventory(newItem.UUID, newItem.OwnerID);
                    }
                });
        }

        /// <summary>
        ///     Remove current outfit folder links for multiple specified inventory item.
        /// </summary>
        /// <param name="item">the item whose link should be removed</param>
        /// <param name="outfitFolder">the outfit folder</param>
        private static void RemoveLink(InventoryItem item, InventoryFolder outfitFolder)
        {
            if (outfitFolder == null) return;

            HashSet<UUID> removeItems = new HashSet<UUID>();
            GetCurrentOutfitFolderLinks(outfitFolder)
                .FindAll(
                    itemLink =>
                        itemLink.AssetUUID.Equals(item is InventoryWearable ? item.AssetUUID : item.UUID))
                .ForEach(link => removeItems.Add(link.UUID));

            Client.Inventory.Remove(removeItems.ToList(), null);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Swaps two integers passed by reference using XOR.
        /// </summary>
        /// <param name="q">first integer to swap</param>
        /// <param name="p">second integer to swap</param>
        private static void wasXORSwap(ref int q, ref int p)
        {
            q ^= p;
            p ^= q;
            q ^= p;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Enumerates the fields of an object along with the child objects,
        ///     provided that all child objects are part of a specified namespace.
        /// </summary>
        /// <param name="object">the object to enumerate</param>
        /// <param name="namespace">the namespace to enumerate in</param>
        /// <returns>child objects of the object</returns>
        private static IEnumerable<KeyValuePair<FieldInfo, object>> wasGetFields(object @object, string @namespace)
        {
            if (@object == null) yield break;

            foreach (FieldInfo fi in @object.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public))
            {
                if (fi.FieldType.FullName.Split('.', '+')
                    .Contains(@namespace, StringComparer.InvariantCultureIgnoreCase))
                {
                    foreach (KeyValuePair<FieldInfo, object> sf in wasGetFields(fi.GetValue(@object), @namespace))
                    {
                        yield return sf;
                    }
                }
                yield return new KeyValuePair<FieldInfo, object>(fi, @object);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Enumerates the properties of an object along with the child objects,
        ///     provided that all child objects are part of a specified namespace.
        /// </summary>
        /// <param name="object">the object to enumerate</param>
        /// <param name="namespace">the namespace to enumerate in</param>
        /// <returns>child objects of the object</returns>
        private static IEnumerable<KeyValuePair<PropertyInfo, object>> wasGetProperties(object @object,
            string @namespace)
        {
            if (@object == null) yield break;

            foreach (PropertyInfo pi in @object.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public))
            {
                if (pi.PropertyType.FullName.Split('.', '+')
                    .Contains(@namespace, StringComparer.InvariantCultureIgnoreCase))
                {
                    foreach (
                        KeyValuePair<PropertyInfo, object> sp in
                            wasGetProperties(pi.GetValue(@object, null), @namespace))
                    {
                        yield return sp;
                    }
                }
                yield return new KeyValuePair<PropertyInfo, object>(pi, @object);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     This is a wrapper for both FieldInfo and PropertyInfo SetValue.
        /// </summary>
        /// <param name="info">either a FieldInfo or PropertyInfo</param>
        /// <param name="object">the object to set the value on</param>
        /// <param name="value">the value to set</param>
        private static void wasSetInfoValue<TK, TV>(TK info, ref TV @object, object value)
        {
            object o = @object;
            FieldInfo fi = (object) info as FieldInfo;
            if (fi != null)
            {
                fi.SetValue(o, value);
                @object = (TV) o;
                return;
            }
            PropertyInfo pi = (object) info as PropertyInfo;
            if (pi != null)
            {
                pi.SetValue(o, value, null);
                @object = (TV) o;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     This is a wrapper for both FieldInfo and PropertyInfo GetValue.
        /// </summary>
        /// <param name="info">either a FieldInfo or PropertyInfo</param>
        /// <param name="value">the object to get from</param>
        /// <returns>the value of the field or property</returns>
        private static object wasGetInfoValue<T>(T info, object value)
        {
            FieldInfo fi = (object) info as FieldInfo;
            if (fi != null)
            {
                return fi.GetValue(value);
            }
            PropertyInfo pi = (object) info as PropertyInfo;
            if (pi != null)
            {
                if (!pi.GetIndexParameters().Length.Equals(0))
                {
                    return value;
                }
                return pi.GetValue(value, null);
            }
            return null;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     The function gets the value from FieldInfo or PropertyInfo.
        /// </summary>
        /// <param name="info">a FieldInfo or PropertyInfo structure</param>
        /// <param name="value">the value to get</param>
        /// <returns>the value or values as a string</returns>
        private static IEnumerable<string> wasGetInfo(object info, object value)
        {
            if (info == null) yield break;
            object data = wasGetInfoValue(info, value);
            if (data == null) yield break;
            // Handle arrays and lists
            if (data is Array || data is IList)
            {
                IList iList = (IList) data;
                if (iList.Count.Equals(0)) yield break;
                foreach (object item in iList.Cast<object>().Where(o => o != null))
                {
                    foreach (KeyValuePair<FieldInfo, object> fi in wasGetFields(item, item.GetType().Name))
                    {
                        if (fi.Key != null)
                        {
                            foreach (string fieldString in wasGetInfo(fi.Key, fi.Value))
                            {
                                yield return fi.Key.Name;
                                yield return fieldString;
                            }
                        }
                    }
                    foreach (KeyValuePair<PropertyInfo, object> pi in wasGetProperties(item, item.GetType().Name))
                    {
                        if (pi.Key != null)
                        {
                            foreach (string propertyString in wasGetInfo(pi.Key, pi.Value))
                            {
                                yield return pi.Key.Name;
                                yield return propertyString;
                            }
                        }
                    }
                    // Don't bother with primitive types.
                    if (item.GetType().IsPrimitive)
                    {
                        yield return item.ToString();
                    }
                }
                yield break;
            }
            // Handle Dictionary
            if (data is IDictionary)
            {
                Hashtable dictionary = new Hashtable(data as IDictionary);
                if (dictionary.Count.Equals(0)) yield break;
                foreach (DictionaryEntry entry in dictionary)
                {
                    // First the keys.
                    foreach (KeyValuePair<FieldInfo, object> fi in wasGetFields(entry.Key, entry.Key.GetType().Name))
                    {
                        if (fi.Key != null)
                        {
                            foreach (string fieldString in wasGetInfo(fi.Key, fi.Value))
                            {
                                yield return fi.Key.Name;
                                yield return fieldString;
                            }
                        }
                    }
                    foreach (
                        KeyValuePair<PropertyInfo, object> pi in wasGetProperties(entry.Key, entry.Key.GetType().Name))
                    {
                        if (pi.Key != null)
                        {
                            foreach (string propertyString in wasGetInfo(pi.Key, pi.Value))
                            {
                                yield return pi.Key.Name;
                                yield return propertyString;
                            }
                        }
                    }
                    // Then the values.
                    foreach (KeyValuePair<FieldInfo, object> fi in wasGetFields(entry.Value, entry.Value.GetType().Name)
                        )
                    {
                        if (fi.Key != null)
                        {
                            foreach (string fieldString in wasGetInfo(fi.Key, fi.Value))
                            {
                                yield return fi.Key.Name;
                                yield return fieldString;
                            }
                        }
                    }
                    foreach (
                        KeyValuePair<PropertyInfo, object> pi in
                            wasGetProperties(entry.Value, entry.Value.GetType().Name))
                    {
                        if (pi.Key != null)
                        {
                            foreach (string propertyString in wasGetInfo(pi.Key, pi.Value))
                            {
                                yield return pi.Key.Name;
                                yield return propertyString;
                            }
                        }
                    }
                }
                yield break;
            }
            // Handle InternalDictionary
            FieldInfo internalDictionaryInfo = data.GetType()
                .GetField("Dictionary",
                    BindingFlags.Default | BindingFlags.CreateInstance | BindingFlags.Instance | BindingFlags.NonPublic);
            if (internalDictionaryInfo != null)
            {
                Hashtable internalDictionary = new Hashtable(internalDictionaryInfo.GetValue(data) as IDictionary);
                if (internalDictionary.Count.Equals(0)) yield break;
                foreach (DictionaryEntry entry in internalDictionary)
                {
                    // First the keys.
                    foreach (KeyValuePair<FieldInfo, object> fi in wasGetFields(entry.Key, entry.Key.GetType().Name))
                    {
                        if (fi.Key != null)
                        {
                            foreach (string fieldString in wasGetInfo(fi.Key, fi.Value))
                            {
                                yield return fi.Key.Name;
                                yield return fieldString;
                            }
                        }
                    }
                    foreach (
                        KeyValuePair<PropertyInfo, object> pi in wasGetProperties(entry.Key, entry.Key.GetType().Name))
                    {
                        if (pi.Key != null)
                        {
                            foreach (string propertyString in wasGetInfo(pi.Key, pi.Value))
                            {
                                yield return pi.Key.Name;
                                yield return propertyString;
                            }
                        }
                    }
                    // Then the values.
                    foreach (KeyValuePair<FieldInfo, object> fi in wasGetFields(entry.Value, entry.Value.GetType().Name)
                        )
                    {
                        if (fi.Key != null)
                        {
                            foreach (string fieldString in wasGetInfo(fi.Key, fi.Value))
                            {
                                yield return fi.Key.Name;
                                yield return fieldString;
                            }
                        }
                    }
                    foreach (
                        KeyValuePair<PropertyInfo, object> pi in
                            wasGetProperties(entry.Value, entry.Value.GetType().Name))
                    {
                        if (pi.Key != null)
                        {
                            foreach (string propertyString in wasGetInfo(pi.Key, pi.Value))
                            {
                                yield return pi.Key.Name;
                                yield return propertyString;
                            }
                        }
                    }
                }
                yield break;
            }

            string @string = data.ToString();
            if (string.IsNullOrEmpty(@string)) yield break;
            yield return @string;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Sets the value of FieldInfo or PropertyInfo.
        /// </summary>
        /// <typeparam name="T">the type to set</typeparam>
        /// <param name="info">a FieldInfo or PropertyInfo object</param>
        /// <param name="value">the object's value</param>
        /// <param name="setting">the value to set to</param>
        /// <param name="object">the object to set the values for</param>
        private static void wasSetInfo<T>(object info, object value, string setting, ref T @object)
        {
            if (info == null) return;
            if (wasGetInfoValue(info, value) is string)
            {
                wasSetInfoValue(info, ref @object, setting);
            }
            if (wasGetInfoValue(info, value) is UUID)
            {
                UUID UUIDData;
                if (!UUID.TryParse(setting, out UUIDData))
                {
                    InventoryItem item = FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                        setting).FirstOrDefault() as InventoryItem;
                    if (item == null)
                    {
                        throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                    }
                    UUIDData = item.UUID;
                }
                if (UUIDData.Equals(UUID.Zero))
                {
                    throw new Exception(
                        wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                }
                wasSetInfoValue(info, ref @object, UUIDData);
            }
            if (wasGetInfoValue(info, value) is bool)
            {
                bool boolData;
                if (bool.TryParse(setting, out boolData))
                {
                    wasSetInfoValue(info, ref @object, boolData);
                }
            }
            if (wasGetInfoValue(info, value) is int)
            {
                int intData;
                if (int.TryParse(setting, out intData))
                {
                    wasSetInfoValue(info, ref @object, intData);
                }
            }
            if (wasGetInfoValue(info, value) is uint)
            {
                uint uintData;
                if (uint.TryParse(setting, out uintData))
                {
                    wasSetInfoValue(info, ref @object, uintData);
                }
            }
            if (wasGetInfoValue(info, value) is DateTime)
            {
                DateTime dateTimeData;
                if (DateTime.TryParse(setting, out dateTimeData))
                {
                    wasSetInfoValue(info, ref @object, dateTimeData);
                }
            }
            if (wasGetInfoValue(info, value) is ParcelFlags)
            {
                uint parcelFlags;
                switch (!uint.TryParse(setting, out parcelFlags))
                {
                    case true:
                        Parallel.ForEach(wasCSVToEnumerable(setting), o =>
                        {
                            Parallel.ForEach(typeof (ParcelFlags).GetFields(BindingFlags.Public | BindingFlags.Static)
                                .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                p => { parcelFlags |= ((uint) p.GetValue(null)); });
                        });
                        break;
                }
                wasSetInfoValue(info, ref @object, parcelFlags);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Converts Linden item permissions to a formatted string:
        ///     CDEMVT - Copy, Damage, Export, Modify, Move, Transfer
        ///     BBBBBBEEEEEEGGGGGGNNNNNNOOOOOO - Base, Everyone, Group, Next, Owner
        /// </summary>
        /// <param name="permissions">the item permissions</param>
        /// <returns>the literal permissions for an item</returns>
        private static string wasPermissionsToString(OpenMetaverse.Permissions permissions)
        {
            Func<PermissionMask, string> segment = o =>
            {
                StringBuilder seg = new StringBuilder();

                switch (!((uint) o & (uint) PermissionMask.Copy).Equals(0))
                {
                    case true:
                        seg.Append("c");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                switch (!((uint) o & (uint) PermissionMask.Damage).Equals(0))
                {
                    case true:
                        seg.Append("d");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                switch (!((uint) o & (uint) PermissionMask.Export).Equals(0))
                {
                    case true:
                        seg.Append("e");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                switch (!((uint) o & (uint) PermissionMask.Modify).Equals(0))
                {
                    case true:
                        seg.Append("m");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                switch (!((uint) o & (uint) PermissionMask.Move).Equals(0))
                {
                    case true:
                        seg.Append("v");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                switch (!((uint) o & (uint) PermissionMask.Transfer).Equals(0))
                {
                    case true:
                        seg.Append("t");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                return seg.ToString();
            };

            StringBuilder x = new StringBuilder();
            x.Append(segment(permissions.BaseMask));
            x.Append(segment(permissions.EveryoneMask));
            x.Append(segment(permissions.GroupMask));
            x.Append(segment(permissions.NextOwnerMask));
            x.Append(segment(permissions.OwnerMask));
            return x.ToString();
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Converts a formatted string to item permissions:
        ///     CDEMVT - Copy, Damage, Export, Modify, Move, Transfer
        ///     BBBBBBEEEEEEGGGGGGNNNNNNOOOOOO - Base, Everyone, Group, Next, Owner
        /// </summary>
        /// <param name="permissions">the item permissions</param>
        /// <returns>the permissions for an item</returns>
        private static OpenMetaverse.Permissions wasStringToPermissions(string permissions)
        {
            Func<string, uint> segment = o =>
            {
                uint r = 0;
                switch (!char.ToLower(o[0]).Equals('c'))
                {
                    case false:
                        r |= (uint) PermissionMask.Copy;
                        break;
                }

                switch (!char.ToLower(o[1]).Equals('d'))
                {
                    case false:
                        r |= (uint) PermissionMask.Damage;
                        break;
                }

                switch (!char.ToLower(o[2]).Equals('e'))
                {
                    case false:
                        r |= (uint) PermissionMask.Export;
                        break;
                }

                switch (!char.ToLower(o[3]).Equals('m'))
                {
                    case false:
                        r |= (uint) PermissionMask.Modify;
                        break;
                }

                switch (!char.ToLower(o[4]).Equals('v'))
                {
                    case false:
                        r |= (uint) PermissionMask.Move;
                        break;
                }

                switch (!char.ToLower(o[5]).Equals('t'))
                {
                    case false:
                        r |= (uint) PermissionMask.Transfer;
                        break;
                }

                return r;
            };

            return new OpenMetaverse.Permissions(segment(permissions.Substring(0, 6)),
                segment(permissions.Substring(6, 6)), segment(permissions.Substring(12, 6)),
                segment(permissions.Substring(18, 6)), segment(permissions.Substring(24, 6)));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Determines whether an agent has a set of powers for a group.
        /// </summary>
        /// <param name="agentUUID">the agent UUID</param>
        /// <param name="groupUUID">the UUID of the group</param>
        /// <param name="powers">a GroupPowers structure</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <returns>true if the agent has the powers</returns>
        private static bool HasGroupPowers(UUID agentUUID, UUID groupUUID, GroupPowers powers,
            int millisecondsTimeout, int dataTimeout)
        {
            bool hasPowers = false;
            wasAdaptiveAlarm AvatarGroupsReceivedAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
            EventHandler<AvatarGroupsReplyEventArgs> AvatarGroupsReplyEventHandler = (sender, args) =>
            {
                AvatarGroupsReceivedAlarm.Alarm(dataTimeout);
                hasPowers =
                    args.Groups.AsParallel().Any(
                        o => o.GroupID.Equals(groupUUID) && !(o.GroupPowers & powers).Equals(GroupPowers.None));
            };
            lock (ClientInstanceAvatarsLock)
            {
                Client.Avatars.AvatarGroupsReply += AvatarGroupsReplyEventHandler;
                Client.Avatars.RequestAvatarProperties(agentUUID);
                if (!AvatarGroupsReceivedAlarm.Signal.WaitOne(millisecondsTimeout, false))
                {
                    Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                    return false;
                }
                Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
            }
            return hasPowers;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Attempts to join the group chat for a given group.
        /// </summary>
        /// <param name="groupUUID">the UUID of the group to join the group chat for</param>
        /// <param name="millisecondsTimeout">timeout for joining the group chat</param>
        /// <returns>true if the group chat was joined</returns>
        private static bool JoinGroupChat(UUID groupUUID, int millisecondsTimeout)
        {
            bool succeeded = false;
            ManualResetEvent GroupChatJoinedEvent = new ManualResetEvent(false);
            EventHandler<GroupChatJoinedEventArgs> GroupChatJoinedEventHandler =
                (sender, args) =>
                {
                    succeeded = args.Success;
                    GroupChatJoinedEvent.Set();
                };
            lock (ClientInstanceSelfLock)
            {
                Client.Self.GroupChatJoined += GroupChatJoinedEventHandler;
                Client.Self.RequestJoinGroupChat(groupUUID);
                if (!GroupChatJoinedEvent.WaitOne(millisecondsTimeout, false))
                {
                    Client.Self.GroupChatJoined -= GroupChatJoinedEventHandler;
                    return false;
                }
                Client.Self.GroupChatJoined -= GroupChatJoinedEventHandler;
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Determines whether an agent referenced by an UUID is in a group
        ///     referenced by an UUID.
        /// </summary>
        /// <param name="agentUUID">the UUID of the agent</param>
        /// <param name="groupUUID">the UUID of the groupt</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <returns>true if the agent is in the group</returns>
        private static bool AgentInGroup(UUID agentUUID, UUID groupUUID, int millisecondsTimeout, int dataTimeout)
        {
            bool agentInGroup = false;
            wasAdaptiveAlarm GroupMembersReceivedAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
            EventHandler<GroupMembersReplyEventArgs> HandleGroupMembersReplyDelegate = (sender, args) =>
            {
                GroupMembersReceivedAlarm.Alarm(dataTimeout);
                agentInGroup = args.Members.AsParallel().Any(o => o.Value.ID.Equals(agentUUID));
            };
            lock (ClientInstanceGroupsLock)
            {
                Client.Groups.GroupMembersReply += HandleGroupMembersReplyDelegate;
                Client.Groups.RequestGroupMembers(groupUUID);
                if (!GroupMembersReceivedAlarm.Signal.WaitOne(millisecondsTimeout, false))
                {
                    Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                    return false;
                }
                Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
            }
            return agentInGroup;
        }

        /// <summary>
        ///     Used to check whether a group name matches a group password.
        /// </summary>
        /// <param name="group">the name of the group</param>
        /// <param name="password">the password for the group</param>
        /// <returns>true if the agent has authenticated</returns>
        private static bool Authenticate(string group, string password)
        {
            UUID groupUUID;
            return UUID.TryParse(group, out groupUUID)
                ? Configuration.GROUPS.AsParallel().Any(
                    o =>
                        groupUUID.Equals(o.UUID) &&
                        password.Equals(o.Password, StringComparison.Ordinal))
                : Configuration.GROUPS.AsParallel().Any(
                    o =>
                        o.Name.Equals(group, StringComparison.Ordinal) &&
                        password.Equals(o.Password, StringComparison.Ordinal));
        }

        /// <summary>
        ///     Used to check whether a group has certain permissions for Corrade.
        /// </summary>
        /// <param name="group">the name of the group</param>
        /// <param name="permission">the numeric Corrade permission</param>
        /// <returns>true if the group has permission</returns>
        private static bool HasCorradePermission(string group, int permission)
        {
            UUID groupUUID;
            return !permission.Equals(0) && UUID.TryParse(group, out groupUUID)
                ? Configuration.GROUPS.AsParallel()
                    .Any(o => groupUUID.Equals(o.UUID) && !(o.PermissionMask & permission).Equals(0))
                : Configuration.GROUPS.AsParallel().Any(
                    o =>
                        o.Name.Equals(group, StringComparison.Ordinal) &&
                        !(o.PermissionMask & permission).Equals(0));
        }

        /// <summary>
        ///     Used to check whether a group has a certain notification for Corrade.
        /// </summary>
        /// <param name="group">the name of the group</param>
        /// <param name="notification">the numeric Corrade notification</param>
        /// <returns>true if the group has the notification</returns>
        private static bool GroupHasNotification(string group, uint notification)
        {
            UUID groupUUID;
            return !notification.Equals(0) && UUID.TryParse(group, out groupUUID)
                ? Configuration.GROUPS.AsParallel().Any(
                    o => groupUUID.Equals(o.UUID) &&
                         !(o.NotificationMask & notification).Equals(0))
                : Configuration.GROUPS.AsParallel().Any(
                    o => o.Name.Equals(group, StringComparison.Ordinal) &&
                         !(o.NotificationMask & notification).Equals(0));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Fetches a group.
        /// </summary>
        /// <param name="groupUUID">the UUID of the group</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="group">a group object to store the group profile</param>
        /// <returns>true if the group was found and false otherwise</returns>
        private static bool RequestGroup(UUID groupUUID, int millisecondsTimeout, ref OpenMetaverse.Group group)
        {
            OpenMetaverse.Group localGroup = new OpenMetaverse.Group();
            ManualResetEvent GroupProfileEvent = new ManualResetEvent(false);
            EventHandler<GroupProfileEventArgs> GroupProfileDelegate = (sender, args) =>
            {
                localGroup = args.Group;
                GroupProfileEvent.Set();
            };
            lock (ClientInstanceGroupsLock)
            {
                Client.Groups.GroupProfile += GroupProfileDelegate;
                Client.Groups.RequestGroupProfile(groupUUID);
                if (!GroupProfileEvent.WaitOne(millisecondsTimeout, false))
                {
                    Client.Groups.GroupProfile -= GroupProfileDelegate;
                    return false;
                }
                Client.Groups.GroupProfile -= GroupProfileDelegate;
            }
            group = localGroup;
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Get the parcel of a simulator given a position.
        /// </summary>
        /// <param name="simulator">the simulator containing the parcel</param>
        /// <param name="position">a position within the parcel</param>
        /// <param name="parcel">a parcel object where to store the found parcel</param>
        /// <returns>true if the parcel could be found</returns>
        private static bool GetParcelAtPosition(Simulator simulator, Vector3 position,
            ref Parcel parcel)
        {
            HashSet<Parcel> localParcels = new HashSet<Parcel>();
            ManualResetEvent RequestAllSimParcelsEvent = new ManualResetEvent(false);
            EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedDelegate =
                (sender, args) => RequestAllSimParcelsEvent.Set();
            lock (ClientInstanceParcelsLock)
            {
                Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedDelegate;
                switch (!simulator.IsParcelMapFull())
                {
                    case true:
                        Client.Parcels.RequestAllSimParcels(simulator);
                        break;
                    default:
                        RequestAllSimParcelsEvent.Set();
                        break;
                }
                if (!RequestAllSimParcelsEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                {
                    Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedDelegate;
                    return false;
                }
                Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedDelegate;
                simulator.Parcels.ForEach(currentParcel =>
                {
                    if (!(position.X >= currentParcel.AABBMin.X) || !(position.X <= currentParcel.AABBMax.X) ||
                        !(position.Y >= currentParcel.AABBMin.Y) || !(position.Y <= currentParcel.AABBMax.Y))
                        return;
                    localParcels.Add(currentParcel);
                });
            }
            Parcel localParcel = localParcels.OrderBy(o => Vector3.Distance(o.AABBMin, o.AABBMax)).FirstOrDefault();
            if (localParcel == null)
                return false;
            parcel = localParcel;
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Determines whether a vector falls within a parcel.
        /// </summary>
        /// <param name="position">a 3D vector</param>
        /// <param name="parcel">a parcel</param>
        /// <returns>true if the vector falls within the parcel bounds</returns>
        private static bool IsVectorInParcel(Vector3 position, Parcel parcel)
        {
            return position.X >= parcel.AABBMin.X && position.X <= parcel.AABBMax.X &&
                   position.Y >= parcel.AABBMin.Y && position.Y <= parcel.AABBMax.Y;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Find a named primitive in range (whether attachment or in-world).
        /// </summary>
        /// <param name="item">the name or UUID of the primitive</param>
        /// <param name="range">the range in meters to search for the object</param>
        /// <param name="primitive">a primitive object to store the result</param>
        /// <param name="millisecondsTimeout">the services timeout in milliseconds</param>
        /// <param name="dataTimeout">the data timeout in milliseconds</param>
        /// <returns>true if the primitive could be found</returns>
        private static bool FindPrimitive<T>(T item, float range, ref Primitive primitive, int millisecondsTimeout,
            int dataTimeout)
        {
            HashSet<Primitive> selectedPrimitives = new HashSet<Primitive>();
            HashSet<Primitive> objectsPrimitives =
                new HashSet<Primitive>(GetPrimitives(range, millisecondsTimeout, dataTimeout));
            HashSet<Avatar> objectsAvatars = new HashSet<Avatar>(GetAvatars(range, millisecondsTimeout, dataTimeout));
            Parallel.ForEach(objectsPrimitives, o =>
            {
                switch (o.ParentID)
                {
                    // primitive is a parent and it is in range
                    case 0:
                        if (Vector3.Distance(o.Position, Client.Self.SimPosition) <= range)
                        {
                            if (item is UUID && o.ID.Equals(item))
                            {
                                selectedPrimitives.Add(o);
                                break;
                            }
                            if (item is string)
                            {
                                selectedPrimitives.Add(o);
                            }
                        }
                        break;
                    // primitive is a child
                    default:
                        // find the parent of the primitive
                        Primitive primitiveParent = objectsPrimitives.FirstOrDefault(p => p.LocalID.Equals(o.ParentID));
                        // if the primitive has a parent
                        if (primitiveParent != null)
                        {
                            // if the parent is in range, add the child
                            if (Vector3.Distance(primitiveParent.Position, Client.Self.SimPosition) <= range)
                            {
                                if (item is UUID && o.ID.Equals(item))
                                {
                                    selectedPrimitives.Add(o);
                                    break;
                                }
                                if (item is string)
                                {
                                    selectedPrimitives.Add(o);
                                }
                                break;
                            }
                        }
                        // check if an avatar is the parent of the parent primitive
                        Avatar avatarParent =
                            objectsAvatars.FirstOrDefault(p => p.LocalID.Equals(o.ParentID));
                        // parent avatar not found, this should not happen
                        if (avatarParent != null)
                        {
                            // check if the avatar is in range
                            if (Vector3.Distance(avatarParent.Position, Client.Self.SimPosition) <= range)
                            {
                                if (item is UUID && o.ID.Equals(item))
                                {
                                    selectedPrimitives.Add(o);
                                    break;
                                }
                                if (item is string)
                                {
                                    selectedPrimitives.Add(o);
                                }
                            }
                        }
                        break;
                }
            });
            if (selectedPrimitives.Count.Equals(0)) return false;
            if (!UpdatePrimitives(ref selectedPrimitives, dataTimeout))
                return false;
            primitive =
                selectedPrimitives.FirstOrDefault(
                    o =>
                        (item is UUID && o.ID.Equals(item)) ||
                        (item is string && (item as string).Equals(o.Properties.Name, StringComparison.Ordinal)));
            return primitive != null;
        }

        /// <summary>
        ///     Creates a faceted mesh from a primitive.
        /// </summary>
        /// <param name="primitive">the primitive to convert</param>
        /// <param name="mesher">the mesher to use</param>
        /// <param name="facetedMesh">a reference to an output facted mesh object</param>
        /// <param name="millisecondsTimeout">the services timeout</param>
        /// <returns>true if the mesh could be created successfully</returns>
        private static bool MakeFacetedMesh(Primitive primitive, MeshmerizerR mesher, ref FacetedMesh facetedMesh,
            int millisecondsTimeout)
        {
            if (primitive.Sculpt == null || primitive.Sculpt.SculptTexture.Equals(UUID.Zero))
            {
                facetedMesh = mesher.GenerateFacetedMesh(primitive, DetailLevel.Highest);
                return true;
            }
            if (!primitive.Sculpt.Type.Equals(SculptType.Mesh))
            {
                byte[] assetData = null;
                switch (!Client.Assets.Cache.HasAsset(primitive.Sculpt.SculptTexture))
                {
                    case true:
                        lock (ClientInstanceAssetsLock)
                        {
                            ManualResetEvent ImageDownloadedEvent = new ManualResetEvent(false);
                            Client.Assets.RequestImage(primitive.Sculpt.SculptTexture, (state, args) =>
                            {
                                if (!state.Equals(TextureRequestState.Finished)) return;
                                assetData = args.AssetData;
                                ImageDownloadedEvent.Set();
                            });
                            if (!ImageDownloadedEvent.WaitOne(millisecondsTimeout, false))
                                return false;
                        }
                        Client.Assets.Cache.SaveAssetToCache(primitive.Sculpt.SculptTexture, assetData);
                        break;
                    default:
                        assetData = Client.Assets.Cache.GetCachedAssetBytes(primitive.Sculpt.SculptTexture);
                        break;
                }
                Image image;
                ManagedImage managedImage;
                switch (!OpenJPEG.DecodeToImage(assetData, out managedImage))
                {
                    case true:
                        return false;
                    default:
                        if ((managedImage.Channels & ManagedImage.ImageChannels.Alpha) != 0)
                        {
                            managedImage.ConvertChannels(managedImage.Channels & ~ManagedImage.ImageChannels.Alpha);
                        }
                        image = LoadTGAClass.LoadTGA(new MemoryStream(managedImage.ExportTGA()));
                        break;
                }
                facetedMesh = mesher.GenerateFacetedSculptMesh(primitive, (Bitmap) image, DetailLevel.Highest);
                return true;
            }
            FacetedMesh localFacetedMesh = null;
            ManualResetEvent MeshDownloadedEvent = new ManualResetEvent(false);
            lock (ClientInstanceAssetsLock)
            {
                Client.Assets.RequestMesh(primitive.Sculpt.SculptTexture, (success, meshAsset) =>
                {
                    FacetedMesh.TryDecodeFromAsset(primitive, meshAsset, DetailLevel.Highest, out localFacetedMesh);
                    MeshDownloadedEvent.Set();
                });

                if (!MeshDownloadedEvent.WaitOne(millisecondsTimeout, false))
                    return false;
            }

            if (localFacetedMesh == null)
                return false;

            facetedMesh = localFacetedMesh;
            return true;
        }

        /// <summary>
        ///     Generates a Collada DAE XML Document.
        /// </summary>
        /// <param name="facetedMeshSet">the faceted meshes</param>
        /// <param name="textures">a dictionary of UUID to texture names</param>
        /// <param name="imageFormat">the image export format</param>
        /// <returns>the DAE document</returns>
        /// <remarks>
        ///     This function is a branch-in of several functions of the Radegast Viewer with some changes by Wizardry and
        ///     Steamworks.
        /// </remarks>
        private static XmlDocument GenerateCollada(IEnumerable<FacetedMesh> facetedMeshSet,
            Dictionary<UUID, string> textures, string imageFormat)
        {
            List<MaterialInfo> AllMeterials = new List<MaterialInfo>();

            XmlDocument Doc = new XmlDocument();
            var root = Doc.AppendChild(Doc.CreateElement("COLLADA"));
            root.Attributes.Append(Doc.CreateAttribute("xmlns")).Value = "http://www.collada.org/2005/11/COLLADASchema";
            root.Attributes.Append(Doc.CreateAttribute("version")).Value = "1.4.1";

            var asset = root.AppendChild(Doc.CreateElement("asset"));
            var contributor = asset.AppendChild(Doc.CreateElement("contributor"));
            contributor.AppendChild(Doc.CreateElement("author")).InnerText = "Radegast User";
            contributor.AppendChild(Doc.CreateElement("authoring_tool")).InnerText = "Radegast Collada Export";

            asset.AppendChild(Doc.CreateElement("created")).InnerText = DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss");
            asset.AppendChild(Doc.CreateElement("modified")).InnerText = DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss");

            var unit = asset.AppendChild(Doc.CreateElement("unit"));
            unit.Attributes.Append(Doc.CreateAttribute("name")).Value = "meter";
            unit.Attributes.Append(Doc.CreateAttribute("meter")).Value = "1";

            asset.AppendChild(Doc.CreateElement("up_axis")).InnerText = "Z_UP";

            var images = root.AppendChild(Doc.CreateElement("library_images"));
            var geomLib = root.AppendChild(Doc.CreateElement("library_geometries"));
            var effects = root.AppendChild(Doc.CreateElement("library_effects"));
            var materials = root.AppendChild(Doc.CreateElement("library_materials"));
            var scene = root.AppendChild(Doc.CreateElement("library_visual_scenes"))
                .AppendChild(Doc.CreateElement("visual_scene"));
            scene.Attributes.Append(Doc.CreateAttribute("id")).InnerText = "Scene";
            scene.Attributes.Append(Doc.CreateAttribute("name")).InnerText = "Scene";

            foreach (string name in textures.Values)
            {
                string colladaName = name + "_" + imageFormat.ToLower();
                var image = images.AppendChild(Doc.CreateElement("image"));
                image.Attributes.Append(Doc.CreateAttribute("id")).InnerText = colladaName;
                image.Attributes.Append(Doc.CreateAttribute("name")).InnerText = colladaName;
                image.AppendChild(Doc.CreateElement("init_from")).InnerText =
                    wasURIUnescapeDataString(name + "." + imageFormat.ToLower());
            }

            Func<XmlNode, string, string, List<float>, bool> addSource = (mesh, src_id, param, vals) =>
            {
                var source = mesh.AppendChild(Doc.CreateElement("source"));
                source.Attributes.Append(Doc.CreateAttribute("id")).InnerText = src_id;
                var src_array = source.AppendChild(Doc.CreateElement("float_array"));

                src_array.Attributes.Append(Doc.CreateAttribute("id")).InnerText = string.Format("{0}-{1}", src_id,
                    "array");
                src_array.Attributes.Append(Doc.CreateAttribute("count")).InnerText = vals.Count.ToString();

                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < vals.Count; i++)
                {
                    sb.Append(vals[i].ToString(CultureInfo.InvariantCulture));
                    if (i != vals.Count - 1)
                    {
                        sb.Append(" ");
                    }
                }
                src_array.InnerText = sb.ToString();

                var acc = source.AppendChild(Doc.CreateElement("technique_common"))
                    .AppendChild(Doc.CreateElement("accessor"));
                acc.Attributes.Append(Doc.CreateAttribute("source")).InnerText = string.Format("#{0}-{1}", src_id,
                    "array");
                acc.Attributes.Append(Doc.CreateAttribute("count")).InnerText = (vals.Count/param.Length).ToString();
                acc.Attributes.Append(Doc.CreateAttribute("stride")).InnerText = param.Length.ToString();

                foreach (char c in param)
                {
                    var pX = acc.AppendChild(Doc.CreateElement("param"));
                    pX.Attributes.Append(Doc.CreateAttribute("name")).InnerText = c.ToString();
                    pX.Attributes.Append(Doc.CreateAttribute("type")).InnerText = "float";
                }

                return true;
            };

            Func<Primitive.TextureEntryFace, MaterialInfo> getMaterial = o =>
            {
                MaterialInfo ret = AllMeterials.FirstOrDefault(mat => mat.Matches(o));

                if (ret != null) return ret;
                ret = new MaterialInfo
                {
                    TextureID = o.TextureID,
                    Color = o.RGBA,
                    Name = string.Format("Material{0}", AllMeterials.Count)
                };
                AllMeterials.Add(ret);

                return ret;
            };

            Func<FacetedMesh, List<MaterialInfo>> getMaterials = o =>
            {
                var ret = new List<MaterialInfo>();

                for (int face_num = 0; face_num < o.Faces.Count; face_num++)
                {
                    var te = o.Faces[face_num].TextureFace;
                    if (te.RGBA.A < 0.01f)
                    {
                        continue;
                    }
                    var mat = getMaterial.Invoke(te);
                    if (!ret.Contains(mat))
                    {
                        ret.Add(mat);
                    }
                }
                return ret;
            };

            Func<XmlNode, string, string, FacetedMesh, List<int>, bool> addPolygons =
                (mesh, geomID, materialID, obj, faces_to_include) =>
                {
                    var polylist = mesh.AppendChild(Doc.CreateElement("polylist"));
                    polylist.Attributes.Append(Doc.CreateAttribute("material")).InnerText = materialID;

                    // Vertices semantic
                    {
                        var input = polylist.AppendChild(Doc.CreateElement("input"));
                        input.Attributes.Append(Doc.CreateAttribute("semantic")).InnerText = "VERTEX";
                        input.Attributes.Append(Doc.CreateAttribute("offset")).InnerText = "0";
                        input.Attributes.Append(Doc.CreateAttribute("source")).InnerText = string.Format("#{0}-{1}",
                            geomID, "vertices");
                    }

                    // Normals semantic
                    {
                        var input = polylist.AppendChild(Doc.CreateElement("input"));
                        input.Attributes.Append(Doc.CreateAttribute("semantic")).InnerText = "NORMAL";
                        input.Attributes.Append(Doc.CreateAttribute("offset")).InnerText = "0";
                        input.Attributes.Append(Doc.CreateAttribute("source")).InnerText = string.Format("#{0}-{1}",
                            geomID, "normals");
                    }

                    // UV semantic
                    {
                        var input = polylist.AppendChild(Doc.CreateElement("input"));
                        input.Attributes.Append(Doc.CreateAttribute("semantic")).InnerText = "TEXCOORD";
                        input.Attributes.Append(Doc.CreateAttribute("offset")).InnerText = "0";
                        input.Attributes.Append(Doc.CreateAttribute("source")).InnerText = string.Format("#{0}-{1}",
                            geomID, "map0");
                    }

                    // Save indices
                    var vcount = polylist.AppendChild(Doc.CreateElement("vcount"));
                    var p = polylist.AppendChild(Doc.CreateElement("p"));
                    int index_offset = 0;
                    int num_tris = 0;
                    StringBuilder pBuilder = new StringBuilder();
                    StringBuilder vcountBuilder = new StringBuilder();

                    for (int face_num = 0; face_num < obj.Faces.Count; face_num++)
                    {
                        var face = obj.Faces[face_num];
                        if (faces_to_include == null || faces_to_include.Contains(face_num))
                        {
                            for (int i = 0; i < face.Indices.Count; i++)
                            {
                                int index = index_offset + face.Indices[i];
                                pBuilder.Append(index);
                                pBuilder.Append(" ");
                                if (i%3 == 0)
                                {
                                    vcountBuilder.Append("3 ");
                                    num_tris++;
                                }
                            }
                        }
                        index_offset += face.Vertices.Count;
                    }

                    p.InnerText = pBuilder.ToString().TrimEnd();
                    vcount.InnerText = vcountBuilder.ToString().TrimEnd();
                    polylist.Attributes.Append(Doc.CreateAttribute("count")).InnerText = num_tris.ToString();

                    return true;
                };

            Func<FacetedMesh, MaterialInfo, List<int>> getFacesWithMaterial = (obj, mat) =>
            {
                var ret = new List<int>();
                for (int face_num = 0; face_num < obj.Faces.Count; face_num++)
                {
                    if (mat == getMaterial.Invoke(obj.Faces[face_num].TextureFace))
                    {
                        ret.Add(face_num);
                    }
                }
                return ret;
            };

            Func<Vector3, Quaternion, Vector3, float[]> createSRTMatrix = (scale, q, pos) =>
            {
                float[] mat = new float[16];

                // Transpose the quaternion (don't ask me why)
                q.X = q.X*-1f;
                q.Y = q.Y*-1f;
                q.Z = q.Z*-1f;

                float x2 = q.X + q.X;
                float y2 = q.Y + q.Y;
                float z2 = q.Z + q.Z;
                float xx = q.X*x2;
                float xy = q.X*y2;
                float xz = q.X*z2;
                float yy = q.Y*y2;
                float yz = q.Y*z2;
                float zz = q.Z*z2;
                float wx = q.W*x2;
                float wy = q.W*y2;
                float wz = q.W*z2;

                mat[0] = (1.0f - (yy + zz))*scale.X;
                mat[1] = (xy - wz)*scale.X;
                mat[2] = (xz + wy)*scale.X;
                mat[3] = 0.0f;

                mat[4] = (xy + wz)*scale.Y;
                mat[5] = (1.0f - (xx + zz))*scale.Y;
                mat[6] = (yz - wx)*scale.Y;
                mat[7] = 0.0f;

                mat[8] = (xz - wy)*scale.Z;
                mat[9] = (yz + wx)*scale.Z;
                mat[10] = (1.0f - (xx + yy))*scale.Z;
                mat[11] = 0.0f;

                //Positional parts
                mat[12] = pos.X;
                mat[13] = pos.Y;
                mat[14] = pos.Z;
                mat[15] = 1.0f;

                return mat;
            };

            Func<XmlNode, bool> generateEffects = o =>
            {
                // Effects (face color, alpha)
                foreach (var mat in AllMeterials)
                {
                    var color = mat.Color;
                    var effect = effects.AppendChild(Doc.CreateElement("effect"));
                    effect.Attributes.Append(Doc.CreateAttribute("id")).InnerText = mat.Name + "-fx";
                    var profile = effect.AppendChild(Doc.CreateElement("profile_COMMON"));
                    string colladaName = null;

                    KeyValuePair<UUID, string> kvp = textures.FirstOrDefault(p => p.Key.Equals(mat.TextureID));

                    if (!kvp.Equals(default(KeyValuePair<UUID, string>)))
                    {
                        UUID textID = kvp.Key;
                        colladaName = textures[textID] + "_" + imageFormat.ToLower();
                        var newparam = profile.AppendChild(Doc.CreateElement("newparam"));
                        newparam.Attributes.Append(Doc.CreateAttribute("sid")).InnerText = colladaName + "-surface";
                        var surface = newparam.AppendChild(Doc.CreateElement("surface"));
                        surface.Attributes.Append(Doc.CreateAttribute("type")).InnerText = "2D";
                        surface.AppendChild(Doc.CreateElement("init_from")).InnerText = colladaName;
                        newparam = profile.AppendChild(Doc.CreateElement("newparam"));
                        newparam.Attributes.Append(Doc.CreateAttribute("sid")).InnerText = colladaName + "-sampler";
                        newparam.AppendChild(Doc.CreateElement("sampler2D"))
                            .AppendChild(Doc.CreateElement("source"))
                            .InnerText = colladaName + "-surface";
                    }

                    var t = profile.AppendChild(Doc.CreateElement("technique"));
                    t.Attributes.Append(Doc.CreateAttribute("sid")).InnerText = "common";
                    var phong = t.AppendChild(Doc.CreateElement("phong"));

                    var diffuse = phong.AppendChild(Doc.CreateElement("diffuse"));
                    // Only one <color> or <texture> can appear inside diffuse element
                    if (colladaName != null)
                    {
                        var txtr = diffuse.AppendChild(Doc.CreateElement("texture"));
                        txtr.Attributes.Append(Doc.CreateAttribute("texture")).InnerText = colladaName + "-sampler";
                        txtr.Attributes.Append(Doc.CreateAttribute("texcoord")).InnerText = colladaName;
                    }
                    else
                    {
                        var diffuseColor = diffuse.AppendChild(Doc.CreateElement("color"));
                        diffuseColor.Attributes.Append(Doc.CreateAttribute("sid")).InnerText = "diffuse";
                        diffuseColor.InnerText = string.Format("{0} {1} {2} {3}",
                            color.R.ToString(CultureInfo.InvariantCulture),
                            color.G.ToString(CultureInfo.InvariantCulture),
                            color.B.ToString(CultureInfo.InvariantCulture),
                            color.A.ToString(CultureInfo.InvariantCulture));
                    }

                    phong.AppendChild(Doc.CreateElement("transparency"))
                        .AppendChild(Doc.CreateElement("float"))
                        .InnerText = color.A.ToString(CultureInfo.InvariantCulture);
                }

                return true;
            };

            int prim_nr = 0;
            foreach (var obj in facetedMeshSet)
            {
                int total_num_vertices = 0;
                string name = string.Format("prim{0}", prim_nr++);
                string geomID = name;

                var geom = geomLib.AppendChild(Doc.CreateElement("geometry"));
                geom.Attributes.Append(Doc.CreateAttribute("id")).InnerText = string.Format("{0}-{1}", geomID, "mesh");
                var mesh = geom.AppendChild(Doc.CreateElement("mesh"));

                List<float> position_data = new List<float>();
                List<float> normal_data = new List<float>();
                List<float> uv_data = new List<float>();

                int num_faces = obj.Faces.Count;

                for (int face_num = 0; face_num < num_faces; face_num++)
                {
                    var face = obj.Faces[face_num];
                    total_num_vertices += face.Vertices.Count;

                    foreach (var v in face.Vertices)
                    {
                        position_data.Add(v.Position.X);
                        position_data.Add(v.Position.Y);
                        position_data.Add(v.Position.Z);

                        normal_data.Add(v.Normal.X);
                        normal_data.Add(v.Normal.Y);
                        normal_data.Add(v.Normal.Z);

                        uv_data.Add(v.TexCoord.X);
                        uv_data.Add(v.TexCoord.Y);
                    }
                }

                addSource.Invoke(mesh, string.Format("{0}-{1}", geomID, "positions"), "XYZ", position_data);
                addSource.Invoke(mesh, string.Format("{0}-{1}", geomID, "normals"), "XYZ", normal_data);
                addSource.Invoke(mesh, string.Format("{0}-{1}", geomID, "map0"), "ST", uv_data);

                // Add the <vertices> element
                {
                    var verticesNode = mesh.AppendChild(Doc.CreateElement("vertices"));
                    verticesNode.Attributes.Append(Doc.CreateAttribute("id")).InnerText = string.Format("{0}-{1}",
                        geomID, "vertices");
                    var verticesInput = verticesNode.AppendChild(Doc.CreateElement("input"));
                    verticesInput.Attributes.Append(Doc.CreateAttribute("semantic")).InnerText = "POSITION";
                    verticesInput.Attributes.Append(Doc.CreateAttribute("source")).InnerText = string.Format(
                        "#{0}-{1}", geomID, "positions");
                }

                var objMaterials = getMaterials.Invoke(obj);

                // Add triangles
                foreach (var objMaterial in objMaterials)
                {
                    addPolygons.Invoke(mesh, geomID, objMaterial.Name + "-material", obj,
                        getFacesWithMaterial.Invoke(obj, objMaterial));
                }

                var node = scene.AppendChild(Doc.CreateElement("node"));
                node.Attributes.Append(Doc.CreateAttribute("type")).InnerText = "NODE";
                node.Attributes.Append(Doc.CreateAttribute("id")).InnerText = geomID;
                node.Attributes.Append(Doc.CreateAttribute("name")).InnerText = geomID;

                // Set tranform matrix (node position, rotation and scale)
                var matrix = node.AppendChild(Doc.CreateElement("matrix"));

                var srt = createSRTMatrix.Invoke(obj.Prim.Scale, obj.Prim.Rotation, obj.Prim.Position);
                string matrixVal = "";
                for (int i = 0; i < 4; i++)
                {
                    for (int j = 0; j < 4; j++)
                    {
                        matrixVal += srt[j*4 + i].ToString(CultureInfo.InvariantCulture) + " ";
                    }
                }
                matrix.InnerText = matrixVal.TrimEnd();

                // Geometry of the node
                var nodeGeometry = node.AppendChild(Doc.CreateElement("instance_geometry"));

                // Bind materials
                var tq = nodeGeometry.AppendChild(Doc.CreateElement("bind_material"))
                    .AppendChild(Doc.CreateElement("technique_common"));
                foreach (var objMaterial in objMaterials)
                {
                    var instanceMaterial = tq.AppendChild(Doc.CreateElement("instance_material"));
                    instanceMaterial.Attributes.Append(Doc.CreateAttribute("symbol")).InnerText =
                        string.Format("{0}-{1}", objMaterial.Name, "material");
                    instanceMaterial.Attributes.Append(Doc.CreateAttribute("target")).InnerText =
                        string.Format("#{0}-{1}", objMaterial.Name, "material");
                }

                nodeGeometry.Attributes.Append(Doc.CreateAttribute("url")).InnerText = string.Format("#{0}-{1}", geomID,
                    "mesh");
            }

            generateEffects.Invoke(effects);

            // Materials
            foreach (var objMaterial in AllMeterials)
            {
                var mat = materials.AppendChild(Doc.CreateElement("material"));
                mat.Attributes.Append(Doc.CreateAttribute("id")).InnerText = objMaterial.Name + "-material";
                var matEffect = mat.AppendChild(Doc.CreateElement("instance_effect"));
                matEffect.Attributes.Append(Doc.CreateAttribute("url")).InnerText = string.Format("#{0}-{1}",
                    objMaterial.Name, "fx");
            }

            root.AppendChild(Doc.CreateElement("scene"))
                .AppendChild(Doc.CreateElement("instance_visual_scene"))
                .Attributes.Append(Doc.CreateAttribute("url")).InnerText = "#Scene";

            return Doc;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Fetches all the avatars in-range.
        /// </summary>
        /// <param name="range">the range to extend or contract to</param>
        /// <param name="millisecondsTimeout">the timeout in milliseconds</param>
        /// <param name="dataTimeout">the data timeout in milliseconds</param>
        /// <returns>the avatars in range</returns>
        private static IEnumerable<Avatar> GetAvatars(float range, int millisecondsTimeout, int dataTimeout)
        {
            switch (Client.Self.Movement.Camera.Far < range)
            {
                case true:
                    IEnumerable<Avatar> avatars;
                    wasAdaptiveAlarm RangeUpdateAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
                    EventHandler<AvatarUpdateEventArgs> AvatarUpdateEventHandler =
                        (sender, args) => { RangeUpdateAlarm.Alarm(dataTimeout); };
                    lock (ClientInstanceObjectsLock)
                    {
                        Client.Objects.AvatarUpdate += AvatarUpdateEventHandler;
                        lock (ClientInstanceConfigurationLock)
                        {
                            Client.Self.Movement.Camera.Far = range;
                            RangeUpdateAlarm.Alarm(dataTimeout);
                            RangeUpdateAlarm.Signal.WaitOne(millisecondsTimeout, false);
                            avatars =
                                Client.Network.Simulators.Select(o => o.ObjectsAvatars)
                                    .Select(o => o.Copy().Values)
                                    .SelectMany(o => o);
                            Client.Self.Movement.Camera.Far = Configuration.RANGE;
                        }
                        Client.Objects.AvatarUpdate -= AvatarUpdateEventHandler;
                    }
                    return avatars;
                default:
                    return Client.Network.CurrentSim.ObjectsAvatars.Copy().Values;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Fetches all the primitives in-range.
        /// </summary>
        /// <param name="range">the range to extend or contract to</param>
        /// <param name="millisecondsTimeout">the timeout in milliseconds</param>
        /// <param name="dataTimeout">the data timeout in milliseconds</param>
        /// <returns>the primitives in range</returns>
        private static IEnumerable<Primitive> GetPrimitives(float range, int millisecondsTimeout, int dataTimeout)
        {
            switch (Client.Self.Movement.Camera.Far < range)
            {
                case true:
                    IEnumerable<Primitive> primitives;
                    wasAdaptiveAlarm RangeUpdateAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
                    EventHandler<PrimEventArgs> ObjectUpdateEventHandler =
                        (sender, args) => { RangeUpdateAlarm.Alarm(dataTimeout); };
                    lock (ClientInstanceObjectsLock)
                    {
                        Client.Objects.ObjectUpdate += ObjectUpdateEventHandler;
                        lock (ClientInstanceConfigurationLock)
                        {
                            Client.Self.Movement.Camera.Far = range;
                            RangeUpdateAlarm.Alarm(dataTimeout);
                            RangeUpdateAlarm.Signal.WaitOne(millisecondsTimeout, false);
                            primitives =
                                Client.Network.Simulators.Select(o => o.ObjectsPrimitives)
                                    .Select(o => o.Copy().Values)
                                    .SelectMany(o => o);
                            Client.Self.Movement.Camera.Far = Configuration.RANGE;
                        }
                        Client.Objects.ObjectUpdate -= ObjectUpdateEventHandler;
                    }
                    return primitives;
                default:
                    return Client.Network.CurrentSim.ObjectsPrimitives.Copy().Values;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Updates a set of primitives by scanning their properties.
        /// </summary>
        /// <param name="primitives">a list of primitives to update</param>
        /// <param name="dataTimeout">the timeout for receiving data from the grid</param>
        /// <returns>a list of updated primitives</returns>
        private static bool UpdatePrimitives(ref HashSet<Primitive> primitives, int dataTimeout)
        {
            HashSet<Primitive> scansPrimitives = new HashSet<Primitive>(primitives);
            HashSet<Primitive> localPrimitives = new HashSet<Primitive>();
            Dictionary<UUID, ManualResetEvent> primitiveEvents =
                new Dictionary<UUID, ManualResetEvent>(
                    scansPrimitives
                        .AsParallel().ToDictionary(o => o.ID, p => new ManualResetEvent(false)));
            Dictionary<UUID, Stopwatch> stopWatch = new Dictionary<UUID, Stopwatch>(
                scansPrimitives
                    .AsParallel().ToDictionary(o => o.ID, p => new Stopwatch()));
            HashSet<long> times = new HashSet<long>(new[] {(long) dataTimeout});
            EventHandler<ObjectPropertiesEventArgs> ObjectPropertiesEventHandler = (sender, args) =>
            {
                KeyValuePair<UUID, ManualResetEvent> queueElement =
                    primitiveEvents.AsParallel().FirstOrDefault(o => o.Key.Equals(args.Properties.ObjectID));
                if (queueElement.Equals(default(KeyValuePair<UUID, ManualResetEvent>))) return;
                Primitive updatedPrimitive =
                    scansPrimitives.AsParallel().FirstOrDefault(o => o.ID.Equals(args.Properties.ObjectID));
                if (updatedPrimitive == null) return;
                updatedPrimitive.Properties = args.Properties;
                localPrimitives.Add(updatedPrimitive);
                stopWatch[queueElement.Key].Stop();
                times.Add(stopWatch[queueElement.Key].ElapsedMilliseconds);
                queueElement.Value.Set();
            };
            lock (ClientInstanceObjectsLock)
            {
                Parallel.ForEach(primitiveEvents,
                    new ParallelOptions
                    {
                        // Don't choke the chicken.
                        MaxDegreeOfParallelism = Environment.ProcessorCount > 1 ? Environment.ProcessorCount - 1 : 1
                    }, o =>
                    {
                        Primitive queryPrimitive =
                            scansPrimitives.AsParallel().SingleOrDefault(p => p.ID.Equals(o.Key));
                        if (queryPrimitive == null) return;
                        stopWatch[queryPrimitive.ID].Start();
                        Client.Objects.ObjectProperties += ObjectPropertiesEventHandler;
                        Client.Objects.SelectObject(
                            Client.Network.Simulators.FirstOrDefault(p => p.Handle.Equals(queryPrimitive.RegionHandle)),
                            queryPrimitive.LocalID,
                            true);
                        int average = (int) times.Average();
                        primitiveEvents[queryPrimitive.ID].WaitOne(
                            average != 0 ? average : dataTimeout, false);
                        Client.Objects.ObjectProperties -= ObjectPropertiesEventHandler;
                    });
            }
            if (!scansPrimitives.Count.Equals(localPrimitives.Count))
                return false;
            primitives = localPrimitives;
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Updates a set of avatars by scanning their profile data.
        /// </summary>
        /// <param name="avatars">a list of avatars to update</param>
        /// <param name="millisecondsTimeout">the amount of time in milliseconds to timeout</param>
        /// <param name="dataTimeout">the data timeout</param>
        /// <returns>a list of updated avatars</returns>
        private static bool UpdateAvatars(ref HashSet<Avatar> avatars, int millisecondsTimeout,
            int dataTimeout)
        {
            HashSet<Avatar> scansAvatars = new HashSet<Avatar>(avatars);
            Dictionary<UUID, wasAdaptiveAlarm> avatarAlarms =
                new Dictionary<UUID, wasAdaptiveAlarm>(scansAvatars.AsParallel()
                    .ToDictionary(o => o.ID, p => new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE)));
            Dictionary<UUID, Avatar> avatarUpdates = new Dictionary<UUID, Avatar>(scansAvatars.AsParallel()
                .ToDictionary(o => o.ID, p => p));
            object LockObject = new object();
            EventHandler<AvatarInterestsReplyEventArgs> AvatarInterestsReplyEventHandler = (sender, args) =>
            {
                avatarAlarms[args.AvatarID].Alarm(dataTimeout);
                avatarUpdates[args.AvatarID].ProfileInterests = args.Interests;
            };
            EventHandler<AvatarPropertiesReplyEventArgs> AvatarPropertiesReplyEventHandler =
                (sender, args) =>
                {
                    avatarAlarms[args.AvatarID].Alarm(dataTimeout);
                    avatarUpdates[args.AvatarID].ProfileProperties = args.Properties;
                };
            EventHandler<AvatarGroupsReplyEventArgs> AvatarGroupsReplyEventHandler = (sender, args) =>
            {
                avatarAlarms[args.AvatarID].Alarm(dataTimeout);
                lock (LockObject)
                {
                    avatarUpdates[args.AvatarID].Groups.AddRange(args.Groups.Select(o => o.GroupID));
                }
            };
            EventHandler<AvatarPicksReplyEventArgs> AvatarPicksReplyEventHandler =
                (sender, args) => avatarAlarms[args.AvatarID].Alarm(dataTimeout);
            EventHandler<AvatarClassifiedReplyEventArgs> AvatarClassifiedReplyEventHandler =
                (sender, args) => avatarAlarms[args.AvatarID].Alarm(dataTimeout);
            lock (ClientInstanceAvatarsLock)
            {
                Parallel.ForEach(scansAvatars, new ParallelOptions
                {
                    MaxDegreeOfParallelism = Environment.ProcessorCount > 1 ? Environment.ProcessorCount - 1 : 1
                }, o =>
                {
                    Client.Avatars.AvatarInterestsReply += AvatarInterestsReplyEventHandler;
                    Client.Avatars.AvatarPropertiesReply += AvatarPropertiesReplyEventHandler;
                    Client.Avatars.AvatarGroupsReply += AvatarGroupsReplyEventHandler;
                    Client.Avatars.AvatarPicksReply += AvatarPicksReplyEventHandler;
                    Client.Avatars.AvatarClassifiedReply += AvatarClassifiedReplyEventHandler;
                    Client.Avatars.RequestAvatarProperties(o.ID);
                    Client.Avatars.RequestAvatarPicks(o.ID);
                    Client.Avatars.RequestAvatarClassified(o.ID);
                    avatarAlarms[o.ID].Signal.WaitOne(millisecondsTimeout, false);
                    Client.Avatars.AvatarInterestsReply -= AvatarInterestsReplyEventHandler;
                    Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesReplyEventHandler;
                    Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                    Client.Avatars.AvatarPicksReply -= AvatarPicksReplyEventHandler;
                    Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedReplyEventHandler;
                });
            }

            avatars = new HashSet<Avatar>(avatarUpdates.Values);

            return
                !avatarUpdates.Values.AsParallel()
                    .Any(
                        o =>
                            o == null || (
                                o.ProfileInterests.Equals(default(Avatar.Interests)) &&
                                o.ProfileProperties.Equals(default(Avatar.AvatarProperties)) &&
                                o.Groups.Count.Equals(0)));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Requests the UUIDs of all the current groups.
        /// </summary>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="groups">a hashset where to store the UUIDs</param>
        /// <returns>true if the current groups could be fetched</returns>
        private static bool directGetCurrentGroups(int millisecondsTimeout, int dataTimeout, ref HashSet<UUID> groups)
        {
            wasAdaptiveAlarm CurrentGroupsReceivedAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
            List<UUID> currentGroups = new List<UUID>();
            object LockObject = new object();
            EventHandler<CurrentGroupsEventArgs> CurrentGroupsEventHandler = (sender, args) =>
            {
                CurrentGroupsReceivedAlarm.Alarm(dataTimeout);
                lock (LockObject)
                {
                    currentGroups.AddRange(args.Groups.Select(o => o.Value.ID));
                }
            };
            Client.Groups.CurrentGroups += CurrentGroupsEventHandler;
            Client.Groups.RequestCurrentGroups();
            if (!CurrentGroupsReceivedAlarm.Signal.WaitOne(millisecondsTimeout, false))
            {
                Client.Groups.CurrentGroups -= CurrentGroupsEventHandler;
                return false;
            }
            Client.Groups.CurrentGroups -= CurrentGroupsEventHandler;
            lock (LockObject)
            {
                if (currentGroups.Count.Equals(0)) return false;
                groups = new HashSet<UUID>(currentGroups);
            }
            return true;
        }

        /// <summary>
        ///     A wrapper for retrieveing all the current groups that implements caching.
        /// </summary>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="groups">a hashset where to store the UUIDs</param>
        /// <returns>true if the current groups could be fetched</returns>
        private static bool GetCurrentGroups(int millisecondsTimeout, int dataTimeout, ref HashSet<UUID> groups)
        {
            lock (Cache.Locks.CurrentGroupsCacheLock)
            {
                if (!Cache.CurrentGroupsCache.Count.Equals(0))
                {
                    groups = Cache.CurrentGroupsCache;
                    return true;
                }
            }
            bool succeeded;
            lock (ClientInstanceGroupsLock)
            {
                succeeded = directGetCurrentGroups(millisecondsTimeout, dataTimeout, ref groups);
            }
            if (succeeded)
            {
                lock (Cache.Locks.GroupCacheLock)
                {
                    Cache.CurrentGroupsCache = groups;
                }
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Get all worn attachments.
        /// </summary>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <returns>attachment points by primitives</returns>
        private static IEnumerable<KeyValuePair<Primitive, AttachmentPoint>> GetAttachments(
            int millisecondsTimeout)
        {
            HashSet<Primitive> primitives;
            lock (ClientInstanceNetworkLock)
            {
                primitives =
                    new HashSet<Primitive>(Client.Network.CurrentSim.ObjectsPrimitives.FindAll(
                        o => o.ParentID.Equals(Client.Self.LocalID)));
            }
            Hashtable primitiveQueue = new Hashtable(primitives.ToDictionary(o => o.ID, o => o.LocalID));
            ManualResetEvent ObjectPropertiesEvent = new ManualResetEvent(false);
            EventHandler<ObjectPropertiesEventArgs> ObjectPropertiesEventHandler = (sender, args) =>
            {
                primitiveQueue.Remove(args.Properties.ObjectID);
                if (!primitiveQueue.Count.Equals(0)) return;
                ObjectPropertiesEvent.Set();
            };
            lock (ClientInstanceObjectsLock)
            {
                Client.Objects.ObjectProperties += ObjectPropertiesEventHandler;
                Client.Objects.SelectObjects(Client.Network.CurrentSim, primitiveQueue.Values.Cast<uint>().ToArray(),
                    true);
                if (ObjectPropertiesEvent.WaitOne(millisecondsTimeout, false))
                {
                    Client.Objects.ObjectProperties -= ObjectPropertiesEventHandler;
                    foreach (KeyValuePair<Primitive, AttachmentPoint> pair in primitives
                        .Select(
                            o =>
                                new KeyValuePair<Primitive, AttachmentPoint>(o,
                                    (AttachmentPoint) (((o.PrimData.State & 0xF0) >> 4) |
                                                       ((o.PrimData.State & ~0xF0) << 4)))))
                    {
                        yield return pair;
                    }
                }
                Client.Objects.ObjectProperties -= ObjectPropertiesEventHandler;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Gets the inventory wearables that are currently being worn.
        /// </summary>
        /// <param name="root">the folder to start the search from</param>
        /// <returns>key value pairs of wearables by name</returns>
        private static IEnumerable<KeyValuePair<AppearanceManager.WearableData, WearableType>> GetWearables(
            InventoryNode root)
        {
            InventoryFolder inventoryFolder = Client.Inventory.Store[root.Data.UUID] as InventoryFolder;
            if (inventoryFolder == null)
            {
                InventoryItem inventoryItem = Client.Inventory.Store[root.Data.UUID] as InventoryItem;
                if (inventoryItem != null)
                {
                    WearableType wearableType = Client.Appearance.IsItemWorn(inventoryItem);
                    if (!wearableType.Equals(WearableType.Invalid))
                    {
                        foreach (
                            KeyValuePair<WearableType, AppearanceManager.WearableData> wearable in
                                Client.Appearance.GetWearables()
                                    .AsParallel().Where(o => o.Value.ItemID.Equals(inventoryItem.UUID)))
                        {
                            yield return
                                new KeyValuePair<AppearanceManager.WearableData, WearableType>(wearable.Value,
                                    wearable.Key);
                        }
                    }
                    yield break;
                }
            }
            foreach (
                KeyValuePair<AppearanceManager.WearableData, WearableType> item in
                    root.Nodes.Values.AsParallel().SelectMany(GetWearables))
            {
                yield return item;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// ///
        /// <summary>
        ///     Fetches items by searching the inventory starting with an inventory
        ///     node where the search criteria finds:
        ///     - name as string
        ///     - name as Regex
        ///     - UUID as UUID
        /// </summary>
        /// <param name="root">the node to start the search from</param>
        /// <param name="criteria">the name, UUID or Regex of the item to be found</param>
        /// <returns>a list of items matching the item name</returns>
        private static IEnumerable<T> FindInventory<T>(InventoryNode root, object criteria)
        {
            if ((criteria is Regex && (criteria as Regex).IsMatch(root.Data.Name)) ||
                (criteria is string &&
                 (criteria as string).Equals(root.Data.Name, StringComparison.Ordinal)) ||
                (criteria is UUID && criteria.Equals(root.Data.UUID)))
            {
                if (typeof (T) == typeof (InventoryNode))
                {
                    yield return (T) (object) root;
                }
                if (typeof (T) == typeof (InventoryBase))
                {
                    yield return (T) (object) Client.Inventory.Store[root.Data.UUID];
                }
            }
            foreach (T item in root.Nodes.Values.AsParallel().SelectMany(node => FindInventory<T>(node, criteria)))
            {
                yield return item;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// ///
        /// <summary>
        ///     Fetches items and their full path from the inventory starting with
        ///     an inventory node where the search criteria finds:
        ///     - name as string
        ///     - name as Regex
        ///     - UUID as UUID
        /// </summary>
        /// <param name="root">the node to start the search from</param>
        /// <param name="criteria">the name, UUID or Regex of the item to be found</param>
        /// <param name="prefix">any prefix to append to the found paths</param>
        /// <returns>items matching criteria and their full inventoy path</returns>
        private static IEnumerable<KeyValuePair<T, LinkedList<string>>> FindInventoryPath<T>(
            InventoryNode root, object criteria, LinkedList<string> prefix)
        {
            if ((criteria is Regex && (criteria as Regex).IsMatch(root.Data.Name)) ||
                (criteria is string &&
                 (criteria as string).Equals(root.Data.Name, StringComparison.Ordinal)) ||
                (criteria is UUID && criteria.Equals(root.Data.UUID)))
            {
                if (typeof (T) == typeof (InventoryBase))
                {
                    yield return
                        new KeyValuePair<T, LinkedList<string>>((T) (object) Client.Inventory.Store[root.Data.UUID],
                            new LinkedList<string>(
                                prefix.Concat(new[] {root.Data.Name})));
                }
                if (typeof (T) == typeof (InventoryNode))
                {
                    yield return
                        new KeyValuePair<T, LinkedList<string>>((T) (object) root,
                            new LinkedList<string>(
                                prefix.Concat(new[] {root.Data.Name})));
                }
            }
            foreach (
                KeyValuePair<T, LinkedList<string>> o in
                    root.Nodes.Values.AsParallel()
                        .SelectMany(o => FindInventoryPath<T>(o, criteria, new LinkedList<string>(
                            prefix.Concat(new[] {root.Data.Name})))))
            {
                yield return o;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Gets all the items from an inventory folder and returns the items.
        /// </summary>
        /// <param name="rootFolder">a folder from which to search</param>
        /// <param name="folder">the folder to search for</param>
        /// <returns>a list of items from the folder</returns>
        private static IEnumerable<T> GetInventoryFolderContents<T>(InventoryNode rootFolder,
            string folder)
        {
            foreach (
                InventoryNode node in
                    rootFolder.Nodes.Values.AsParallel()
                        .Where(node => node.Data is InventoryFolder && node.Data.Name.Equals(folder))
                )
            {
                foreach (InventoryNode item in node.Nodes.Values)
                {
                    if (typeof (T) == typeof (InventoryNode))
                    {
                        yield return (T) (object) item;
                    }
                    if (typeof (T) == typeof (InventoryBase))
                    {
                        yield return (T) (object) Client.Inventory.Store[item.Data.UUID];
                    }
                }
                break;
            }
        }

        /// <summary>
        ///     Posts messages to console or log-files.
        /// </summary>
        /// <param name="messages">a list of messages</param>
        private static void Feedback(params string[] messages)
        {
            List<string> output = new List<string>
            {
                CORRADE_CONSTANTS.CORRADE,
                string.Format(CultureInfo.InvariantCulture, "[{0}]",
                    DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP, DateTimeFormatInfo.InvariantInfo))
            };

            output.AddRange(messages.Select(message => message));

            // Attempt to write to log file,
            if (Configuration.CLIENT_LOG_ENABLED)
            {
                try
                {
                    lock (ClientLogFileLock)
                    {
                        using (
                            StreamWriter logWriter =
                                File.AppendText(Configuration.CLIENT_LOG_FILE))
                        {
                            logWriter.WriteLine(string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR, output.ToArray()));
                            //logWriter.Flush();
                        }
                    }
                }
                catch (Exception ex)
                {
                    // or fail and append the fail message.
                    output.Add(string.Format(CultureInfo.InvariantCulture, "{0} {1}",
                        wasGetDescriptionFromEnumValue(
                            ConsoleError.COULD_NOT_WRITE_TO_CLIENT_LOG_FILE),
                        ex.Message));
                }
            }

            if (!Environment.UserInteractive)
            {
                switch (Environment.OSVersion.Platform)
                {
                    case PlatformID.Win32NT:
                        CorradeEventLog.WriteEntry(string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR, output.ToArray()),
                            EventLogEntryType.Information);
                        break;
                }
                return;
            }

            Console.WriteLine(string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR, output.ToArray()));
        }

        public static int Main(string[] args)
        {
            if (Environment.UserInteractive)
            {
                if (!args.Length.Equals(0))
                {
                    string action = string.Empty;
                    for (int i = 0; i < args.Length; ++i)
                    {
                        switch (args[i].ToUpper())
                        {
                            case "/INSTALL":
                                action = "INSTALL";
                                break;
                            case "/UNINSTALL":
                                action = "UNINSTALL";
                                break;
                            case "/NAME":
                                if (args.Length > i + 1)
                                {
                                    InstalledServiceName = args[++i];
                                }
                                break;
                        }
                    }
                    switch (action)
                    {
                        case "INSTALL":
                            return InstallService();
                        case "UNINSTALL":
                            return UninstallService();
                    }
                }
                // run interactively and log to console
                Corrade corrade = new Corrade();
                corrade.OnStart(null);
                return 0;
            }

            // run as a standard service
            Run(new Corrade());
            return 0;
        }

        private static int InstallService()
        {
            try
            {
                // install the service with the Windows Service Control Manager (SCM)
                ManagedInstallerClass.InstallHelper(new[] {Assembly.GetExecutingAssembly().Location});
            }
            catch (Exception ex)
            {
                if (ex.InnerException != null && ex.InnerException.GetType() == typeof (Win32Exception))
                {
                    Win32Exception we = (Win32Exception) ex.InnerException;
                    Console.WriteLine("Error(0x{0:X}): Service already installed!", we.ErrorCode);
                    return we.ErrorCode;
                }
                Console.WriteLine(ex.ToString());
                return -1;
            }

            return 0;
        }

        private static int UninstallService()
        {
            try
            {
                // uninstall the service from the Windows Service Control Manager (SCM)
                ManagedInstallerClass.InstallHelper(new[] {"/u", Assembly.GetExecutingAssembly().Location});
            }
            catch (Exception ex)
            {
                if (ex.InnerException.GetType() == typeof (Win32Exception))
                {
                    Win32Exception we = (Win32Exception) ex.InnerException;
                    Console.WriteLine("Error(0x{0:X}): Service not installed!", we.ErrorCode);
                    return we.ErrorCode;
                }
                Console.WriteLine(ex.ToString());
                return -1;
            }

            return 0;
        }

        protected override void OnStop()
        {
            base.OnStop();
            ConnectionSemaphores['u'].Set();
        }

        protected override void OnStart(string[] args)
        {
            base.OnStart(args);
            //Debugger.Break();
            programThread = new Thread(new Corrade().Program);
            programThread.Start();
        }

        // Main entry point.
        public void Program()
        {
            // Set the current directory to the service directory.
            Directory.SetCurrentDirectory(AppDomain.CurrentDomain.BaseDirectory);
            // Load the configuration file.
            Configuration.Load(CORRADE_CONSTANTS.CONFIGURATION_FILE);
            // Write the logo.
            foreach (string line in CORRADE_CONSTANTS.LOGO)
            {
                Feedback(line);
            }
            // Branch on platform and set-up termination handlers.
            switch (Environment.OSVersion.Platform)
            {
                case PlatformID.Win32NT:
                    if (Environment.UserInteractive)
                    {
                        // Setup console handler.
                        ConsoleEventHandler += ConsoleCtrlCheck;
                        NativeMethods.SetConsoleCtrlHandler(ConsoleEventHandler, true);
                        if (Environment.UserInteractive)
                        {
                            Console.CancelKeyPress +=
                                (sender, args) => ConnectionSemaphores['u'].Set();
                        }
                    }
                    break;
            }
            // Set-up watcher for dynamically reading the configuration file.
            FileSystemWatcher configurationWatcher = new FileSystemWatcher
            {
                Path = Directory.GetCurrentDirectory(),
                Filter = CORRADE_CONSTANTS.CONFIGURATION_FILE,
                NotifyFilter = NotifyFilters.LastWrite
            };
            FileSystemEventHandler HandleConfigurationFileChanged =
                (sender, args) => ConfigurationChangedTimer.Change(1000, 0);
            configurationWatcher.Changed += HandleConfigurationFileChanged;
            configurationWatcher.EnableRaisingEvents = true;
            // Set-up the AIML bot in case it has been enabled.
            AIMLBotConfigurationWatcher.Path = wasPathCombine(Directory.GetCurrentDirectory(),
                AIML_BOT_CONSTANTS.DIRECTORY);
            AIMLBotConfigurationWatcher.NotifyFilter = NotifyFilters.LastWrite;
            FileSystemEventHandler HandleAIMLBotConfigurationChanged =
                (sender, args) => AIMLConfigurationChangedTimer.Change(1000, 0);
            AIMLBotConfigurationWatcher.Changed += HandleAIMLBotConfigurationChanged;
            // Network Tweaks
            ServicePointManager.DefaultConnectionLimit = Configuration.CONNECTION_LIMIT;
            ServicePointManager.UseNagleAlgorithm = Configuration.USE_NAGGLE;
            ServicePointManager.Expect100Continue = Configuration.USE_EXPECT100CONTINUE;
            ServicePointManager.MaxServicePointIdleTime = Configuration.CONNECTION_IDLE_TIME;
            // Suppress standard OpenMetaverse logs, we have better ones.
            Settings.LOG_LEVEL = Helpers.LogLevel.None;
            Client.Settings.ALWAYS_REQUEST_PARCEL_ACL = true;
            Client.Settings.ALWAYS_DECODE_OBJECTS = true;
            Client.Settings.ALWAYS_REQUEST_OBJECTS = true;
            Client.Settings.SEND_AGENT_APPEARANCE = true;
            Client.Settings.AVATAR_TRACKING = true;
            Client.Settings.OBJECT_TRACKING = true;
            Client.Settings.PARCEL_TRACKING = true;
            Client.Settings.ALWAYS_REQUEST_PARCEL_DWELL = true;
            Client.Settings.ALWAYS_REQUEST_PARCEL_ACL = true;
            Client.Settings.SEND_AGENT_UPDATES = true;
            // Smoother movement for autopilot.
            Client.Settings.DISABLE_AGENT_UPDATE_DUPLICATE_CHECK = true;
            Client.Settings.ENABLE_CAPS = true;
            Client.Settings.USE_ASSET_CACHE = true;
            // More precision for object and avatar tracking updates.
            Client.Settings.USE_INTERPOLATION_TIMER = true;
            Client.Settings.FETCH_MISSING_INVENTORY = true;
            Client.Settings.HTTP_INVENTORY = true;
            // Transfer textures over HTTP if possible.
            Client.Settings.USE_HTTP_TEXTURES = true;
            // Needed for commands dealing with terrain height.
            Client.Settings.STORE_LAND_PATCHES = true;
            // Decode simulator statistics.
            Client.Settings.ENABLE_SIMSTATS = true;
            // Enable multiple simulators
            Client.Settings.MULTIPLE_SIMS = true;
            // Check TOS
            if (!Configuration.TOS_ACCEPTED)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.TOS_NOT_ACCEPTED));
                Environment.Exit(Configuration.EXIT_CODE_ABNORMAL);
            }
            // Proceed to log-in.
            LoginParams login = new LoginParams(
                Client,
                Configuration.FIRST_NAME,
                Configuration.LAST_NAME,
                Configuration.PASSWORD,
                CORRADE_CONSTANTS.CLIENT_CHANNEL,
                CORRADE_CONSTANTS.CORRADE_VERSION.ToString(CultureInfo.InvariantCulture),
                Configuration.LOGIN_URL)
            {
                Author = CORRADE_CONSTANTS.WIZARDRY_AND_STEAMWORKS,
                AgreeToTos = Configuration.TOS_ACCEPTED,
                Start = Configuration.START_LOCATION,
                UserAgent =
                    string.Format("{0}/{1} ({2})", CORRADE_CONSTANTS.CORRADE, CORRADE_CONSTANTS.CORRADE_VERSION,
                        CORRADE_CONSTANTS.WIZARDRY_AND_STEAMWORKS_WEBSITE)
            };
            // Set the outgoing IP address if specified in the configuration file.
            if (!string.IsNullOrEmpty(Configuration.BIND_IP_ADDRESS))
            {
                try
                {
                    Settings.BIND_ADDR = IPAddress.Parse(Configuration.BIND_IP_ADDRESS);
                }
                catch (Exception)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNKNOWN_IP_ADDRESS));
                    Environment.Exit(Configuration.EXIT_CODE_ABNORMAL);
                }
            }
            // Set the ID0 if specified in the configuration file.
            if (!string.IsNullOrEmpty(Configuration.DRIVE_IDENTIFIER_HASH))
            {
                login.ID0 = Utils.MD5String(Configuration.DRIVE_IDENTIFIER_HASH);
            }
            // Set the MAC if specified in the configuration file.
            if (!string.IsNullOrEmpty(Configuration.NETWORK_CARD_MAC))
            {
                login.MAC = Utils.MD5String(Configuration.NETWORK_CARD_MAC);
            }
            // Load Corrade caches.
            LoadCorradeCache.Invoke();
            // Load Corrade states.
            lock (GroupNotificationsLock)
            {
                LoadNotificationState.Invoke();
            }
            lock (InventoryOffersLock)
            {
                LoadInventoryOffersState.Invoke();
            }
            // Start the HTTP Server if it is supported
            Thread HTTPListenerThread = null;
            HttpListener HTTPListener = null;
            if (Configuration.ENABLE_HTTP_SERVER && !HttpListener.IsSupported)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_ERROR),
                    wasGetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_NOT_SUPPORTED));
            }
            if (Configuration.ENABLE_HTTP_SERVER && HttpListener.IsSupported)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.STARTING_HTTP_SERVER));
                HTTPListenerThread = new Thread(() =>
                {
                    try
                    {
                        using (HTTPListener = new HttpListener())
                        {
                            HTTPListener.Prefixes.Add(Configuration.HTTP_SERVER_PREFIX);
                            HTTPListener.Start();
                            while (HTTPListener.IsListening)
                            {
                                IAsyncResult result = HTTPListener.BeginGetContext(ProcessHTTPRequest, HTTPListener);
                                result.AsyncWaitHandle.WaitOne(Configuration.HTTP_SERVER_TIMEOUT, false);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Feedback(wasGetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_ERROR), ex.Message);
                    }
                }) {IsBackground = true, Priority = ThreadPriority.BelowNormal};
                HTTPListenerThread.Start();
            }
            // Start the callback thread to send callbacks.
            Thread CallbackThread = new Thread(() =>
            {
                do
                {
                    Thread.Sleep(Configuration.CALLBACK_THROTTLE);
                    lock (CallbackQueueLock)
                    {
                        if (CallbackQueue.Count.Equals(0)) continue;
                    }
                    CallbackQueueElement callbackQueueElement;
                    lock (CallbackQueueLock)
                    {
                        callbackQueueElement = CallbackQueue.Dequeue();
                    }
                    try
                    {
                        if (!callbackQueueElement.Equals(default(CallbackQueueElement)))
                        {
                            wasPOST(callbackQueueElement.URL, callbackQueueElement.message,
                                Configuration.CALLBACK_TIMEOUT);
                        }
                    }
                    catch (Exception ex)
                    {
                        Feedback(wasGetDescriptionFromEnumValue(ConsoleError.CALLBACK_ERROR),
                            callbackQueueElement.URL,
                            ex.Message);
                    }
                } while (runCallbackThread);
            }) {IsBackground = true, Priority = ThreadPriority.BelowNormal};
            CallbackThread.Start();
            Thread NotificationThread = new Thread(() =>
            {
                do
                {
                    Thread.Sleep(Configuration.NOTIFICATION_THROTTLE);
                    lock (NotificationQueueLock)
                    {
                        if (NotificationQueue.Count.Equals(0)) continue;
                    }
                    NotificationQueueElement notificationQueueElement;
                    lock (NotificationQueueLock)
                    {
                        notificationQueueElement = NotificationQueue.Dequeue();
                    }
                    try
                    {
                        if (!notificationQueueElement.Equals(default(NotificationQueueElement)))
                        {
                            wasPOST(notificationQueueElement.URL, notificationQueueElement.message,
                                Configuration.NOTIFICATION_TIMEOUT);
                        }
                    }
                    catch (Exception ex)
                    {
                        Feedback(wasGetDescriptionFromEnumValue(ConsoleError.NOTIFICATION_ERROR),
                            notificationQueueElement.URL,
                            ex.Message);
                    }
                } while (runNotificationThread);
            }) {IsBackground = true, Priority = ThreadPriority.BelowNormal};
            NotificationThread.Start();
            // Start sphere effect expiration thread
            Thread EffectsExpirationThread = new Thread(() =>
            {
                do
                {
                    Thread.Sleep(1000);
                    lock (SphereEffectsLock)
                    {
                        SphereEffects.RemoveWhere(o => DateTime.Compare(DateTime.Now, o.Termination) > 0);
                    }
                    lock (BeamEffectsLock)
                    {
                        BeamEffects.RemoveWhere(o => DateTime.Compare(DateTime.Now, o.Termination) > 0);
                    }
                } while (runEffectsExpirationThread);
            }) {IsBackground = true, Priority = ThreadPriority.BelowNormal};
            EffectsExpirationThread.Start();
            // Install non-dynamic global event handlers.
            Client.Inventory.InventoryObjectOffered += HandleInventoryObjectOffered;
            Client.Network.LoginProgress += HandleLoginProgress;
            Client.Appearance.AppearanceSet += HandleAppearanceSet;
            Client.Network.SimConnected += HandleSimulatorConnected;
            Client.Network.Disconnected += HandleDisconnected;
            Client.Network.SimDisconnected += HandleSimulatorDisconnected;
            Client.Network.EventQueueRunning += HandleEventQueueRunning;
            Client.Self.TeleportProgress += HandleTeleportProgress;
            Client.Self.ChatFromSimulator += HandleChatFromSimulator;
            Client.Groups.GroupJoinedReply += HandleGroupJoined;
            Client.Groups.GroupLeaveReply += HandleGroupLeave;
            // Each Instant Message is processed in its own thread.
            Client.Self.IM += (sender, args) => CorradeThreadPool[CorradeThreadType.INSTANT_MESSAGE].Spawn(
                () => HandleSelfIM(sender, args),
                Configuration.MAXIMUM_INSTANT_MESSAGE_THREADS);
            // Log-in to the grid.
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.LOGGING_IN));
            Client.Network.Login(login);
            /*
             * The main thread spins around waiting for the semaphores to become invalidated,
             * at which point Corrade will consider its connection to the grid severed and
             * will terminate.
             *
             */
            WaitHandle.WaitAny(ConnectionSemaphores.Values.Select(o => (WaitHandle) o).ToArray());
            // Now log-out.
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.LOGGING_OUT));
            // Uninstall all installed handlers
            Client.Self.IM -= HandleSelfIM;
            Client.Network.SimChanged -= HandleRadarObjects;
            Client.Objects.AvatarUpdate -= HandleAvatarUpdate;
            Client.Objects.ObjectUpdate -= HandleObjectUpdate;
            Client.Objects.KillObject -= HandleKillObject;
            Client.Self.LoadURL -= HandleLoadURL;
            Client.Self.MoneyBalanceReply -= HandleMoneyBalance;
            Client.Network.SimChanged -= HandleSimChanged;
            Client.Self.RegionCrossed -= HandleRegionCrossed;
            Client.Self.MeanCollision -= HandleMeanCollision;
            Client.Avatars.ViewerEffectLookAt -= HandleViewerEffect;
            Client.Avatars.ViewerEffectPointAt -= HandleViewerEffect;
            Client.Avatars.ViewerEffect -= HandleViewerEffect;
            Client.Objects.TerseObjectUpdate -= HandleTerseObjectUpdate;
            Client.Self.ScriptDialog -= HandleScriptDialog;
            Client.Self.ChatFromSimulator -= HandleChatFromSimulator;
            Client.Self.MoneyBalance -= HandleMoneyBalance;
            Client.Self.AlertMessage -= HandleAlertMessage;
            Client.Self.ScriptQuestion -= HandleScriptQuestion;
            Client.Self.TeleportProgress -= HandleTeleportProgress;
            Client.Friends.FriendRightsUpdate -= HandleFriendRightsUpdate;
            Client.Friends.FriendOffline -= HandleFriendOnlineStatus;
            Client.Friends.FriendOnline -= HandleFriendOnlineStatus;
            Client.Friends.FriendshipResponse -= HandleFriendShipResponse;
            Client.Friends.FriendshipOffered -= HandleFriendshipOffered;
            Client.Network.EventQueueRunning -= HandleEventQueueRunning;
            Client.Network.SimDisconnected -= HandleSimulatorDisconnected;
            Client.Network.Disconnected -= HandleDisconnected;
            Client.Network.SimConnected -= HandleSimulatorConnected;
            Client.Appearance.AppearanceSet -= HandleAppearanceSet;
            Client.Network.LoginProgress -= HandleLoginProgress;
            Client.Inventory.InventoryObjectOffered -= HandleInventoryObjectOffered;
            // Save Corrade states.
            lock (InventoryOffersLock)
            {
                SaveInventoryOffersState.Invoke();
            }
            lock (GroupNotificationsLock)
            {
                SaveNotificationState.Invoke();
            }
            // Save Corrade caches.
            SaveCorradeCache.Invoke();
            // Stop the sphere effects expiration thread.
            runEffectsExpirationThread = false;
            if (
                (EffectsExpirationThread.ThreadState.Equals(ThreadState.Running) ||
                 EffectsExpirationThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
            {
                if (!EffectsExpirationThread.Join(1000))
                {
                    try
                    {
                        EffectsExpirationThread.Abort();
                        EffectsExpirationThread.Join();
                    }
                    catch (ThreadStateException)
                    {
                    }
                }
            }
            // Stop the group member sweep thread.
            StopGroupMembershipSweepThread.Invoke();
            // Stop the notification thread.
            runNotificationThread = false;
            if (
                (NotificationThread.ThreadState.Equals(ThreadState.Running) ||
                 NotificationThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
            {
                if (!NotificationThread.Join(1000))
                {
                    try
                    {
                        NotificationThread.Abort();
                        NotificationThread.Join();
                    }
                    catch (ThreadStateException)
                    {
                    }
                }
            }
            // Stop the callback thread.
            runCallbackThread = false;
            if (
                (CallbackThread.ThreadState.Equals(ThreadState.Running) ||
                 CallbackThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
            {
                if (!CallbackThread.Join(1000))
                {
                    try
                    {
                        CallbackThread.Abort();
                        CallbackThread.Join();
                    }
                    catch (ThreadStateException)
                    {
                    }
                }
            }
            // Close HTTP server
            if (Configuration.ENABLE_HTTP_SERVER && HttpListener.IsSupported)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.STOPPING_HTTP_SERVER));
                if (HTTPListenerThread != null)
                {
                    HTTPListener.Stop();
                    if (
                        (HTTPListenerThread.ThreadState.Equals(ThreadState.Running) ||
                         HTTPListenerThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                    {
                        if (!HTTPListenerThread.Join(1000))
                        {
                            try
                            {
                                HTTPListenerThread.Abort();
                                HTTPListenerThread.Join();
                            }
                            catch (ThreadStateException)
                            {
                            }
                        }
                    }
                }
            }
            // Reject any inventory that has not been accepted.
            lock (InventoryOffersLock)
            {
                Parallel.ForEach(InventoryOffers, o =>
                {
                    o.Key.Accept = false;
                    o.Value.Set();
                });

                SaveInventoryOffersState.Invoke();
            }
            // Disable the configuration watcher.
            configurationWatcher.EnableRaisingEvents = false;
            configurationWatcher.Changed -= HandleConfigurationFileChanged;
            // Disable the AIML bot configuration watcher.
            AIMLBotConfigurationWatcher.EnableRaisingEvents = false;
            AIMLBotConfigurationWatcher.Changed -= HandleAIMLBotConfigurationChanged;
            // Save the AIML user session.
            lock (AIMLBotLock)
            {
                if (AIMLBotBrainCompiled)
                {
                    SaveChatBotFiles.Invoke();
                }
            }
            // Logout
            if (Client.Network.Connected)
            {
                // Full speed ahead; do not even attempt to grab a lock.
                ManualResetEvent LoggedOutEvent = new ManualResetEvent(false);
                EventHandler<LoggedOutEventArgs> LoggedOutEventHandler = (sender, args) => LoggedOutEvent.Set();
                Client.Network.LoggedOut += LoggedOutEventHandler;
                Client.Network.RequestLogout();
                if (!LoggedOutEvent.WaitOne(Configuration.LOGOUT_GRACE, false))
                {
                    Client.Network.LoggedOut -= LoggedOutEventHandler;
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.TIMEOUT_LOGGING_OUT));
                }
                Client.Network.LoggedOut -= LoggedOutEventHandler;
            }
            if (Client.Network.Connected)
            {
                Client.Network.Shutdown(NetworkManager.DisconnectType.ClientInitiated);
            }
            // Terminate.
            Environment.Exit(Configuration.EXIT_CODE_EXPECTED);
        }

        private static void HandleAvatarUpdate(object sender, AvatarUpdateEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_RADAR_AVATARS, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleObjectUpdate(object sender, PrimEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_RADAR_PRIMITIVES, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleKillObject(object sender, KillObjectEventArgs e)
        {
            KeyValuePair<UUID, Primitive> tracked;
            lock (RadarObjectsLock)
            {
                tracked =
                    RadarObjects.AsParallel().FirstOrDefault(o => o.Value.LocalID.Equals(e.ObjectLocalID));
            }
            if (!tracked.Equals(default(KeyValuePair<UUID, Primitive>)))
            {
                switch (tracked.Value is Avatar)
                {
                    case true:
                        CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                            () => SendNotification(Notifications.NOTIFICATION_RADAR_AVATARS, e),
                            Configuration.MAXIMUM_NOTIFICATION_THREADS);
                        break;
                    default:
                        CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                            () => SendNotification(Notifications.NOTIFICATION_RADAR_PRIMITIVES, e),
                            Configuration.MAXIMUM_NOTIFICATION_THREADS);
                        break;
                }
            }
        }

        private static void HandleGroupJoined(object sender, GroupOperationEventArgs e)
        {
            // Add the group to the cache.
            lock (Cache.Locks.CurrentGroupsCacheLock)
            {
                if (!Cache.CurrentGroupsCache.Contains(e.GroupID))
                {
                    Cache.CurrentGroupsCache.Add(e.GroupID);
                }
            }
            // Join group chat if possible.
            if (!Client.Self.GroupChatSessions.ContainsKey(e.GroupID) &&
                HasGroupPowers(Client.Self.AgentID, e.GroupID, GroupPowers.JoinChat,
                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
            {
                JoinGroupChat(e.GroupID, Configuration.SERVICES_TIMEOUT);
            }
        }

        private static void HandleGroupLeave(object sender, GroupOperationEventArgs e)
        {
            // Remove the group from the cache.
            lock (Cache.Locks.CurrentGroupsCacheLock)
            {
                if (Cache.CurrentGroupsCache.Contains(e.GroupID))
                {
                    Cache.CurrentGroupsCache.Remove(e.GroupID);
                }
            }
        }

        private static void HandleLoadURL(object sender, LoadUrlEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_LOAD_URL, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleAppearanceSet(object sender, AppearanceSetEventArgs e)
        {
            if (e.Success)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.APPEARANCE_SET_SUCCEEDED));
                return;
            }
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.APPEARANCE_SET_FAILED));
        }

        private static void HandleRegionCrossed(object sender, RegionCrossedEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_REGION_CROSSED, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleMeanCollision(object sender, MeanCollisionEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_MEAN_COLLISION, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleViewerEffect(object sender, object e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_VIEWER_EFFECT, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void ProcessHTTPRequest(IAsyncResult ar)
        {
            try
            {
                HttpListener httpListener = ar.AsyncState as HttpListener;
                // bail if we are not listening
                if (httpListener == null || !httpListener.IsListening) return;
                HttpListenerContext httpContext = httpListener.EndGetContext(ar);
                HttpListenerRequest httpRequest = httpContext.Request;
                // only accept POST requests
                if (!httpRequest.HttpMethod.Equals(WebRequestMethods.Http.Post, StringComparison.OrdinalIgnoreCase))
                    return;
                // only accept connected remote endpoints
                if (httpRequest.RemoteEndPoint == null) return;
                using (Stream body = httpRequest.InputStream)
                {
                    using (StreamReader reader = new StreamReader(body, httpRequest.ContentEncoding))
                    {
                        Dictionary<string, string> result = HandleCorradeCommand(reader.ReadToEnd(),
                            CORRADE_CONSTANTS.WEB_REQUEST,
                            httpRequest.RemoteEndPoint.ToString());
                        using (HttpListenerResponse response = httpContext.Response)
                        {
                            // set the content type based on chosen output filers
                            switch (Configuration.OUTPUT_FILTERS.Last())
                            {
                                case Filter.RFC1738:
                                    response.ContentType = CORRADE_CONSTANTS.CONTENT_TYPE.WWW_FORM_URLENCODED;
                                    break;
                                default:
                                    response.ContentType = CORRADE_CONSTANTS.CONTENT_TYPE.TEXT_PLAIN;
                                    break;
                            }
                            byte[] data = !result.Count.Equals(0)
                                ? Encoding.UTF8.GetBytes(wasKeyValueEncode(wasKeyValueEscape(result)))
                                : new byte[0];
                            response.StatusCode = (int) HttpStatusCode.OK;
                            using (MemoryStream outputStream = new MemoryStream())
                            {
                                switch (Configuration.HTTP_SERVER_COMPRESSION)
                                {
                                    case HTTPCompressionMethod.GZIP:
                                        using (GZipStream dataGZipStream = new GZipStream(outputStream,
                                            CompressionMode.Compress, false))
                                        {
                                            dataGZipStream.Write(data, 0, data.Length);
                                            dataGZipStream.Flush();
                                        }
                                        response.AddHeader("Content-Encoding", "gzip");
                                        data = outputStream.ToArray();
                                        break;
                                    case HTTPCompressionMethod.DEFLATE:
                                        using (
                                            DeflateStream dataDeflateStream = new DeflateStream(outputStream,
                                                CompressionMode.Compress, false))
                                        {
                                            dataDeflateStream.Write(data, 0, data.Length);
                                            dataDeflateStream.Flush();
                                        }
                                        response.AddHeader("Content-Encoding", "deflate");
                                        data = outputStream.ToArray();
                                        break;
                                }
                            }
                            response.ContentLength64 = data.Length;
                            using (Stream responseStream = response.OutputStream)
                            {
                                if (responseStream != null)
                                {
                                    responseStream.Write(data, 0, data.Length);
                                    responseStream.Flush();
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_PROCESSING_ABORTED));
            }
        }

        /// <summary>
        ///     Sends a notification to each group with a configured and installed notification.
        /// </summary>
        /// <param name="notification">the notification to send</param>
        /// <param name="args">the event arguments</param>
        private static void SendNotification(Notifications notification, object args)
        {
            // Only send notifications for groups that have bound to the notification to send.
            lock (GroupNotificationsLock)
            {
                Parallel.ForEach(GroupNotifications, o =>
                {
                    if ((o.NotificationMask & (uint) notification).Equals(0) || !Configuration.GROUPS.AsParallel().Any(
                        p => p.Name.Equals(o.GroupName, StringComparison.Ordinal) &&
                             !(p.NotificationMask & (uint) notification).Equals(0))) return;
                    // Set the notification type
                    Dictionary<string, string> notificationData = new Dictionary<string, string>
                    {
                        {
                            wasGetDescriptionFromEnumValue(ScriptKeys.TYPE),
                            wasGetDescriptionFromEnumValue(notification)
                        }
                    };
                    // Build the notification data
                    switch (notification)
                    {
                        case Notifications.NOTIFICATION_SCRIPT_DIALOG:
                            ScriptDialogEventArgs scriptDialogEventArgs = (ScriptDialogEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                scriptDialogEventArgs.Message);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                scriptDialogEventArgs.FirstName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                scriptDialogEventArgs.LastName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.CHANNEL),
                                scriptDialogEventArgs.Channel.ToString(CultureInfo.InvariantCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                scriptDialogEventArgs.ObjectName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                scriptDialogEventArgs.ObjectID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                scriptDialogEventArgs.OwnerID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.BUTTON),
                                wasEnumerableToCSV(scriptDialogEventArgs.ButtonLabels));
                            break;
                        case Notifications.NOTIFICATION_LOCAL_CHAT:
                            ChatEventArgs localChatEventArgs = (ChatEventArgs) args;
                            List<string> chatName =
                                new List<string>(GetAvatarNames(localChatEventArgs.FromName));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                localChatEventArgs.Message);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME), chatName.First());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME), chatName.Last());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                localChatEventArgs.OwnerID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                localChatEventArgs.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                localChatEventArgs.Position.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                Enum.GetName(typeof (ChatSourceType), localChatEventArgs.SourceType));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AUDIBLE),
                                Enum.GetName(typeof (ChatAudibleLevel), localChatEventArgs.AudibleLevel));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.VOLUME),
                                Enum.GetName(typeof (ChatType), localChatEventArgs.Type));
                            break;
                        case Notifications.NOTIFICATION_BALANCE:
                            BalanceEventArgs balanceEventArgs = (BalanceEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.BALANCE),
                                balanceEventArgs.Balance.ToString(CultureInfo.InvariantCulture));
                            break;
                        case Notifications.NOTIFICATION_ALERT_MESSAGE:
                            AlertMessageEventArgs alertMessageEventArgs = (AlertMessageEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                alertMessageEventArgs.Message);
                            break;
                        case Notifications.NOTIFICATION_INVENTORY:
                            System.Type inventoryOfferedType = args.GetType();
                            if (inventoryOfferedType == typeof (InstantMessageEventArgs))
                            {
                                InstantMessageEventArgs inventoryOfferEventArgs = (InstantMessageEventArgs) args;
                                List<string> inventoryObjectOfferedName =
                                    new List<string>(CORRADE_CONSTANTS.AvatarFullNameRegex.Matches(
                                        inventoryOfferEventArgs.IM.FromAgentName)
                                        .Cast<Match>()
                                        .ToDictionary(p => new[]
                                        {
                                            p.Groups["first"].Value,
                                            p.Groups["last"].Value
                                        })
                                        .SelectMany(
                                            p =>
                                                new[]
                                                {
                                                    p.Key[0].Trim(),
                                                    !string.IsNullOrEmpty(p.Key[1])
                                                        ? p.Key[1].Trim()
                                                        : string.Empty
                                                }));
                                switch (!string.IsNullOrEmpty(inventoryObjectOfferedName.Last()))
                                {
                                    case true:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                            inventoryObjectOfferedName.First());
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                            inventoryObjectOfferedName.Last());
                                        break;
                                    default:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                            inventoryObjectOfferedName.First());
                                        break;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                    inventoryOfferEventArgs.IM.FromAgentID.ToString());
                                switch (inventoryOfferEventArgs.IM.Dialog)
                                {
                                    case InstantMessageDialog.InventoryAccepted:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                            wasGetDescriptionFromEnumValue(Action.ACCEPT));
                                        break;
                                    case InstantMessageDialog.InventoryDeclined:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                            wasGetDescriptionFromEnumValue(Action.DECLINE));
                                        break;
                                    case InstantMessageDialog.TaskInventoryOffered:
                                    case InstantMessageDialog.InventoryOffered:
                                        lock (InventoryOffersLock)
                                        {
                                            KeyValuePair<InventoryObjectOfferedEventArgs, ManualResetEvent>
                                                inventoryObjectOfferedEventArgs =
                                                    InventoryOffers.AsParallel().FirstOrDefault(p =>
                                                        p.Key.Offer.IMSessionID.Equals(
                                                            inventoryOfferEventArgs.IM.IMSessionID));
                                            if (
                                                !inventoryObjectOfferedEventArgs.Equals(
                                                    default(
                                                        KeyValuePair<InventoryObjectOfferedEventArgs, ManualResetEvent>)))
                                            {
                                                switch (inventoryObjectOfferedEventArgs.Key.Accept)
                                                {
                                                    case true:
                                                        notificationData.Add(
                                                            wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                                            wasGetDescriptionFromEnumValue(Action.ACCEPT));
                                                        break;
                                                    default:
                                                        notificationData.Add(
                                                            wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                                            wasGetDescriptionFromEnumValue(Action.DECLINE));
                                                        break;
                                                }
                                            }
                                            GroupCollection groups =
                                                CORRADE_CONSTANTS.InventoryOfferObjectNameRegEx.Match(
                                                    inventoryObjectOfferedEventArgs.Key.Offer.Message).Groups;
                                            if (groups.Count > 0)
                                            {
                                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                                    groups[1].Value);
                                            }
                                            InventoryOffers.Remove(inventoryObjectOfferedEventArgs.Key);
                                        }
                                        break;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DIRECTION),
                                    wasGetDescriptionFromEnumValue(Action.REPLY));
                                break;
                            }
                            if (inventoryOfferedType == typeof (InventoryObjectOfferedEventArgs))
                            {
                                InventoryObjectOfferedEventArgs inventoryObjectOfferedEventArgs =
                                    (InventoryObjectOfferedEventArgs) args;
                                List<string> inventoryObjectOfferedName =
                                    new List<string>(CORRADE_CONSTANTS.AvatarFullNameRegex.Matches(
                                        inventoryObjectOfferedEventArgs.Offer.FromAgentName)
                                        .Cast<Match>()
                                        .ToDictionary(p => new[]
                                        {
                                            p.Groups["first"].Value,
                                            p.Groups["last"].Value
                                        })
                                        .SelectMany(
                                            p =>
                                                new[]
                                                {
                                                    p.Key[0],
                                                    !string.IsNullOrEmpty(p.Key[1])
                                                        ? p.Key[1]
                                                        : string.Empty
                                                }));
                                switch (!string.IsNullOrEmpty(inventoryObjectOfferedName.Last()))
                                {
                                    case true:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                            inventoryObjectOfferedName.First());
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                            inventoryObjectOfferedName.Last());
                                        break;
                                    default:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                            inventoryObjectOfferedName.First());
                                        break;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                    inventoryObjectOfferedEventArgs.Offer.FromAgentID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ASSET),
                                    inventoryObjectOfferedEventArgs.AssetType.ToString());
                                GroupCollection groups =
                                    CORRADE_CONSTANTS.InventoryOfferObjectNameRegEx.Match(
                                        inventoryObjectOfferedEventArgs.Offer.Message).Groups;
                                if (groups.Count > 0)
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                        groups[1].Value);
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION),
                                    inventoryObjectOfferedEventArgs.Offer.IMSessionID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DIRECTION),
                                    wasGetDescriptionFromEnumValue(Action.OFFER));
                            }
                            break;
                        case Notifications.NOTIFICATION_SCRIPT_PERMISSION:
                            ScriptQuestionEventArgs scriptQuestionEventArgs = (ScriptQuestionEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                scriptQuestionEventArgs.ItemID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TASK),
                                scriptQuestionEventArgs.TaskID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.PERMISSIONS),
                                wasEnumerableToCSV(typeof (ScriptPermission).GetFields(BindingFlags.Public |
                                                                                       BindingFlags.Static)
                                    .AsParallel().Where(
                                        p =>
                                            !(((int) p.GetValue(null) &
                                               (int) scriptQuestionEventArgs.Questions)).Equals(0))
                                    .Select(p => p.Name)));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.REGION),
                                scriptQuestionEventArgs.Simulator.Name);
                            break;
                        case Notifications.NOTIFICATION_FRIENDSHIP:
                            System.Type friendshipNotificationType = args.GetType();
                            if (friendshipNotificationType == typeof (FriendInfoEventArgs))
                            {
                                FriendInfoEventArgs friendInfoEventArgs = (FriendInfoEventArgs) args;
                                List<string> name =
                                    new List<string>(GetAvatarNames(friendInfoEventArgs.Friend.Name));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME), name.First());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME), name.Last());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                    friendInfoEventArgs.Friend.UUID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.STATUS),
                                    friendInfoEventArgs.Friend.IsOnline
                                        ? wasGetDescriptionFromEnumValue(Action.ONLINE)
                                        : wasGetDescriptionFromEnumValue(Action.OFFLINE));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.RIGHTS),
                                    // Return the friend rights as a nice CSV string.
                                    wasEnumerableToCSV(typeof (FriendRights).GetFields(BindingFlags.Public |
                                                                                       BindingFlags.Static)
                                        .AsParallel().Where(
                                            p =>
                                                !(((int) p.GetValue(null) &
                                                   (int) friendInfoEventArgs.Friend.MyFriendRights))
                                                    .Equals(
                                                        0))
                                        .Select(p => p.Name)));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.UPDATE));
                                break;
                            }
                            if (friendshipNotificationType == typeof (FriendshipResponseEventArgs))
                            {
                                FriendshipResponseEventArgs friendshipResponseEventArgs =
                                    (FriendshipResponseEventArgs) args;
                                List<string> friendshipResponseName =
                                    new List<string>(
                                        GetAvatarNames(friendshipResponseEventArgs.AgentName));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                    friendshipResponseName.First());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                    friendshipResponseName.Last());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                    friendshipResponseEventArgs.AgentID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.RESPONSE));
                                break;
                            }
                            if (friendshipNotificationType == typeof (FriendshipOfferedEventArgs))
                            {
                                FriendshipOfferedEventArgs friendshipOfferedEventArgs =
                                    (FriendshipOfferedEventArgs) args;
                                List<string> friendshipOfferedName =
                                    new List<string>(GetAvatarNames(friendshipOfferedEventArgs.AgentName));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                    friendshipOfferedName.First());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                    friendshipOfferedName.Last());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                    friendshipOfferedEventArgs.AgentID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.REQUEST));
                            }
                            break;
                        case Notifications.NOTIFICATION_TELEPORT_LURE:
                            InstantMessageEventArgs teleportLureEventArgs = (InstantMessageEventArgs) args;
                            List<string> teleportLureName =
                                new List<string>(
                                    GetAvatarNames(teleportLureEventArgs.IM.FromAgentName));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                teleportLureName.First());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                teleportLureName.Last());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                teleportLureEventArgs.IM.FromAgentID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION),
                                teleportLureEventArgs.IM.IMSessionID.ToString());
                            break;
                        case Notifications.NOTIFICATION_GROUP_NOTICE:
                            InstantMessageEventArgs notificationGroupNoticeEventArgs =
                                (InstantMessageEventArgs) args;
                            List<string> notificationGroupNoticeName =
                                new List<string>(
                                    GetAvatarNames(notificationGroupNoticeEventArgs.IM.FromAgentName));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                notificationGroupNoticeName.First());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                notificationGroupNoticeName.Last());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationGroupNoticeEventArgs.IM.FromAgentID.ToString());
                            string[] noticeData = notificationGroupNoticeEventArgs.IM.Message.Split('|');
                            if (noticeData.Length > 0 && !string.IsNullOrEmpty(noticeData[0]))
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SUBJECT), noticeData[0]);
                            }
                            if (noticeData.Length > 1 && !string.IsNullOrEmpty(noticeData[1]))
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE), noticeData[1]);
                            }
                            switch (notificationGroupNoticeEventArgs.IM.Dialog)
                            {
                                case InstantMessageDialog.GroupNoticeInventoryAccepted:
                                case InstantMessageDialog.GroupNoticeInventoryDeclined:
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                        !notificationGroupNoticeEventArgs.IM.Dialog.Equals(
                                            InstantMessageDialog.GroupNoticeInventoryAccepted)
                                            ? wasGetDescriptionFromEnumValue(Action.DECLINE)
                                            : wasGetDescriptionFromEnumValue(Action.ACCEPT));
                                    break;
                                case InstantMessageDialog.GroupNotice:
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                        wasGetDescriptionFromEnumValue(Action.RECEIVED));
                                    break;
                            }
                            break;
                        case Notifications.NOTIFICATION_INSTANT_MESSAGE:
                            InstantMessageEventArgs notificationInstantMessage =
                                (InstantMessageEventArgs) args;
                            List<string> notificationInstantMessageName =
                                new List<string>(
                                    GetAvatarNames(notificationInstantMessage.IM.FromAgentName));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                notificationInstantMessageName.First());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                notificationInstantMessageName.Last());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationInstantMessage.IM.FromAgentID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                notificationInstantMessage.IM.Message);
                            break;
                        case Notifications.NOTIFICATION_REGION_MESSAGE:
                            InstantMessageEventArgs notificationRegionMessage =
                                (InstantMessageEventArgs) args;
                            List<string> notificationRegionMessageName =
                                new List<string>(
                                    GetAvatarNames(notificationRegionMessage.IM.FromAgentName));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                notificationRegionMessageName.First());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                notificationRegionMessageName.Last());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationRegionMessage.IM.FromAgentID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                notificationRegionMessage.IM.Message);
                            break;
                        case Notifications.NOTIFICATION_GROUP_MESSAGE:
                            InstantMessageEventArgs notificationGroupMessage =
                                (InstantMessageEventArgs) args;
                            List<string> notificationGroupMessageName =
                                new List<string>(
                                    GetAvatarNames(notificationGroupMessage.IM.FromAgentName));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                notificationGroupMessageName.First());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                notificationGroupMessageName.Last());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationGroupMessage.IM.FromAgentID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP), o.GroupName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                notificationGroupMessage.IM.Message);
                            break;
                        case Notifications.NOTIFICATION_VIEWER_EFFECT:
                            System.Type viewerEffectType = args.GetType();
                            if (viewerEffectType == typeof (ViewerEffectEventArgs))
                            {
                                ViewerEffectEventArgs notificationViewerEffectEventArgs =
                                    (ViewerEffectEventArgs) args;
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.EFFECT),
                                    notificationViewerEffectEventArgs.Type.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SOURCE),
                                    notificationViewerEffectEventArgs.SourceID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET),
                                    notificationViewerEffectEventArgs.TargetID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    notificationViewerEffectEventArgs.TargetPosition.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DURATION),
                                    notificationViewerEffectEventArgs.Duration.ToString(
                                        CultureInfo.InvariantCulture));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    notificationViewerEffectEventArgs.EffectID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.GENERIC));
                                break;
                            }
                            if (viewerEffectType == typeof (ViewerEffectPointAtEventArgs))
                            {
                                ViewerEffectPointAtEventArgs notificationViewerPointAtEventArgs =
                                    (ViewerEffectPointAtEventArgs) args;
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SOURCE),
                                    notificationViewerPointAtEventArgs.SourceID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET),
                                    notificationViewerPointAtEventArgs.TargetID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    notificationViewerPointAtEventArgs.TargetPosition.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DURATION),
                                    notificationViewerPointAtEventArgs.Duration.ToString(
                                        CultureInfo.InvariantCulture));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    notificationViewerPointAtEventArgs.EffectID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.POINT));
                                break;
                            }
                            if (viewerEffectType == typeof (ViewerEffectLookAtEventArgs))
                            {
                                ViewerEffectLookAtEventArgs notificationViewerLookAtEventArgs =
                                    (ViewerEffectLookAtEventArgs) args;
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SOURCE),
                                    notificationViewerLookAtEventArgs.SourceID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET),
                                    notificationViewerLookAtEventArgs.TargetID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    notificationViewerLookAtEventArgs.TargetPosition.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DURATION),
                                    notificationViewerLookAtEventArgs.Duration.ToString(
                                        CultureInfo.InvariantCulture));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    notificationViewerLookAtEventArgs.EffectID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.LOOK));
                            }
                            break;
                        case Notifications.NOTIFICATION_MEAN_COLLISION:
                            MeanCollisionEventArgs meanCollisionEventArgs =
                                (MeanCollisionEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGGRESSOR),
                                meanCollisionEventArgs.Aggressor.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MAGNITUDE),
                                meanCollisionEventArgs.Magnitude.ToString(CultureInfo.InvariantCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TIME),
                                meanCollisionEventArgs.Time.ToLongDateString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                meanCollisionEventArgs.Type.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.VICTIM),
                                meanCollisionEventArgs.Victim.ToString());
                            break;
                        case Notifications.NOTIFICATION_REGION_CROSSED:
                            System.Type regionChangeType = args.GetType();
                            if (regionChangeType == typeof (SimChangedEventArgs))
                            {
                                SimChangedEventArgs simChangedEventArgs = (SimChangedEventArgs) args;
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OLD),
                                    simChangedEventArgs.PreviousSimulator.Name);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NEW),
                                    Client.Network.CurrentSim.Name);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.CHANGED));
                                break;
                            }
                            if (regionChangeType == typeof (RegionCrossedEventArgs))
                            {
                                RegionCrossedEventArgs regionCrossedEventArgs =
                                    (RegionCrossedEventArgs) args;
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OLD),
                                    regionCrossedEventArgs.OldSimulator.Name);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NEW),
                                    regionCrossedEventArgs.NewSimulator.Name);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.CROSSED));
                            }
                            break;
                        case Notifications.NOTIFICATION_TERSE_UPDATES:
                            TerseObjectUpdateEventArgs terseObjectUpdateEventArgs =
                                (TerseObjectUpdateEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                terseObjectUpdateEventArgs.Prim.ID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                terseObjectUpdateEventArgs.Prim.Position.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION),
                                terseObjectUpdateEventArgs.Prim.Rotation.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                terseObjectUpdateEventArgs.Prim.PrimData.PCode.ToString());
                            break;
                        case Notifications.NOTIFICATION_TYPING:
                            InstantMessageEventArgs notificationTypingMessageEventArgs = (InstantMessageEventArgs) args;
                            List<string> notificationTypingMessageName =
                                new List<string>(
                                    GetAvatarNames(notificationTypingMessageEventArgs.IM.FromAgentName));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                notificationTypingMessageName.First());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                notificationTypingMessageName.Last());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationTypingMessageEventArgs.IM.FromAgentID.ToString());
                            switch (notificationTypingMessageEventArgs.IM.Dialog)
                            {
                                case InstantMessageDialog.StartTyping:
                                case InstantMessageDialog.StopTyping:
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                        !notificationTypingMessageEventArgs.IM.Dialog.Equals(
                                            InstantMessageDialog.StartTyping)
                                            ? wasGetDescriptionFromEnumValue(Action.STOP)
                                            : wasGetDescriptionFromEnumValue(Action.START));
                                    break;
                            }
                            break;
                        case Notifications.NOTIFICATION_GROUP_INVITE:
                            InstantMessageEventArgs notificationGroupInviteEventArgs = (InstantMessageEventArgs) args;
                            List<string> notificationGroupInviteName =
                                new List<string>(
                                    GetAvatarNames(notificationGroupInviteEventArgs.IM.FromAgentName));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                notificationGroupInviteName.First());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                notificationGroupInviteName.Last());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationGroupInviteEventArgs.IM.FromAgentID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP),
                                GroupInvites.AsParallel().FirstOrDefault(
                                    p => p.Session.Equals(notificationGroupInviteEventArgs.IM.IMSessionID))
                                    .Group);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION),
                                notificationGroupInviteEventArgs.IM.IMSessionID.ToString());
                            break;
                        case Notifications.NOTIFICATION_ECONOMY:
                            MoneyBalanceReplyEventArgs notificationMoneyBalanceEventArgs =
                                (MoneyBalanceReplyEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.BALANCE),
                                notificationMoneyBalanceEventArgs.Balance.ToString(CultureInfo.InvariantCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION),
                                notificationMoneyBalanceEventArgs.Description);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.COMMITTED),
                                notificationMoneyBalanceEventArgs.MetersCommitted.ToString(CultureInfo.InvariantCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.CREDIT),
                                notificationMoneyBalanceEventArgs.MetersCredit.ToString(CultureInfo.InvariantCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SUCCESS),
                                notificationMoneyBalanceEventArgs.Success.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                notificationMoneyBalanceEventArgs.TransactionID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AMOUNT),
                                notificationMoneyBalanceEventArgs.TransactionInfo.Amount.ToString(
                                    CultureInfo.InvariantCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET),
                                notificationMoneyBalanceEventArgs.TransactionInfo.DestID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SOURCE),
                                notificationMoneyBalanceEventArgs.TransactionInfo.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TRANSACTION),
                                Enum.GetName(typeof (MoneyTransactionType),
                                    notificationMoneyBalanceEventArgs.TransactionInfo.TransactionType));
                            break;
                        case Notifications.NOTIFICATION_GROUP_MEMBERSHIP:
                            GroupMembershipEventArgs groupMembershipEventArgs = (GroupMembershipEventArgs) args;
                            List<string> groupMembershipName =
                                new List<string>(
                                    GetAvatarNames(groupMembershipEventArgs.AgentName));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                groupMembershipName.First());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                groupMembershipName.Last());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                groupMembershipEventArgs.AgentUUID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP),
                                o.GroupName);
                            switch (groupMembershipEventArgs.Action)
                            {
                                case Action.JOINED:
                                case Action.PARTED:
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                        !groupMembershipEventArgs.Action.Equals(
                                            Action.JOINED)
                                            ? wasGetDescriptionFromEnumValue(Action.PARTED)
                                            : wasGetDescriptionFromEnumValue(Action.JOINED));
                                    break;
                            }
                            break;
                        case Notifications.NOTIFICATION_LOAD_URL:
                            LoadUrlEventArgs loadURLEventArgs = (LoadUrlEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                loadURLEventArgs.ObjectName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                loadURLEventArgs.ObjectID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                loadURLEventArgs.OwnerID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP),
                                loadURLEventArgs.OwnerIsGroup.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                loadURLEventArgs.Message);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.URL),
                                loadURLEventArgs.URL);
                            break;
                        case Notifications.NOTIFICATION_OWNER_SAY:
                            ChatEventArgs ownerSayEventArgs = (ChatEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                ownerSayEventArgs.Message);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                ownerSayEventArgs.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                ownerSayEventArgs.FromName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                ownerSayEventArgs.Position.ToString());
                            break;
                        case Notifications.NOTIFICATION_REGION_SAY_TO:
                            ChatEventArgs regionSayToEventArgs = (ChatEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                regionSayToEventArgs.Message);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                regionSayToEventArgs.OwnerID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                regionSayToEventArgs.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                regionSayToEventArgs.FromName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                regionSayToEventArgs.Position.ToString());
                            break;
                        case Notifications.NOTIFICATION_OBJECT_INSTANT_MESSAGE:
                            InstantMessageEventArgs notificationObjectInstantMessage =
                                (InstantMessageEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                notificationObjectInstantMessage.IM.FromAgentID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                notificationObjectInstantMessage.IM.IMSessionID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                notificationObjectInstantMessage.IM.FromAgentName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                notificationObjectInstantMessage.IM.Message);
                            break;
                        case Notifications.NOTIFICATION_RLV_MESSAGE:
                            ChatEventArgs RLVEventArgs = (ChatEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                RLVEventArgs.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                RLVEventArgs.FromName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                RLVEventArgs.Position.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.RLV),
                                wasEnumerableToCSV(wasRLVToString(RLVEventArgs.Message)));
                            break;
                        case Notifications.NOTIFICATION_DEBUG_MESSAGE:
                            ChatEventArgs DebugEventArgs = (ChatEventArgs) args;
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                DebugEventArgs.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                DebugEventArgs.FromName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                DebugEventArgs.Position.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                DebugEventArgs.Message);
                            break;
                        case Notifications.NOTIFICATION_RADAR_AVATARS:
                            System.Type radarAvatarsType = args.GetType();
                            if (radarAvatarsType == typeof (AvatarUpdateEventArgs))
                            {
                                AvatarUpdateEventArgs avatarUpdateEventArgs =
                                    (AvatarUpdateEventArgs) args;
                                lock (RadarObjectsLock)
                                {
                                    if (RadarObjects.ContainsKey(avatarUpdateEventArgs.Avatar.ID)) return;
                                    RadarObjects.Add(avatarUpdateEventArgs.Avatar.ID, avatarUpdateEventArgs.Avatar);
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                    avatarUpdateEventArgs.Avatar.FirstName);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                    avatarUpdateEventArgs.Avatar.LastName);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    avatarUpdateEventArgs.Avatar.ID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    avatarUpdateEventArgs.Avatar.Position.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION),
                                    avatarUpdateEventArgs.Avatar.Rotation.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                    avatarUpdateEventArgs.Avatar.PrimData.PCode.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.APPEAR));
                                break;
                            }
                            if (radarAvatarsType == typeof (KillObjectEventArgs))
                            {
                                KillObjectEventArgs killObjectEventArgs =
                                    (KillObjectEventArgs) args;
                                Avatar avatar;
                                lock (RadarObjectsLock)
                                {
                                    KeyValuePair<UUID, Primitive> tracked =
                                        RadarObjects.AsParallel().FirstOrDefault(
                                            p => p.Value.LocalID.Equals(killObjectEventArgs.ObjectLocalID));
                                    if (tracked.Equals(default(KeyValuePair<UUID, Primitive>))) return;
                                    RadarObjects.Remove(tracked.Key);
                                    if (!(tracked.Value is Avatar)) return;
                                    avatar = tracked.Value as Avatar;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                    avatar.FirstName);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                    avatar.LastName);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    avatar.ID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    avatar.Position.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION),
                                    avatar.Rotation.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                    avatar.PrimData.PCode.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.VANISH));
                            }
                            break;
                        case Notifications.NOTIFICATION_RADAR_PRIMITIVES:
                            System.Type radarPrimitivesType = args.GetType();
                            if (radarPrimitivesType == typeof (PrimEventArgs))
                            {
                                PrimEventArgs primEventArgs =
                                    (PrimEventArgs) args;
                                lock (RadarObjectsLock)
                                {
                                    if (RadarObjects.ContainsKey(primEventArgs.Prim.ID)) return;
                                    RadarObjects.Add(primEventArgs.Prim.ID, primEventArgs.Prim);
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                    primEventArgs.Prim.OwnerID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    primEventArgs.Prim.ID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    primEventArgs.Prim.Position.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION),
                                    primEventArgs.Prim.Rotation.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                    primEventArgs.Prim.PrimData.PCode.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.APPEAR));
                                break;
                            }
                            if (radarPrimitivesType == typeof (KillObjectEventArgs))
                            {
                                KillObjectEventArgs killObjectEventArgs =
                                    (KillObjectEventArgs) args;
                                Primitive prim;
                                lock (RadarObjectsLock)
                                {
                                    KeyValuePair<UUID, Primitive> tracked =
                                        RadarObjects.AsParallel().FirstOrDefault(
                                            p => p.Value.LocalID.Equals(killObjectEventArgs.ObjectLocalID));
                                    if (tracked.Equals(default(KeyValuePair<UUID, Primitive>))) return;
                                    RadarObjects.Remove(tracked.Key);
                                    prim = tracked.Value;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                    prim.OwnerID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    prim.ID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    prim.Position.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION),
                                    prim.Rotation.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                    prim.PrimData.PCode.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.VANISH));
                            }
                            break;
                    }
                    lock (NotificationQueueLock)
                    {
                        if (NotificationQueue.Count < Configuration.NOTIFICATION_QUEUE_LENGTH)
                        {
                            Parallel.ForEach(
                                o.NotificationDestination.AsParallel()
                                    .Where(p => p.Key.Equals(notification))
                                    .SelectMany(p => p.Value), p =>
                                    {
                                        NotificationQueue.Enqueue(new NotificationQueueElement
                                        {
                                            URL = p,
                                            message = wasKeyValueEscape(notificationData)
                                        });
                                    });
                        }
                    }
                });
            }
        }

        private static void HandleScriptDialog(object sender, ScriptDialogEventArgs e)
        {
            lock (ScriptDialogLock)
            {
                ScriptDialogs.Add(new ScriptDialog
                {
                    Message = e.Message,
                    Agent = new Agent
                    {
                        FirstName = e.FirstName,
                        LastName = e.LastName,
                        UUID = e.OwnerID
                    },
                    Channel = e.Channel,
                    Name = e.ObjectName,
                    Item = e.ObjectID,
                    Button = e.ButtonLabels
                });
            }
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_SCRIPT_DIALOG, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleChatFromSimulator(object sender, ChatEventArgs e)
        {
            // Ignore chat with no message (ie: start / stop typing)
            if (string.IsNullOrEmpty(e.Message)) return;
            switch (e.Type)
            {
                case ChatType.OwnerSay:
                    // If RLV is enabled, process RLV and terminate.
                    if (EnableRLV && e.Message.StartsWith(RLV_CONSTANTS.COMMAND_OPERATOR))
                    {
                        // Send RLV message notifications.
                        CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                            () => SendNotification(Notifications.NOTIFICATION_RLV_MESSAGE, e),
                            Configuration.MAXIMUM_NOTIFICATION_THREADS);
                        CorradeThreadPool[CorradeThreadType.RLV].Spawn(
                            () => HandleRLVBehaviour(e.Message.Substring(1, e.Message.Length - 1), e.SourceID),
                            Configuration.MAXIMUM_RLV_THREADS);
                        break;
                    }
                    // Otherwise, send llOwnerSay notifications.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.NOTIFICATION_OWNER_SAY, e),
                        Configuration.MAXIMUM_NOTIFICATION_THREADS);
                    break;
                case ChatType.Debug:
                    // Send debug notifications.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.NOTIFICATION_DEBUG_MESSAGE, e),
                        Configuration.MAXIMUM_NOTIFICATION_THREADS);
                    break;
                case ChatType.Normal:
                case ChatType.Shout:
                case ChatType.Whisper:
                    // Send chat notifications.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.NOTIFICATION_LOCAL_CHAT, e),
                        Configuration.MAXIMUM_NOTIFICATION_THREADS);
                    // Log local chat,
                    if (Configuration.LOCAL_MESSAGE_LOG_ENABLED)
                    {
                        List<string> fullName =
                            new List<string>(
                                GetAvatarNames(e.FromName));
                        try
                        {
                            lock (LocalLogFileLock)
                            {
                                using (
                                    StreamWriter logWriter =
                                        File.AppendText(
                                            wasPathCombine(Configuration.LOCAL_MESSAGE_LOG_DIRECTORY,
                                                Client.Network.CurrentSim.Name) +
                                            "." +
                                            CORRADE_CONSTANTS.LOG_FILE_EXTENSION))
                                {
                                    logWriter.WriteLine("[{0}] {1} {2} ({3}) : {4}",
                                        DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                            DateTimeFormatInfo.InvariantInfo), fullName.First(), fullName.Last(),
                                        Enum.GetName(typeof (ChatType), e.Type),
                                        e.Message);
                                    //logWriter.Flush();
                                    //logWriter.Close();
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            // or fail and append the fail message.
                            Feedback(
                                wasGetDescriptionFromEnumValue(
                                    ConsoleError.COULD_NOT_WRITE_TO_LOCAL_MESSAGE_LOG_FILE),
                                ex.Message);
                        }
                    }
                    break;
                case (ChatType) 9:
                    // Send llRegionSayTo notification in case we do not have a command.
                    if (!IsCorradeCommand(e.Message))
                    {
                        // Send chat notifications.
                        CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                            () => SendNotification(Notifications.NOTIFICATION_REGION_SAY_TO, e),
                            Configuration.MAXIMUM_NOTIFICATION_THREADS);
                        break;
                    }
                    CorradeThreadPool[CorradeThreadType.COMMAND].Spawn(
                        () => HandleCorradeCommand(e.Message, e.FromName, e.OwnerID.ToString()),
                        Configuration.MAXIMUM_COMMAND_THREADS);
                    break;
            }
        }

        private static void HandleAlertMessage(object sender, AlertMessageEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_ALERT_MESSAGE, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleInventoryObjectOffered(object sender, InventoryObjectOfferedEventArgs e)
        {
            // Send notification
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_INVENTORY, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);

            // Accept anything from master avatars.
            if (
                Configuration.MASTERS.AsParallel().Select(
                    o => string.Format(CultureInfo.InvariantCulture, "{0} {1}", o.FirstName, o.LastName))
                    .Any(p => p.Equals(e.Offer.FromAgentName, StringComparison.OrdinalIgnoreCase)))
            {
                e.Accept = true;
                return;
            }

            // We need to block until we get a reply from a script.
            ManualResetEvent wait = new ManualResetEvent(false);
            // Add the inventory offer to the list of inventory items.
            lock (InventoryOffersLock)
            {
                InventoryOffers.Add(e, wait);
                SaveInventoryOffersState.Invoke();
            }

            UpdateInventoryRecursive.Invoke(
                Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(e.AssetType)].Data as
                    InventoryFolder);

            // Find the item in the inventory.
            InventoryBase inventoryBaseItem;
            lock (ClientInstanceInventoryLock)
            {
                inventoryBaseItem = FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, ((Func<string>) (() =>
                {
                    GroupCollection groups =
                        CORRADE_CONSTANTS.InventoryOfferObjectNameRegEx.Match(e.Offer.Message).Groups;
                    return groups.Count > 0 ? groups[1].Value : e.Offer.Message;
                }))()
                    ).FirstOrDefault();
            }

            if (inventoryBaseItem != null)
            {
                // Assume we do not want the item.
                lock (ClientInstanceInventoryLock)
                {
                    Client.Inventory.Move(
                        inventoryBaseItem,
                        Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(AssetType.TrashFolder)].Data as
                            InventoryFolder);
                }
            }

            // Wait for a reply.
            wait.WaitOne(Timeout.Infinite);

            if (!e.Accept) return;

            // If no folder UUID was specified, move it to the default folder for the asset type.
            if (inventoryBaseItem != null)
            {
                switch (!e.FolderID.Equals(UUID.Zero))
                {
                    case true:
                        InventoryBase inventoryBaseFolder;
                        lock (ClientInstanceInventoryLock)
                        {
                            // Locate the folder and move.
                            inventoryBaseFolder =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, e.FolderID
                                    ).FirstOrDefault();
                            if (inventoryBaseFolder != null)
                            {
                                Client.Inventory.Move(inventoryBaseItem, inventoryBaseFolder as InventoryFolder);
                            }
                        }
                        if (inventoryBaseFolder != null)
                        {
                            UpdateInventoryRecursive.Invoke(inventoryBaseFolder as InventoryFolder);
                        }
                        break;
                    default:
                        lock (ClientInstanceInventoryLock)
                        {
                            Client.Inventory.Move(
                                inventoryBaseItem,
                                Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(e.AssetType)].Data as
                                    InventoryFolder);
                        }
                        UpdateInventoryRecursive.Invoke(
                            Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(e.AssetType)].Data as
                                InventoryFolder);
                        break;
                }
            }
        }

        private static void HandleScriptQuestion(object sender, ScriptQuestionEventArgs e)
        {
            List<string> owner = new List<string>(GetAvatarNames(e.ObjectOwnerName));
            UUID ownerUUID = UUID.Zero;
            // Don't add permission requests from unknown agents.
            if (
                !AgentNameToUUID(owner.First(), owner.Last(), Configuration.SERVICES_TIMEOUT,
                    Configuration.DATA_TIMEOUT,
                    ref ownerUUID))
            {
                return;
            }

            lock (ScriptPermissionRequestLock)
            {
                ScriptPermissionRequests.Add(new ScriptPermissionRequest
                {
                    Name = e.ObjectName,
                    Agent = new Agent
                    {
                        FirstName = owner.First(),
                        LastName = owner.Last(),
                        UUID = ownerUUID
                    },
                    Item = e.ItemID,
                    Task = e.TaskID,
                    Permission = e.Questions,
                    Region = e.Simulator.Name
                });
            }
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_SCRIPT_PERMISSION, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);

            // Handle RLV: acceptpermission
            lock (RLVRulesLock)
            {
                if (
                    !RLVRules.AsParallel()
                        .Any(o => o.Behaviour.Equals(wasGetDescriptionFromEnumValue(RLVBehaviour.ACCEPTPERMISSION))))
                    return;
                lock (ClientInstanceSelfLock)
                {
                    Client.Self.ScriptQuestionReply(e.Simulator, e.ItemID, e.TaskID, e.Questions);
                }
            }
        }

        private static void HandleDisconnected(object sender, DisconnectedEventArgs e)
        {
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.DISCONNECTED));
            ConnectionSemaphores['l'].Set();
        }

        private static void HandleEventQueueRunning(object sender, EventQueueRunningEventArgs e)
        {
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.EVENT_QUEUE_STARTED));
        }

        private static void HandleSimulatorConnected(object sender, SimConnectedEventArgs e)
        {
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.SIMULATOR_CONNECTED));
        }

        private static void HandleSimulatorDisconnected(object sender, SimDisconnectedEventArgs e)
        {
            // if any simulators are still connected, we are not disconnected
            if (Client.Network.Simulators.Any()) return;
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ALL_SIMULATORS_DISCONNECTED));
            ConnectionSemaphores['s'].Set();
        }

        private static void HandleLoginProgress(object sender, LoginProgressEventArgs e)
        {
            switch (e.Status)
            {
                case LoginStatus.Success:
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.LOGIN_SUCCEEDED));
                    // Start inventory update thread.
                    ManualResetEvent InventoryLoadedEvent = new ManualResetEvent(false);
                    new Thread(() =>
                    {
                        lock (ClientInstanceInventoryLock)
                        {
                            // First load the caches.
                            LoadInventoryCache.Invoke();
                        }
                        // Update the inventory.
                        UpdateInventoryRecursive.Invoke(Client.Inventory.Store.RootFolder);
                        lock (ClientInstanceInventoryLock)
                        {
                            // Now save the caches.
                            SaveInventoryCache.Invoke();
                        }
                        // Signal completion.
                        InventoryLoadedEvent.Set();
                    }) {IsBackground = true, Priority = ThreadPriority.BelowNormal}.Start();
                    // Set current group to land group.
                    new Thread(() =>
                    {
                        if (!Configuration.AUTO_ACTIVATE_GROUP) return;
                        ActivateCurrentLandGroupTimer.Change(Configuration.ACTIVATE_DELAY, 0);
                    }) {IsBackground = true, Priority = ThreadPriority.BelowNormal}.Start();
                    // Retrieve instant messages.
                    new Thread(() =>
                    {
                        // Wait till the inventory has loaded to retrieve messages since 
                        // instant messages may contain commands that must be replayed.
                        InventoryLoadedEvent.WaitOne(Timeout.Infinite, false);
                        lock (ClientInstanceSelfLock)
                        {
                            Client.Self.RetrieveInstantMessages();
                        }
                    }) {IsBackground = true, Priority = ThreadPriority.BelowNormal}.Start();
                    // Set the camera on the avatar.
                    Client.Self.Movement.Camera.LookAt(
                        Client.Self.SimPosition,
                        Client.Self.SimPosition
                        );
                    break;
                case LoginStatus.Failed:
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.LOGIN_FAILED), e.FailReason);
                    ConnectionSemaphores['l'].Set();
                    break;
            }
        }

        private static void HandleFriendOnlineStatus(object sender, FriendInfoEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_FRIENDSHIP, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleFriendRightsUpdate(object sender, FriendInfoEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_FRIENDSHIP, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleFriendShipResponse(object sender, FriendshipResponseEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_FRIENDSHIP, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleFriendshipOffered(object sender, FriendshipOfferedEventArgs e)
        {
            // Send friendship notifications
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_FRIENDSHIP, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleTeleportProgress(object sender, TeleportEventArgs e)
        {
            switch (e.Status)
            {
                case TeleportStatus.Finished:
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.TELEPORT_SUCCEEDED));
                    // Set current group to land group.
                    new Thread(() =>
                    {
                        if (!Configuration.AUTO_ACTIVATE_GROUP) return;
                        ActivateCurrentLandGroupTimer.Change(Configuration.ACTIVATE_DELAY, 0);
                    }) {IsBackground = true, Priority = ThreadPriority.BelowNormal}.Start();
                    // Set the camera on the avatar.
                    Client.Self.Movement.Camera.LookAt(
                        Client.Self.SimPosition,
                        Client.Self.SimPosition
                        );
                    break;
                case TeleportStatus.Failed:
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.TELEPORT_FAILED));
                    break;
            }
        }

        private static void HandleSelfIM(object sender, InstantMessageEventArgs args)
        {
            List<string> fullName =
                new List<string>(
                    GetAvatarNames(args.IM.FromAgentName));
            // Process dialog messages.
            switch (args.IM.Dialog)
            {
                // Send typing notification.
                case InstantMessageDialog.StartTyping:
                case InstantMessageDialog.StopTyping:
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.NOTIFICATION_TYPING, args),
                        Configuration.MAXIMUM_NOTIFICATION_THREADS);
                    return;
                case InstantMessageDialog.FriendshipOffered:
                    // Accept friendships only from masters (for the time being)
                    if (
                        !Configuration.MASTERS.AsParallel().Any(
                            o =>
                                o.FirstName.Equals(fullName.First(), StringComparison.OrdinalIgnoreCase) &&
                                o.LastName.Equals(fullName.Last(), StringComparison.OrdinalIgnoreCase))) return;
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ACCEPTED_FRIENDSHIP), args.IM.FromAgentName);
                    Client.Friends.AcceptFriendship(args.IM.FromAgentID, args.IM.IMSessionID);
                    break;
                case InstantMessageDialog.InventoryAccepted:
                case InstantMessageDialog.InventoryDeclined:
                case InstantMessageDialog.TaskInventoryOffered:
                case InstantMessageDialog.InventoryOffered:
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.NOTIFICATION_INVENTORY, args),
                        Configuration.MAXIMUM_NOTIFICATION_THREADS);
                    return;
                case InstantMessageDialog.MessageBox:
                    // Not used.
                    return;
                case InstantMessageDialog.RequestTeleport:
                    // Handle RLV: acccepttp
                    lock (RLVRulesLock)
                    {
                        if (
                            RLVRules.AsParallel()
                                .Any(o => o.Behaviour.Equals(wasGetDescriptionFromEnumValue(RLVBehaviour.ACCEPTTP))))
                        {
                            lock (ClientInstanceSelfLock)
                            {
                                Client.Self.TeleportLureRespond(args.IM.FromAgentID, args.IM.IMSessionID, true);
                            }
                            return;
                        }
                    }
                    // Handle Corrade
                    List<string> teleportLureName =
                        new List<string>(
                            GetAvatarNames(args.IM.FromAgentName));
                    // Store teleport lure.
                    lock (TeleportLureLock)
                    {
                        TeleportLures.Add(new TeleportLure
                        {
                            Agent = new Agent
                            {
                                FirstName = teleportLureName.First(),
                                LastName = teleportLureName.Last(),
                                UUID = args.IM.FromAgentID
                            },
                            Session = args.IM.IMSessionID
                        });
                    }
                    // Send teleport lure notification.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.NOTIFICATION_TELEPORT_LURE, args),
                        Configuration.MAXIMUM_NOTIFICATION_THREADS);
                    // If we got a teleport request from a master, then accept it (for the moment).
                    lock (ClientInstanceInventoryLock)
                    {
                        if (!Configuration.MASTERS.AsParallel().Select(
                            o =>
                                string.Format(CultureInfo.InvariantCulture, "{0} {1}", o.FirstName, o.LastName))
                            .
                            Any(p => p.Equals(args.IM.FromAgentName, StringComparison.OrdinalIgnoreCase))) return;
                    }
                    lock (ClientInstanceSelfLock)
                    {
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        Client.Self.TeleportLureRespond(args.IM.FromAgentID, args.IM.IMSessionID, true);
                    }
                    return;
                // Group invitations received
                case InstantMessageDialog.GroupInvitation:
                    OpenMetaverse.Group inviteGroup = new OpenMetaverse.Group();
                    if (!RequestGroup(args.IM.FromAgentID, Configuration.SERVICES_TIMEOUT, ref inviteGroup)) return;

                    List<string> groupInviteName =
                        new List<string>(
                            GetAvatarNames(args.IM.FromAgentName));
                    UUID inviteGroupAgent = UUID.Zero;
                    if (
                        !AgentNameToUUID(groupInviteName.First(), groupInviteName.Last(),
                            Configuration.SERVICES_TIMEOUT,
                            Configuration.DATA_TIMEOUT,
                            ref inviteGroupAgent)) return;

                    // Add the group invite - have to track them manually.
                    lock (GroupInviteLock)
                    {
                        GroupInvites.Add(new GroupInvite
                        {
                            Agent = new Agent
                            {
                                FirstName = groupInviteName.First(),
                                LastName = groupInviteName.Last(),
                                UUID = inviteGroupAgent
                            },
                            Group = inviteGroup.Name,
                            Session = args.IM.IMSessionID,
                            Fee = inviteGroup.MembershipFee
                        });
                    }
                    // Send group invitation notification.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.NOTIFICATION_GROUP_INVITE, args),
                        Configuration.MAXIMUM_NOTIFICATION_THREADS);
                    // If a master sends it, then accept.
                    if (
                        !Configuration.MASTERS.AsParallel().Select(
                            o =>
                                string.Format(CultureInfo.InvariantCulture, "{0}.{1}", o.FirstName, o.LastName))
                            .
                            Any(p => p.Equals(args.IM.FromAgentName, StringComparison.OrdinalIgnoreCase)))
                        return;

                    Client.Self.GroupInviteRespond(inviteGroup.ID, args.IM.IMSessionID, true);
                    return;
                // Group notice inventory accepted, declined or notice received.
                case InstantMessageDialog.GroupNoticeInventoryAccepted:
                case InstantMessageDialog.GroupNoticeInventoryDeclined:
                case InstantMessageDialog.GroupNotice:
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.NOTIFICATION_GROUP_NOTICE, args),
                        Configuration.MAXIMUM_NOTIFICATION_THREADS);
                    return;
                case InstantMessageDialog.SessionSend:
                case InstantMessageDialog.MessageFromAgent:
                    // Check if this is a group message.
                    // Note that this is a lousy way of doing it but libomv does not properly set the GroupIM field
                    // such that the only way to determine if we have a group message is to check that the UUID
                    // of the session is actually the UUID of a current group. Furthermore, what's worse is that 
                    // group mesages can appear both through SessionSend and from MessageFromAgent. Hence the problem.
                    HashSet<UUID> currentGroups = new HashSet<UUID>();
                    if (
                        !GetCurrentGroups(Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                            ref currentGroups))
                        return;

                    if (currentGroups.AsParallel().Any(o => o.Equals(args.IM.IMSessionID)))
                    {
                        Group messageGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(p => p.UUID.Equals(args.IM.IMSessionID));
                        if (!messageGroup.Equals(default(Group)))
                        {
                            // Send group notice notifications.
                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                () => SendNotification(Notifications.NOTIFICATION_GROUP_MESSAGE, args),
                                Configuration.MAXIMUM_NOTIFICATION_THREADS);
                            // Log group messages
                            Parallel.ForEach(
                                Configuration.GROUPS.AsParallel().Where(
                                    o =>
                                        o.Name.Equals(messageGroup.Name, StringComparison.Ordinal) &&
                                        o.ChatLogEnabled),
                                o =>
                                {
                                    // Attempt to write to log file,
                                    try
                                    {
                                        lock (GroupLogFileLock)
                                        {
                                            using (StreamWriter logWriter = File.AppendText(o.ChatLog))
                                            {
                                                logWriter.WriteLine("[{0}] {1} {2} : {3}",
                                                    DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                        DateTimeFormatInfo.InvariantInfo), fullName.First(),
                                                    fullName.Last(),
                                                    args.IM.Message);
                                                //logWriter.Flush();
                                                //logWriter.Close();
                                            }
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        // or fail and append the fail message.
                                        Feedback(
                                            wasGetDescriptionFromEnumValue(
                                                ConsoleError.COULD_NOT_WRITE_TO_GROUP_CHAT_LOG_FILE),
                                            ex.Message);
                                    }
                                });
                        }
                        return;
                    }
                    // Check if this is an instant message.
                    if (args.IM.ToAgentID.Equals(Client.Self.AgentID))
                    {
                        CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                            () => SendNotification(Notifications.NOTIFICATION_INSTANT_MESSAGE, args),
                            Configuration.MAXIMUM_NOTIFICATION_THREADS);

                        // Check if we were ejected.
                        UUID groupUUID = UUID.Zero;
                        if (
                            GroupNameToUUID(
                                CORRADE_CONSTANTS.EjectedFromGroupRegEx.Match(args.IM.Message).Groups[1].Value,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref groupUUID))
                        {
                            // Remove the group from the cache.
                            lock (Cache.Locks.CurrentGroupsCacheLock)
                            {
                                if (Cache.CurrentGroupsCache.Contains(groupUUID))
                                {
                                    Cache.CurrentGroupsCache.Remove(groupUUID);
                                }
                            }
                        }

                        // Log instant messages,
                        if (Configuration.INSTANT_MESSAGE_LOG_ENABLED)
                        {
                            try
                            {
                                lock (InstantMessageLogFileLock)
                                {
                                    using (
                                        StreamWriter logWriter =
                                            File.AppendText(
                                                wasPathCombine(Configuration.INSTANT_MESSAGE_LOG_DIRECTORY,
                                                    args.IM.FromAgentName) +
                                                "." + CORRADE_CONSTANTS.LOG_FILE_EXTENSION))
                                    {
                                        logWriter.WriteLine("[{0}] {1} {2} : {3}",
                                            DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                DateTimeFormatInfo.InvariantInfo), fullName.First(), fullName.Last(),
                                            args.IM.Message);
                                        //logWriter.Flush();
                                        //logWriter.Close();
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                // or fail and append the fail message.
                                Feedback(
                                    wasGetDescriptionFromEnumValue(
                                        ConsoleError.COULD_NOT_WRITE_TO_INSTANT_MESSAGE_LOG_FILE),
                                    ex.Message);
                            }
                        }
                        return;
                    }
                    // Check if this is a region message.
                    if (args.IM.IMSessionID.Equals(UUID.Zero))
                    {
                        CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                            () => SendNotification(Notifications.NOTIFICATION_REGION_MESSAGE, args),
                            Configuration.MAXIMUM_NOTIFICATION_THREADS);
                        // Log region messages,
                        if (Configuration.REGION_MESSAGE_LOG_ENABLED)
                        {
                            try
                            {
                                lock (RegionLogFileLock)
                                {
                                    using (
                                        StreamWriter logWriter =
                                            File.AppendText(
                                                wasPathCombine(Configuration.REGION_MESSAGE_LOG_DIRECTORY,
                                                    Client.Network.CurrentSim.Name) + "." +
                                                CORRADE_CONSTANTS.LOG_FILE_EXTENSION))
                                    {
                                        logWriter.WriteLine("[{0}] {1} {2} : {3}",
                                            DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                DateTimeFormatInfo.InvariantInfo), fullName.First(), fullName.Last(),
                                            args.IM.Message);
                                        //logWriter.Flush();
                                        //logWriter.Close();
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                // or fail and append the fail message.
                                Feedback(
                                    wasGetDescriptionFromEnumValue(
                                        ConsoleError.COULD_NOT_WRITE_TO_REGION_MESSAGE_LOG_FILE),
                                    ex.Message);
                            }
                        }
                        return;
                    }
                    break;
            }

            // Where are now in a region where the message is an IM sent by an object.
            // Check if this is not a Corrade command and send an object IM notification.
            if (!IsCorradeCommand(args.IM.Message))
            {
                CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                    () => SendNotification(Notifications.NOTIFICATION_OBJECT_INSTANT_MESSAGE, args),
                    Configuration.MAXIMUM_NOTIFICATION_THREADS);
                return;
            }

            // Otherwise process the command.
            CorradeThreadPool[CorradeThreadType.COMMAND].Spawn(
                () => HandleCorradeCommand(args.IM.Message, args.IM.FromAgentName, args.IM.FromAgentID.ToString()),
                Configuration.MAXIMUM_COMMAND_THREADS);
        }

        /// <summary>
        ///     Processes a RLV behaviour.
        /// </summary>
        /// <param name="message">the RLV message to process</param>
        /// <param name="senderUUID">the UUID of the sender</param>
        private static void HandleRLVBehaviour(string message, UUID senderUUID)
        {
            if (string.IsNullOrEmpty(message)) return;

            // Split all commands.
            string[] unpack = message.Split(RLV_CONSTANTS.CSV_DELIMITER[0]);
            // Pop first command to process.
            string first = unpack.First();
            // Remove command.
            unpack = unpack.AsParallel().Where(o => !o.Equals(first)).ToArray();
            // Keep rest of message.
            message = string.Join(RLV_CONSTANTS.CSV_DELIMITER, unpack);

            Match match = RLV_CONSTANTS.RLVRegEx.Match(first);
            if (!match.Success) goto CONTINUE;

            RLVRule RLVrule = new RLVRule
            {
                Behaviour = match.Groups["behaviour"].ToString().ToLowerInvariant(),
                Option = match.Groups["option"].ToString().ToLowerInvariant(),
                Param = match.Groups["param"].ToString().ToLowerInvariant(),
                ObjectUUID = senderUUID
            };

            switch (RLVrule.Param)
            {
                case RLV_CONSTANTS.Y:
                case RLV_CONSTANTS.ADD:
                    if (RLVrule.Option.Equals(string.Empty))
                    {
                        lock (RLVRulesLock)
                        {
                            RLVRules.RemoveWhere(
                                o =>
                                    o.Behaviour.Equals(
                                        RLVrule.Behaviour,
                                        StringComparison.InvariantCultureIgnoreCase) &&
                                    o.ObjectUUID.Equals(RLVrule.ObjectUUID));
                        }
                        goto CONTINUE;
                    }
                    lock (RLVRulesLock)
                    {
                        RLVRules.RemoveWhere(
                            o =>
                                o.Behaviour.Equals(
                                    RLVrule.Behaviour,
                                    StringComparison.InvariantCultureIgnoreCase) &&
                                o.ObjectUUID.Equals(RLVrule.ObjectUUID) &&
                                o.Option.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                    }
                    goto CONTINUE;
                case RLV_CONSTANTS.N:
                case RLV_CONSTANTS.REM:
                    lock (RLVRulesLock)
                    {
                        RLVRules.RemoveWhere(
                            o =>
                                o.Behaviour.Equals(
                                    RLVrule.Behaviour,
                                    StringComparison.InvariantCultureIgnoreCase) &&
                                o.Option.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase) &&
                                o.ObjectUUID.Equals(RLVrule.ObjectUUID));
                        RLVRules.Add(RLVrule);
                    }
                    goto CONTINUE;
            }

            System.Action execute;

            switch (wasGetEnumValueFromDescription<RLVBehaviour>(RLVrule.Behaviour))
            {
                case RLVBehaviour.VERSION:
                case RLVBehaviour.VERSIONNEW:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        Client.Self.Chat(
                            string.Format("{0} v{1} (Corrade Version: {2} Compiled: {3})", RLV_CONSTANTS.VIEWER,
                                RLV_CONSTANTS.SHORT_VERSION, CORRADE_CONSTANTS.CORRADE_VERSION,
                                CORRADE_CONSTANTS.CORRADE_COMPILE_DATE), channel,
                            ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.VERSIONNUM:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        Client.Self.Chat(RLV_CONSTANTS.LONG_VERSION, channel, ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.GETGROUP:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        UUID groupUUID = Client.Self.ActiveGroup;
                        HashSet<UUID> currentGroups = new HashSet<UUID>();
                        if (
                            !GetCurrentGroups(Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                ref currentGroups))
                            return;
                        if (!currentGroups.AsParallel().Any(o => o.Equals(groupUUID)))
                        {
                            return;
                        }
                        string groupName = string.Empty;
                        if (
                            !GroupUUIDToName(currentGroups.AsParallel().FirstOrDefault(o => o.Equals(groupUUID)),
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref groupName))
                        {
                            return;
                        }
                        Client.Self.Chat(
                            groupName,
                            channel,
                            ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.SETGROUP:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE))
                        {
                            return;
                        }
                        UUID groupUUID;
                        if (!UUID.TryParse(RLVrule.Option, out groupUUID))
                        {
                            return;
                        }
                        HashSet<UUID> currentGroups = new HashSet<UUID>();
                        if (
                            !GetCurrentGroups(Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                ref currentGroups))
                            return;
                        if (!currentGroups.AsParallel().Any(o => o.Equals(groupUUID)))
                        {
                            return;
                        }
                        Client.Groups.ActivateGroup(groupUUID);
                    };
                    break;
                case RLVBehaviour.GETSITID:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        Avatar me;
                        if (Client.Network.CurrentSim.ObjectsAvatars.TryGetValue(Client.Self.LocalID, out me))
                        {
                            if (me.ParentID != 0)
                            {
                                Primitive sit;
                                if (Client.Network.CurrentSim.ObjectsPrimitives.TryGetValue(me.ParentID, out sit))
                                {
                                    Client.Self.Chat(sit.ID.ToString(), channel, ChatType.Normal);
                                    return;
                                }
                            }
                        }
                        UUID zero = UUID.Zero;
                        Client.Self.Chat(zero.ToString(), channel, ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.SIT:
                    execute = () =>
                    {
                        UUID sitTarget;
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE) || !UUID.TryParse(RLVrule.Option, out sitTarget) ||
                            sitTarget.Equals(UUID.Zero))
                        {
                            return;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(sitTarget,
                                LINDEN_CONSTANTS.LSL.SENSOR_RANGE,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            return;
                        }
                        ManualResetEvent SitEvent = new ManualResetEvent(false);
                        EventHandler<AvatarSitResponseEventArgs> AvatarSitEventHandler =
                            (sender, args) =>
                                SitEvent.Set();
                        EventHandler<AlertMessageEventArgs> AlertMessageEventHandler = (sender, args) => SitEvent.Set();
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        lock (ClientInstanceSelfLock)
                        {
                            Client.Self.AvatarSitResponse += AvatarSitEventHandler;
                            Client.Self.AlertMessage += AlertMessageEventHandler;
                            Client.Self.RequestSit(primitive.ID, Vector3.Zero);
                            SitEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false);
                            Client.Self.AvatarSitResponse -= AvatarSitEventHandler;
                            Client.Self.AlertMessage -= AlertMessageEventHandler;
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case RLVBehaviour.UNSIT:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE))
                        {
                            return;
                        }
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                    };
                    break;
                case RLVBehaviour.SETROT:
                    execute = () =>
                    {
                        double rotation;
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE) ||
                            !double.TryParse(RLVrule.Option, NumberStyles.Float, CultureInfo.InvariantCulture,
                                out rotation))
                        {
                            return;
                        }
                        Client.Self.Movement.UpdateFromHeading(Math.PI/2d - rotation, true);
                    };
                    break;
                case RLVBehaviour.TPTO:
                    execute = () =>
                    {
                        string[] coordinates = RLVrule.Option.Split('/');
                        if (!coordinates.Length.Equals(3))
                        {
                            return;
                        }
                        float globalX;
                        if (!float.TryParse(coordinates[0], out globalX))
                        {
                            return;
                        }
                        float globalY;
                        if (!float.TryParse(coordinates[1], out globalY))
                        {
                            return;
                        }
                        float altitude;
                        if (!float.TryParse(coordinates[2], out altitude))
                        {
                            return;
                        }
                        float localX, localY;
                        ulong handle = Helpers.GlobalPosToRegionHandle(globalX, globalY, out localX, out localY);
                        Client.Self.RequestTeleport(handle, new Vector3(localX, localY, altitude));
                    };
                    break;
                case RLVBehaviour.GETOUTFIT:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        HashSet<KeyValuePair<AppearanceManager.WearableData, WearableType>> wearables =
                            new HashSet<KeyValuePair<AppearanceManager.WearableData, WearableType>>(
                                GetWearables(Client.Inventory.Store.RootNode));
                        StringBuilder response = new StringBuilder();
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                RLVWearable RLVwearable = RLVWearables.AsParallel()
                                    .FirstOrDefault(
                                        o => o.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                if (RLVwearable.Equals(default(RLVWearable)))
                                {
                                    response.Append(RLV_CONSTANTS.FALSE_MARKER);
                                    break;
                                }
                                if (!wearables.AsParallel().Any(o => o.Value.Equals(RLVwearable.WearableType)))
                                {
                                    response.Append(RLV_CONSTANTS.FALSE_MARKER);
                                    break;
                                }
                                response.Append(RLV_CONSTANTS.TRUE_MARKER);
                                break;
                            default:
                                string[] data = new string[RLVWearables.Count];
                                Parallel.ForEach(Enumerable.Range(0, RLVWearables.Count), o =>
                                {
                                    if (!wearables.AsParallel().Any(p => p.Value.Equals(RLVWearables[o].WearableType)))
                                    {
                                        data[o] = RLV_CONSTANTS.FALSE_MARKER;
                                        return;
                                    }
                                    data[o] = RLV_CONSTANTS.TRUE_MARKER;
                                });
                                response.Append(string.Join("", data.ToArray()));
                                break;
                        }
                        Client.Self.Chat(response.ToString(), channel, ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.GETATTACH:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        HashSet<Primitive> attachments = new HashSet<Primitive>(
                            GetAttachments(Configuration.SERVICES_TIMEOUT).AsParallel().Select(o => o.Key));
                        StringBuilder response = new StringBuilder();
                        if (attachments.Count.Equals(0))
                        {
                            Client.Self.Chat(response.ToString(), channel, ChatType.Normal);
                        }
                        HashSet<AttachmentPoint> attachmentPoints =
                            new HashSet<AttachmentPoint>(attachments.AsParallel()
                                .Select(o => o.PrimData.AttachmentPoint));
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                RLVAttachment RLVattachment = RLVAttachments.AsParallel().FirstOrDefault(
                                    o => o.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                if (RLVattachment.Equals(default(RLVAttachment)))
                                {
                                    response.Append(RLV_CONSTANTS.FALSE_MARKER);
                                    break;
                                }
                                if (!attachmentPoints.Contains(RLVattachment.AttachmentPoint))
                                {
                                    response.Append(RLV_CONSTANTS.FALSE_MARKER);
                                    break;
                                }
                                response.Append(RLV_CONSTANTS.TRUE_MARKER);
                                break;
                            default:
                                string[] data = new string[RLVAttachments.Count];
                                Parallel.ForEach(Enumerable.Range(0, RLVAttachments.Count), o =>
                                {
                                    if (!attachmentPoints.Contains(RLVAttachments[o].AttachmentPoint))
                                    {
                                        data[o] = RLV_CONSTANTS.FALSE_MARKER;
                                        return;
                                    }
                                    data[o] = RLV_CONSTANTS.TRUE_MARKER;
                                });
                                response.Append(string.Join("", data.ToArray()));
                                break;
                        }
                        Client.Self.Chat(response.ToString(), channel, ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.DETACHME:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE))
                        {
                            return;
                        }
                        KeyValuePair<Primitive, AttachmentPoint> attachment =
                            GetAttachments(Configuration.SERVICES_TIMEOUT)
                                .AsParallel().FirstOrDefault(o => o.Key.ID.Equals(senderUUID));
                        if (attachment.Equals(default(KeyValuePair<Primitive, AttachmentPoint>)))
                        {
                            return;
                        }
                        InventoryBase inventoryBase =
                            FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                attachment.Key.Properties.ItemID
                                )
                                .AsParallel().FirstOrDefault(
                                    p =>
                                        (p is InventoryItem) &&
                                        ((InventoryItem) p).AssetType.Equals(AssetType.Object));
                        if (inventoryBase is InventoryAttachment || inventoryBase is InventoryObject)
                        {
                            Detach(inventoryBase as InventoryItem);
                        }
                        RebakeTimer.Change(Configuration.REBAKE_DELAY, 0);
                    };
                    break;
                case RLVBehaviour.REMATTACH:
                case RLVBehaviour.DETACH:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE))
                        {
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            return;
                        }
                        InventoryBase inventoryBase;
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                RLVAttachment RLVattachment =
                                    RLVAttachments.AsParallel().FirstOrDefault(
                                        o => o.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                switch (!RLVattachment.Equals(default(RLVAttachment)))
                                {
                                    case true: // detach by attachment point
                                        Parallel.ForEach(
                                            GetAttachments(Configuration.SERVICES_TIMEOUT)
                                                .AsParallel().Where(o => o.Value.Equals(RLVattachment.AttachmentPoint)),
                                            o =>
                                            {
                                                inventoryBase =
                                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                                        o.Key.Properties.Name
                                                        )
                                                        .AsParallel().FirstOrDefault(
                                                            p =>
                                                                (p is InventoryItem) &&
                                                                ((InventoryItem) p).AssetType.Equals(
                                                                    AssetType.Object));
                                                if (inventoryBase is InventoryAttachment ||
                                                    inventoryBase is InventoryObject)
                                                {
                                                    Detach(inventoryBase as InventoryItem);
                                                }
                                            });
                                        break;
                                    default: // detach by folder(s) name
                                        Parallel.ForEach(
                                            RLVrule.Option.Split(RLV_CONSTANTS.PATH_SEPARATOR[0])
                                                .AsParallel().Select(
                                                    folder =>
                                                        FindInventory<InventoryBase>(RLVFolder,
                                                            new Regex(Regex.Escape(folder),
                                                                RegexOptions.Compiled | RegexOptions.IgnoreCase)
                                                            ).AsParallel().FirstOrDefault(o => (o is InventoryFolder))),
                                            o =>
                                            {
                                                if (o != null)
                                                {
                                                    Client.Inventory.Store.GetContents(
                                                        o as InventoryFolder).FindAll(CanBeWorn)
                                                        .ForEach(
                                                            p =>
                                                            {
                                                                if (p is InventoryWearable)
                                                                {
                                                                    UnWear(p as InventoryItem);
                                                                    return;
                                                                }
                                                                if (p is InventoryAttachment ||
                                                                    p is InventoryObject)
                                                                {
                                                                    // Multiple attachment points not working in libOpenMetaverse, so just replace.
                                                                    Detach(p as InventoryItem);
                                                                }
                                                            });
                                                }
                                            });
                                        break;
                                }
                                break;
                            default: //detach everything from RLV attachmentpoints
                                Parallel.ForEach(
                                    GetAttachments(Configuration.SERVICES_TIMEOUT)
                                        .AsParallel()
                                        .Where(o => RLVAttachments.Any(p => p.AttachmentPoint.Equals(o.Value))), o =>
                                        {
                                            inventoryBase = FindInventory<InventoryBase>(
                                                Client.Inventory.Store.RootNode, o.Key.Properties.Name
                                                )
                                                .AsParallel().FirstOrDefault(
                                                    p =>
                                                        p is InventoryItem &&
                                                        ((InventoryItem) p).AssetType.Equals(AssetType.Object));
                                            if (inventoryBase is InventoryAttachment || inventoryBase is InventoryObject)
                                            {
                                                Detach(inventoryBase as InventoryItem);
                                            }
                                        });
                                break;
                        }
                        RebakeTimer.Change(Configuration.REBAKE_DELAY, 0);
                    };
                    break;
                case RLVBehaviour.ATTACH:
                case RLVBehaviour.ATTACHOVERORREPLACE:
                case RLVBehaviour.ATTACHOVER:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE) || string.IsNullOrEmpty(RLVrule.Option))
                        {
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            return;
                        }
                        Parallel.ForEach(
                            RLVrule.Option.Split(RLV_CONSTANTS.PATH_SEPARATOR[0])
                                .AsParallel().Select(
                                    folder =>
                                        FindInventory<InventoryBase>(RLVFolder,
                                            new Regex(Regex.Escape(folder),
                                                RegexOptions.Compiled | RegexOptions.IgnoreCase)
                                            ).AsParallel().FirstOrDefault(o => (o is InventoryFolder))), o =>
                                            {
                                                if (o != null)
                                                {
                                                    Client.Inventory.Store.GetContents(o as InventoryFolder).
                                                        FindAll(CanBeWorn)
                                                        .ForEach(
                                                            p =>
                                                            {
                                                                if (p is InventoryWearable)
                                                                {
                                                                    Wear(p as InventoryItem, true);
                                                                    return;
                                                                }
                                                                if (p is InventoryObject || p is InventoryAttachment)
                                                                {
                                                                    // Multiple attachment points not working in libOpenMetaverse, so just replace.
                                                                    Attach(p as InventoryItem,
                                                                        AttachmentPoint.Default,
                                                                        true);
                                                                }
                                                            });
                                                }
                                            });
                        RebakeTimer.Change(Configuration.REBAKE_DELAY, 0);
                    };
                    break;
                case RLVBehaviour.REMOUTFIT:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE))
                        {
                            return;
                        }
                        InventoryBase inventoryBase;
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true: // A single wearable
                                FieldInfo wearTypeInfo = typeof (WearableType).GetFields(BindingFlags.Public |
                                                                                         BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        p => p.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                if (wearTypeInfo == null)
                                {
                                    break;
                                }
                                KeyValuePair<AppearanceManager.WearableData, WearableType> wearable = GetWearables(
                                    Client.Inventory.Store.RootNode)
                                    .AsParallel().FirstOrDefault(
                                        o => o.Value.Equals((WearableType) wearTypeInfo.GetValue(null)));
                                if (wearable.Equals(default(KeyValuePair<AppearanceManager.WearableData, WearableType>)))
                                {
                                    break;
                                }
                                inventoryBase = FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                    wearable.Value).FirstOrDefault();
                                if (inventoryBase == null)
                                {
                                    break;
                                }
                                UnWear(inventoryBase as InventoryItem);
                                break;
                            default:
                                Parallel.ForEach(GetWearables(Client.Inventory.Store.RootNode)
                                    .AsParallel().Select(o => new[]
                                    {
                                        o.Key
                                    }).SelectMany(o => o), o =>
                                    {
                                        inventoryBase =
                                            FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, o.ItemID
                                                )
                                                .FirstOrDefault(p => (p is InventoryWearable));
                                        if (inventoryBase == null)
                                        {
                                            return;
                                        }
                                        UnWear(inventoryBase as InventoryItem);
                                    });
                                break;
                        }
                        RebakeTimer.Change(Configuration.REBAKE_DELAY, 0);
                    };
                    break;
                case RLVBehaviour.GETPATHNEW:
                case RLVBehaviour.GETPATH:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        // General variables
                        InventoryBase inventoryBase = null;
                        KeyValuePair<Primitive, AttachmentPoint> attachment;
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                // Try attachments
                                RLVAttachment RLVattachment =
                                    RLVAttachments.AsParallel().FirstOrDefault(
                                        o => o.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                if (!RLVattachment.Equals(default(RLVAttachment)))
                                {
                                    attachment =
                                        GetAttachments(Configuration.SERVICES_TIMEOUT)
                                            .AsParallel()
                                            .FirstOrDefault(o => o.Value.Equals(RLVattachment.AttachmentPoint));
                                    if (attachment.Equals(default(KeyValuePair<Primitive, AttachmentPoint>)))
                                    {
                                        return;
                                    }
                                    inventoryBase = FindInventory<InventoryBase>(
                                        RLVFolder, attachment.Key.Properties.ItemID
                                        )
                                        .AsParallel().FirstOrDefault(
                                            p =>
                                                (p is InventoryItem) &&
                                                ((InventoryItem) p).AssetType.Equals(AssetType.Object));
                                    break;
                                }
                                RLVWearable RLVwearable =
                                    RLVWearables.AsParallel().FirstOrDefault(
                                        o => o.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                if (!RLVwearable.Equals(default(RLVWearable)))
                                {
                                    FieldInfo wearTypeInfo = typeof (WearableType).GetFields(BindingFlags.Public |
                                                                                             BindingFlags.Static)
                                        .AsParallel().FirstOrDefault(
                                            p =>
                                                p.Name.Equals(RLVrule.Option,
                                                    StringComparison.InvariantCultureIgnoreCase));
                                    if (wearTypeInfo == null)
                                    {
                                        return;
                                    }
                                    KeyValuePair<AppearanceManager.WearableData, WearableType> wearable = GetWearables(
                                        RLVFolder)
                                        .AsParallel().FirstOrDefault(
                                            o => o.Value.Equals((WearableType) wearTypeInfo.GetValue(null)));
                                    if (
                                        wearable.Equals(
                                            default(KeyValuePair<AppearanceManager.WearableData, WearableType>)))
                                    {
                                        return;
                                    }
                                    inventoryBase =
                                        FindInventory<InventoryBase>(RLVFolder,
                                            wearable
                                                .Key.ItemID)
                                            .AsParallel().FirstOrDefault(o => (o is InventoryWearable));
                                }
                                break;
                            default:
                                attachment =
                                    GetAttachments(Configuration.SERVICES_TIMEOUT)
                                        .AsParallel().FirstOrDefault(o => o.Key.ID.Equals(senderUUID));
                                if (attachment.Equals(default(KeyValuePair<Primitive, AttachmentPoint>)))
                                {
                                    break;
                                }
                                inventoryBase = FindInventory<InventoryBase>(
                                    Client.Inventory.Store.RootNode, attachment.Key.Properties.ItemID
                                    )
                                    .AsParallel().FirstOrDefault(
                                        p =>
                                            (p is InventoryItem) &&
                                            ((InventoryItem) p).AssetType.Equals(AssetType.Object));
                                break;
                        }
                        if (inventoryBase == null)
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        KeyValuePair<InventoryBase, LinkedList<string>> path =
                            FindInventoryPath<InventoryBase>(RLVFolder, inventoryBase.Name,
                                new LinkedList<string>()).FirstOrDefault();
                        if (path.Equals(default(KeyValuePair<InventoryBase, LinkedList<string>>)))
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        Client.Self.Chat(string.Join(RLV_CONSTANTS.PATH_SEPARATOR, path.Value.ToArray()), channel,
                            ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.FINDFOLDER:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        if (string.IsNullOrEmpty(RLVrule.Option))
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        List<string> folders = new List<string>();
                        HashSet<string> parts =
                            new HashSet<string>(RLVrule.Option.Split(RLV_CONSTANTS.AND_OPERATOR.ToCharArray()));
                        object LockObject = new object();
                        Parallel.ForEach(FindInventoryPath<InventoryBase>(RLVFolder,
                            CORRADE_CONSTANTS.OneOrMoRegex,
                            new LinkedList<string>())
                            .AsParallel().Where(
                                o =>
                                    o.Key is InventoryFolder &&
                                    !o.Key.Name.Substring(1).Equals(RLV_CONSTANTS.DOT_MARKER) &&
                                    !o.Key.Name.Substring(1).Equals(RLV_CONSTANTS.TILDE_MARKER)), o =>
                                    {
                                        int count = 0;
                                        Parallel.ForEach(parts, p => Parallel.ForEach(o.Value, q =>
                                        {
                                            if (q.Contains(p))
                                            {
                                                Interlocked.Increment(ref count);
                                            }
                                        }));
                                        if (!count.Equals(parts.Count)) return;
                                        lock (LockObject)
                                        {
                                            folders.Add(o.Key.Name);
                                        }
                                    });
                        if (!folders.Count.Equals(0))
                        {
                            Client.Self.Chat(string.Join(RLV_CONSTANTS.PATH_SEPARATOR, folders.ToArray()),
                                channel,
                                ChatType.Normal);
                        }
                    };
                    break;
                case RLVBehaviour.GETINV:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        if (string.IsNullOrEmpty(RLVrule.Option))
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        InventoryNode optionFolderNode;
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                KeyValuePair<InventoryNode, LinkedList<string>> folderPath = FindInventoryPath
                                    <InventoryNode>(
                                        RLVFolder,
                                        CORRADE_CONSTANTS.OneOrMoRegex,
                                        new LinkedList<string>())
                                    .AsParallel().Where(o => o.Key.Data is InventoryFolder)
                                    .FirstOrDefault(
                                        o =>
                                            string.Join(RLV_CONSTANTS.PATH_SEPARATOR, o.Value.Skip(1).ToArray())
                                                .Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                if (folderPath.Equals(default(KeyValuePair<InventoryNode, LinkedList<string>>)))
                                {
                                    Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                                    return;
                                }
                                optionFolderNode = folderPath.Key;
                                break;
                            default:
                                optionFolderNode = RLVFolder;
                                break;
                        }
                        HashSet<string> csv = new HashSet<string>();
                        object LockObject = new object();
                        Parallel.ForEach(
                            FindInventory<InventoryBase>(optionFolderNode, CORRADE_CONSTANTS.OneOrMoRegex),
                            o =>
                            {
                                if (o.Name.StartsWith(RLV_CONSTANTS.DOT_MARKER)) return;
                                lock (LockObject)
                                {
                                    csv.Add(o.Name);
                                }
                            });
                        Client.Self.Chat(string.Join(RLV_CONSTANTS.CSV_DELIMITER, csv.ToArray()), channel,
                            ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.GETINVWORN:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        KeyValuePair<InventoryNode, LinkedList<string>> folderPath = FindInventoryPath<InventoryNode>(
                            RLVFolder,
                            CORRADE_CONSTANTS.OneOrMoRegex,
                            new LinkedList<string>())
                            .AsParallel().Where(o => o.Key.Data is InventoryFolder)
                            .FirstOrDefault(
                                o =>
                                    string.Join(RLV_CONSTANTS.PATH_SEPARATOR, o.Value.Skip(1).ToArray())
                                        .Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                        if (folderPath.Equals(default(KeyValuePair<InventoryNode, LinkedList<string>>)))
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        Func<InventoryNode, string> GetWornIndicator = node =>
                        {
                            Dictionary<AppearanceManager.WearableData, WearableType> currentWearables =
                                GetWearables(Client.Inventory.Store.RootNode).ToDictionary(o => o.Key, o => o.Value);
                            Dictionary<Primitive, AttachmentPoint> currentAttachments =
                                GetAttachments(Configuration.SERVICES_TIMEOUT).ToDictionary(o => o.Key, p => p.Value);

                            int myItemsCount = 0;
                            int myItemsWornCount = 0;

                            Parallel.ForEach(
                                node.Nodes.Values.AsParallel().Where(
                                    n =>
                                        !n.Data.Name.StartsWith(RLV_CONSTANTS.DOT_MARKER) &&
                                        n.Data is InventoryItem && CanBeWorn(n.Data)
                                    ), n =>
                                    {
                                        Interlocked.Increment(ref myItemsCount);
                                        if ((n.Data is InventoryWearable &&
                                             currentWearables.Keys.AsParallel().Any(
                                                 o => o.ItemID.Equals(ResolveItemLink(n.Data as InventoryItem).UUID))) ||
                                            currentAttachments.AsParallel().Any(
                                                o =>
                                                    o.Key.Properties.ItemID.Equals(
                                                        ResolveItemLink(n.Data as InventoryItem).UUID)))
                                        {
                                            Interlocked.Increment(ref myItemsWornCount);
                                        }
                                    });


                            int allItemsCount = 0;
                            int allItemsWornCount = 0;

                            Parallel.ForEach(
                                node.Nodes.Values.AsParallel().Where(
                                    n =>
                                        !n.Data.Name.StartsWith(RLV_CONSTANTS.DOT_MARKER) &&
                                        n.Data is InventoryFolder
                                    ),
                                n => Parallel.ForEach(n.Nodes.Values
                                    .AsParallel().Where(o => !o.Data.Name.StartsWith(RLV_CONSTANTS.DOT_MARKER))
                                    .Where(
                                        o =>
                                            o.Data is InventoryItem && CanBeWorn(o.Data) &&
                                            !o.Data.Name.StartsWith(RLV_CONSTANTS.DOT_MARKER)), p =>
                                            {
                                                Interlocked.Increment(ref allItemsCount);
                                                if ((p.Data is InventoryWearable &&
                                                     currentWearables.Keys.AsParallel().Any(
                                                         o =>
                                                             o.ItemID.Equals(
                                                                 ResolveItemLink(p.Data as InventoryItem).UUID))) ||
                                                    currentAttachments.AsParallel().Any(
                                                        o =>
                                                            o.Key.Properties.ItemID.Equals(
                                                                ResolveItemLink(p.Data as InventoryItem).UUID)))
                                                {
                                                    Interlocked.Increment(ref allItemsWornCount);
                                                }
                                            }));


                            Func<int, int, string> WornIndicator =
                                (all, one) => all > 0 ? (all.Equals(one) ? "3" : (one > 0 ? "2" : "1")) : "0";

                            return WornIndicator(myItemsCount, myItemsWornCount) +
                                   WornIndicator(allItemsCount, allItemsWornCount);
                        };
                        List<string> response = new List<string>
                        {
                            string.Format("{0}{1}", RLV_CONSTANTS.PROPORTION_SEPARATOR,
                                GetWornIndicator(folderPath.Key))
                        };
                        response.AddRange(
                            folderPath.Key.Nodes.Values.AsParallel().Where(node => node.Data is InventoryFolder)
                                .Select(
                                    node =>
                                        string.Format("{0}{1}{2}", node.Data.Name,
                                            RLV_CONSTANTS.PROPORTION_SEPARATOR, GetWornIndicator(node))));

                        Client.Self.Chat(string.Join(RLV_CONSTANTS.CSV_DELIMITER, response.ToArray()),
                            channel,
                            ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.GETSTATUSALL:
                case RLVBehaviour.GETSTATUS:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        string separator = RLV_CONSTANTS.PATH_SEPARATOR;
                        string filter = string.Empty;
                        if (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            string[] parts = RLVrule.Option.Split(RLV_CONSTANTS.STATUS_SEPARATOR[0]);
                            if (parts.Length > 1 && parts[1].Length > 0)
                            {
                                separator = parts[1].Substring(0, 1);
                            }
                            if (parts.Length > 0 && parts[0].Length > 0)
                            {
                                filter = parts[0].ToLowerInvariant();
                            }
                        }
                        StringBuilder response = new StringBuilder();
                        lock (RLVRulesLock)
                        {
                            object LockObject = new object();
                            Parallel.ForEach(RLVRules.AsParallel().Where(o =>
                                o.ObjectUUID.Equals(senderUUID) && o.Behaviour.Contains(filter)
                                ), o =>
                                {
                                    lock (LockObject)
                                    {
                                        response.AppendFormat("{0}{1}", separator, o.Behaviour);
                                    }
                                    if (!string.IsNullOrEmpty(o.Option))
                                    {
                                        lock (LockObject)
                                        {
                                            response.AppendFormat("{0}{1}", RLV_CONSTANTS.PATH_SEPARATOR, o.Option);
                                        }
                                    }
                                });
                        }
                        Client.Self.Chat(response.ToString(),
                            channel,
                            ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.CLEAR:
                    execute = () =>
                    {
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                lock (RLVRulesLock)
                                {
                                    RLVRules.RemoveWhere(o => o.Behaviour.Contains(RLVrule.Behaviour));
                                }
                                break;
                            case false:
                                lock (RLVRulesLock)
                                {
                                    RLVRules.RemoveWhere(o => o.ObjectUUID.Equals(senderUUID));
                                }
                                break;
                        }
                    };
                    break;
                default:
                    execute =
                        () =>
                        {
                            throw new Exception(string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR,
                                wasGetDescriptionFromEnumValue(ConsoleError.BEHAVIOUR_NOT_IMPLEMENTED),
                                RLVrule.Behaviour));
                        };
                    break;
            }

            try
            {
                execute.Invoke();
            }
            catch (Exception ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.FAILED_TO_MANIFEST_RLV_BEHAVIOUR), ex.Message);
            }

            CONTINUE:
            HandleRLVBehaviour(message, senderUUID);
        }

        private static Dictionary<string, string> HandleCorradeCommand(string message, string sender, string identifier)
        {
            // Now we can start processing commands.
            // Get group and password.
            string group =
                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP)), message));
            // Bail if no group set.
            if (string.IsNullOrEmpty(group)) return null;
            // If an UUID was sent, try to resolve to a name and bail if not.
            UUID groupUUID;
            if (UUID.TryParse(group, out groupUUID))
            {
                // First, trust the user to have properly configured the UUID for the group.
                Group configGroup = Configuration.GROUPS.AsParallel().FirstOrDefault(o => o.UUID.Equals(groupUUID));
                switch (!configGroup.Equals(default(Group)))
                {
                    case true:
                        // If they have, then just grab the group name.
                        group = configGroup.Name;
                        break;
                    default:
                        // Otherwise, attempt to resolve the group name.
                        if (
                            !GroupUUIDToName(groupUUID, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                ref group)) return null;

                        break;
                }
            }
            // Set literal group.
            message = wasKeyValueSet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP)),
                wasOutput(group), message);
            // Get password.
            string password =
                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PASSWORD)), message));
            // Bail if no password set.
            if (string.IsNullOrEmpty(password)) return null;
            // Authenticate the request against the group password.
            if (!Authenticate(group, password))
            {
                Feedback(group, wasGetDescriptionFromEnumValue(ConsoleError.ACCESS_DENIED));
                return null;
            }
            // Censor password.
            message = wasKeyValueSet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PASSWORD)),
                CORRADE_CONSTANTS.PASSWORD_CENSOR, message);
            /*
             * OpenSim sends the primitive UUID through args.IM.FromAgentID while Second Life properly sends 
             * the agent UUID - which just shows how crap OpenSim really is. This tries to resolve 
             * args.IM.FromAgentID to a name, which is what Second Life does, otherwise it just sets the name 
             * to the name of the primitive sending the message.
             */
            bool isSecondLife;
            lock (ClientInstanceNetworkLock)
            {
                isSecondLife = Client.Network.CurrentSim.SimVersion.Contains(LINDEN_CONSTANTS.GRID.SECOND_LIFE);
            }
            if (isSecondLife)
            {
                UUID fromAgentID;
                if (UUID.TryParse(identifier, out fromAgentID))
                {
                    if (
                        !AgentUUIDToName(fromAgentID, Configuration.SERVICES_TIMEOUT,
                            ref sender))
                    {
                        Feedback(wasGetDescriptionFromEnumValue(ConsoleError.AGENT_NOT_FOUND),
                            fromAgentID.ToString());
                        return null;
                    }
                }
            }


            // Log the command.
            Feedback(string.Format(CultureInfo.InvariantCulture, "{0} ({1}) : {2}", sender,
                identifier,
                message));

            // Initialize workers for the group if they are not set.
            lock (GroupWorkersLock)
            {
                if (!GroupWorkers.Contains(group))
                {
                    GroupWorkers.Add(group, 0u);
                }
            }

            // Check if the workers have not been exceeded.
            lock (GroupWorkersLock)
            {
                if ((uint) GroupWorkers[group] >
                    Configuration.GROUPS.AsParallel().FirstOrDefault(
                        o => o.Name.Equals(group, StringComparison.InvariantCultureIgnoreCase)).Workers)
                {
                    // And refuse to proceed if they have.
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.WORKERS_EXCEEDED),
                        group);
                    return null;
                }
            }

            // Increment the group workers.
            lock (GroupWorkersLock)
            {
                GroupWorkers[group] = ((uint) GroupWorkers[group]) + 1;
            }
            // Perform the command.
            Dictionary<string, string> result = ProcessCommand(message);
            // Decrement the group workers.
            lock (GroupWorkersLock)
            {
                GroupWorkers[group] = ((uint) GroupWorkers[group]) - 1;
            }
            // do not send a callback if the callback queue is saturated
            if (CallbackQueue.Count >= Configuration.CALLBACK_QUEUE_LENGTH) return result;
            // send callback if registered
            string url =
                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.CALLBACK)), message));
            // if no url was provided, do not send the callback
            if (string.IsNullOrEmpty(url)) return result;
            lock (CallbackQueueLock)
            {
                CallbackQueue.Enqueue(new CallbackQueueElement
                {
                    URL = url,
                    message = wasKeyValueEscape(result)
                });
            }
            return result;
        }

        /// <summary>
        ///     This function is responsible for processing commands.
        /// </summary>
        /// <param name="message">the message</param>
        /// <returns>a dictionary of key-value pairs representing the results of the command</returns>
        private static Dictionary<string, string> ProcessCommand(string message)
        {
            Dictionary<string, string> result = new Dictionary<string, string>();
            string command =
                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.COMMAND)), message));
            if (!string.IsNullOrEmpty(command))
            {
                result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.COMMAND), command);
            }
            string group =
                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP)), message));
            if (!string.IsNullOrEmpty(group))
            {
                result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP), group);
            }

            System.Action execute;

            switch (wasGetEnumValueFromDescription<ScriptKeys>(command))
            {
                case ScriptKeys.JOIN:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                            Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ALREADY_IN_GROUP));
                        }
                        OpenMetaverse.Group commandGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(groupUUID, Configuration.SERVICES_TIMEOUT, ref commandGroup))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                        }
                        if (!commandGroup.OpenEnrollment)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_OPEN));
                        }
                        if (!Client.Network.MaxAgentGroups.Equals(-1))
                        {
                            HashSet<UUID> currentGroups = new HashSet<UUID>();
                            if (
                                !GetCurrentGroups(Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref currentGroups))
                            {
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_GET_CURRENT_GROUPS));
                            }
                            if (currentGroups.Count >= Client.Network.MaxAgentGroups)
                            {
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.MAXIMUM_NUMBER_OF_GROUPS_REACHED));
                            }
                        }
                        ManualResetEvent GroupJoinedReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupOperationEventArgs> GroupOperationEventHandler =
                            (sender, args) => GroupJoinedReplyEvent.Set();
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupJoinedReply += GroupOperationEventHandler;
                            Client.Groups.RequestJoinGroup(groupUUID);
                            if (!GroupJoinedReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupJoinedReply -= GroupOperationEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_JOINING_GROUP));
                            }
                            Client.Groups.GroupJoinedReply -= GroupOperationEventHandler;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_JOIN_GROUP));
                        }
                    };
                    break;
                case ScriptKeys.CREATEGROUP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        if (!UpdateBalance(Configuration.SERVICES_TIMEOUT))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE));
                        }
                        if (Client.Self.Balance < Configuration.GROUP_CREATE_FEE)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INSUFFICIENT_FUNDS));
                        }
                        if (!Configuration.GROUP_CREATE_FEE.Equals(0) &&
                            !HasCorradePermission(group, (int) Permissions.PERMISSION_ECONOMY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        OpenMetaverse.Group commandGroup = new OpenMetaverse.Group
                        {
                            Name = group
                        };
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message)),
                            ref commandGroup);
                        bool succeeded = false;
                        ManualResetEvent GroupCreatedReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupCreatedReplyEventArgs> GroupCreatedEventHandler = (sender, args) =>
                        {
                            succeeded = args.Success;
                            GroupCreatedReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupCreatedReply += GroupCreatedEventHandler;
                            Client.Groups.RequestCreateGroup(commandGroup);
                            if (!GroupCreatedReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupCreatedReply -= GroupCreatedEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_CREATING_GROUP));
                            }
                            Client.Groups.GroupCreatedReply -= GroupCreatedEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_CREATE_GROUP));
                        }
                    };
                    break;
                case ScriptKeys.INVITE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.Invite,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        if (AgentInGroup(agentUUID, groupUUID, Configuration.SERVICES_TIMEOUT,
                            Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ALREADY_IN_GROUP));
                        }
                        HashSet<UUID> roleUUIDs = new HashSet<UUID>();
                        foreach (
                            string role in
                                wasCSVToEnumerable(
                                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                        message)))
                                    .AsParallel().Where(o => !string.IsNullOrEmpty(o)))
                        {
                            UUID roleUUID;
                            if (!UUID.TryParse(role, out roleUUID) &&
                                !RoleNameToRoleUUID(role, groupUUID,
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref roleUUID))
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ROLE_NOT_FOUND));
                            }
                            if (!roleUUIDs.Contains(roleUUID))
                            {
                                roleUUIDs.Add(roleUUID);
                            }
                        }
                        // No roles specified, so assume everyone role.
                        if (roleUUIDs.Count.Equals(0))
                        {
                            roleUUIDs.Add(UUID.Zero);
                        }
                        if (!roleUUIDs.All(o => o.Equals(UUID.Zero)) &&
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.AssignMember,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        Client.Groups.Invite(groupUUID, roleUUIDs.ToList(), agentUUID);
                    };
                    break;
                case ScriptKeys.REPLYTOGROUPINVITE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        uint action =
                            (uint) wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                    .ToLowerInvariant());
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                            Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ALREADY_IN_GROUP));
                        }
                        UUID sessionUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION)),
                                        message)),
                                out sessionUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_SESSION_SPECIFIED));
                        }
                        lock (GroupInviteLock)
                        {
                            if (!GroupInvites.AsParallel().Any(o => o.Session.Equals(sessionUUID)))
                            {
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_GROUP_INVITE_SESSION));
                            }
                        }
                        int amount;
                        lock (GroupInviteLock)
                        {
                            GroupInvite groupInvite =
                                GroupInvites.AsParallel().FirstOrDefault(o => o.Session.Equals(sessionUUID));
                            if (groupInvite.Equals(default(GroupInvite)))
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_GROUP_INVITE_SESSION));
                            amount = groupInvite.Fee;
                        }
                        if (!amount.Equals(0) && action.Equals((uint) Action.ACCEPT))
                        {
                            if (!HasCorradePermission(group, (int) Permissions.PERMISSION_ECONOMY))
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                            }
                            if (!UpdateBalance(Configuration.SERVICES_TIMEOUT))
                            {
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE));
                            }
                            if (Client.Self.Balance < amount)
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INSUFFICIENT_FUNDS));
                            }
                        }
                        Client.Self.GroupInviteRespond(groupUUID, sessionUUID,
                            action.Equals((uint) Action.ACCEPT));
                    };
                    break;
                case ScriptKeys.GETGROUPINVITES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> csv = new List<string>();
                        object LockObject = new object();
                        lock (GroupInviteLock)
                        {
                            Parallel.ForEach(GroupInvites, o =>
                            {
                                lock (LockObject)
                                {
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.FirstName), o.Agent.FirstName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.LastName), o.Agent.LastName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.UUID), o.Agent.UUID.ToString()});
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Group), o.Group});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o, o.Session), o.Session.ToString()});
                                    csv.AddRange(new[]
                                    {
                                        wasGetStructureMemberDescription(o, o.Fee),
                                        o.Fee.ToString(CultureInfo.InvariantCulture)
                                    });
                                }
                            });
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.EJECT:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.Eject,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT) ||
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.RemoveMember,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        if (
                            !AgentInGroup(agentUUID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        OpenMetaverse.Group commandGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(groupUUID, Configuration.SERVICES_TIMEOUT, ref commandGroup))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                        }
                        ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesMembersReplyEventArgs> GroupRoleMembersEventHandler = (sender, args) =>
                        {
                            if (args.RolesMembers.AsParallel().Any(
                                o => o.Key.Equals(commandGroup.OwnerRole) && o.Value.Equals(agentUUID)))
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.CANNOT_EJECT_OWNERS));
                            }
                            Parallel.ForEach(
                                args.RolesMembers.AsParallel().Where(
                                    o => o.Value.Equals(agentUUID)),
                                o => Client.Groups.RemoveFromRole(groupUUID, o.Key, agentUUID));
                            GroupRoleMembersReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleMembersReply += GroupRoleMembersEventHandler;
                            Client.Groups.RequestGroupRolesMembers(groupUUID);
                            if (!GroupRoleMembersReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupRoleMembersReply -= GroupRoleMembersEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_GROUP_ROLE_MEMBERS));
                            }
                            Client.Groups.GroupRoleMembersReply -= GroupRoleMembersEventHandler;
                        }
                        ManualResetEvent GroupEjectEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        EventHandler<GroupOperationEventArgs> GroupOperationEventHandler = (sender, args) =>
                        {
                            succeeded = args.Success;
                            GroupEjectEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupMemberEjected += GroupOperationEventHandler;
                            Client.Groups.EjectUser(groupUUID, agentUUID);
                            if (!GroupEjectEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupMemberEjected -= GroupOperationEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_EJECTING_AGENT));
                            }
                            Client.Groups.GroupMemberEjected -= GroupOperationEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_EJECT_AGENT));
                        }
                    };
                    break;
                case ScriptKeys.GETGROUPACCOUNTSUMMARYDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        int days;
                        if (
                            !int.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DAYS)), message)),
                                out days))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_DAYS));
                        }
                        int interval;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.INTERVAL)),
                                        message)),
                                out interval))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_INTERVAL));
                        }
                        ManualResetEvent RequestGroupAccountSummaryEvent = new ManualResetEvent(false);
                        GroupAccountSummary summary = new GroupAccountSummary();
                        EventHandler<GroupAccountSummaryReplyEventArgs> RequestGroupAccountSummaryEventHandler =
                            (sender, args) =>
                            {
                                summary = args.Summary;
                                RequestGroupAccountSummaryEvent.Set();
                            };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupAccountSummaryReply += RequestGroupAccountSummaryEventHandler;
                            Client.Groups.RequestGroupAccountSummary(groupUUID, days, interval);
                            if (!RequestGroupAccountSummaryEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupAccountSummaryReply -= RequestGroupAccountSummaryEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_GROUP_ACCOUNT_SUMMARY));
                            }
                            Client.Groups.GroupAccountSummaryReply -= RequestGroupAccountSummaryEventHandler;
                        }
                        List<string> data = new List<string>(GetStructuredData(summary,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message)))
                            );
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.UPDATEGROUPDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.ChangeIdentity,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        OpenMetaverse.Group commandGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(groupUUID, Configuration.SERVICES_TIMEOUT, ref commandGroup))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                        }
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message)),
                            ref commandGroup);
                        Client.Groups.UpdateGroup(groupUUID, commandGroup);
                    };
                    break;
                case ScriptKeys.LEAVE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        ManualResetEvent GroupLeaveReplyEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        EventHandler<GroupOperationEventArgs> GroupOperationEventHandler = (sender, args) =>
                        {
                            succeeded = args.Success;
                            GroupLeaveReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupLeaveReply += GroupOperationEventHandler;
                            Client.Groups.LeaveGroup(groupUUID);
                            if (!GroupLeaveReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupLeaveReply -= GroupOperationEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_LEAVING_GROUP));
                            }
                            Client.Groups.GroupLeaveReply -= GroupOperationEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_LEAVE_GROUP));
                        }
                    };
                    break;
                case ScriptKeys.CREATEROLE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.CreateRole,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        ManualResetEvent GroupRoleDataReplyEvent = new ManualResetEvent(false);
                        int roleCount = 0;
                        EventHandler<GroupRolesDataReplyEventArgs> GroupRolesDataEventHandler = (sender, args) =>
                        {
                            roleCount = args.Roles.Count;
                            GroupRoleDataReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleDataReply += GroupRolesDataEventHandler;
                            Client.Groups.RequestGroupRoles(groupUUID);
                            if (!GroupRoleDataReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupRoleDataReply -= GroupRolesDataEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_GROUP_ROLES));
                            }
                            Client.Groups.GroupRoleDataReply -= GroupRolesDataEventHandler;
                        }
                        if (roleCount >= LINDEN_CONSTANTS.GROUPS.MAXIMUM_NUMBER_OF_ROLES)
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.MAXIMUM_NUMBER_OF_ROLES_EXCEEDED));
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        if (string.IsNullOrEmpty(role))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_ROLE_NAME_SPECIFIED));
                        }
                        ulong powers = 0;
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POWERS)),
                                message))),
                            o =>
                                Parallel.ForEach(
                                    typeof (GroupPowers).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                    q => { powers |= ((ulong) q.GetValue(null)); }));
                        if (!HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.ChangeActions,
                            Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        Client.Groups.CreateRole(groupUUID, new GroupRole
                        {
                            Name = role,
                            Description =
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                        message)),
                            GroupID = groupUUID,
                            ID = UUID.Random(),
                            Powers = (GroupPowers) powers,
                            Title =
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TITLE)), message))
                        });
                        UUID roleUUID = UUID.Zero;
                        if (
                            !RoleNameToRoleUUID(role, groupUUID,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref roleUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_CREATE_ROLE));
                        }
                    };
                    break;
                case ScriptKeys.GETROLES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        ManualResetEvent GroupRoleDataReplyEvent = new ManualResetEvent(false);
                        List<string> csv = new List<string>();
                        EventHandler<GroupRolesDataReplyEventArgs> GroupRolesDataEventHandler = (sender, args) =>
                        {
                            csv.AddRange(args.Roles.AsParallel().Select(o => new[]
                            {
                                o.Value.Name,
                                o.Value.ID.ToString(),
                                o.Value.Title,
                                o.Value.Description
                            }).SelectMany(o => o));
                            GroupRoleDataReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleDataReply += GroupRolesDataEventHandler;
                            Client.Groups.RequestGroupRoles(groupUUID);
                            if (!GroupRoleDataReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupRoleDataReply -= GroupRolesDataEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_GROUP_ROLES));
                            }
                            Client.Groups.GroupRoleDataReply -= GroupRolesDataEventHandler;
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETMEMBERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        ManualResetEvent agentInGroupEvent = new ManualResetEvent(false);
                        List<string> csv = new List<string>();
                        EventHandler<GroupMembersReplyEventArgs> HandleGroupMembersReplyDelegate = (sender, args) =>
                        {
                            foreach (KeyValuePair<UUID, GroupMember> pair in args.Members)
                            {
                                string agentName = string.Empty;
                                if (
                                    !AgentUUIDToName(pair.Value.ID, Configuration.SERVICES_TIMEOUT, ref agentName))
                                    continue;
                                csv.Add(agentName);
                                csv.Add(pair.Key.ToString());
                            }
                            agentInGroupEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupMembersReply += HandleGroupMembersReplyDelegate;
                            Client.Groups.RequestGroupMembers(groupUUID);
                            if (!agentInGroupEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_GROUP_MEMBERS));
                            }
                            Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETMEMBERROLES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        if (
                            !AgentInGroup(agentUUID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_IN_GROUP));
                        }
                        HashSet<string> csv = new HashSet<string>();
                        // get roles for a member
                        ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesMembersReplyEventArgs> GroupRolesMembersEventHandler = (sender, args) =>
                        {
                            foreach (
                                KeyValuePair<UUID, UUID> pair in
                                    args.RolesMembers.AsParallel().Where(o => o.Value.Equals(agentUUID))
                                )
                            {
                                string roleName = string.Empty;
                                if (
                                    !RoleUUIDToName(pair.Key, groupUUID, Configuration.SERVICES_TIMEOUT,
                                        Configuration.DATA_TIMEOUT,
                                        ref roleName))
                                    continue;
                                csv.Add(roleName);
                            }
                            GroupRoleMembersReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleMembersReply += GroupRolesMembersEventHandler;
                            Client.Groups.RequestGroupRolesMembers(groupUUID);
                            if (!GroupRoleMembersReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETING_GROUP_ROLES_MEMBERS));
                            }
                            Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETROLEMEMBERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        if (string.IsNullOrEmpty(role))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_ROLE_NAME_SPECIFIED));
                        }
                        UUID roleUUID;
                        if (!UUID.TryParse(role, out roleUUID) && !RoleNameToRoleUUID(role, groupUUID,
                            Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                            ref roleUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ROLE_NOT_FOUND));
                        }
                        List<string> csv = new List<string>();
                        ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesMembersReplyEventArgs> GroupRolesMembersEventHandler =
                            (sender, args) =>
                            {
                                foreach (
                                    KeyValuePair<UUID, UUID> pair in
                                        args.RolesMembers.AsParallel().Where(o => o.Key.Equals(roleUUID)))
                                {
                                    string agentName = string.Empty;
                                    if (
                                        !AgentUUIDToName(pair.Value, Configuration.SERVICES_TIMEOUT, ref agentName))
                                        continue;
                                    csv.Add(agentName);
                                    csv.Add(pair.Value.ToString());
                                }
                                GroupRoleMembersReplyEvent.Set();
                            };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleMembersReply += GroupRolesMembersEventHandler;
                            Client.Groups.RequestGroupRolesMembers(groupUUID);
                            if (!GroupRoleMembersReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETING_GROUP_ROLES_MEMBERS));
                            }
                            Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETROLESMEMBERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        List<string> csv = new List<string>();
                        ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesMembersReplyEventArgs> GroupRolesMembersEventHandler =
                            (sender, args) =>
                            {
                                // First resolve the all the role names to role UUIDs
                                Hashtable roleUUIDNames = new Hashtable(args.RolesMembers.Count);
                                foreach (
                                    UUID roleUUID in
                                        args.RolesMembers.AsParallel().GroupBy(o => o.Key).Select(o => o.First().Key))
                                {
                                    string roleName = string.Empty;
                                    if (
                                        !RoleUUIDToName(roleUUID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                            Configuration.DATA_TIMEOUT,
                                            ref roleName))
                                        continue;
                                    roleUUIDNames.Add(roleUUID, roleName);
                                }
                                // Next, associate role names with agent names and UUIDs.
                                foreach (KeyValuePair<UUID, UUID> pair in args.RolesMembers)
                                {
                                    if (!roleUUIDNames.ContainsKey(pair.Key)) continue;
                                    string agentName = string.Empty;
                                    if (
                                        !AgentUUIDToName(pair.Value, Configuration.SERVICES_TIMEOUT, ref agentName))
                                        continue;
                                    csv.Add(roleUUIDNames[pair.Key] as string);
                                    csv.Add(agentName);
                                    csv.Add(pair.Value.ToString());
                                }
                                GroupRoleMembersReplyEvent.Set();
                            };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleMembersReply += GroupRolesMembersEventHandler;
                            Client.Groups.RequestGroupRolesMembers(groupUUID);
                            if (!GroupRoleMembersReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETING_GROUP_ROLES_MEMBERS));
                            }
                            Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETROLEPOWERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.RoleProperties,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        UUID roleUUID;
                        if (!UUID.TryParse(role, out roleUUID) && !RoleNameToRoleUUID(role, groupUUID,
                            Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                            ref roleUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ROLE_NOT_FOUND));
                        }
                        HashSet<string> csv = new HashSet<string>();
                        ManualResetEvent GroupRoleDataReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesDataReplyEventArgs> GroupRoleDataEventHandler = (sender, args) =>
                        {
                            GroupRole queryRole =
                                args.Roles.Values.AsParallel().FirstOrDefault(o => o.ID.Equals(roleUUID));
                            csv.UnionWith(typeof (GroupPowers).GetFields(BindingFlags.Public | BindingFlags.Static)
                                .AsParallel().Where(
                                    o =>
                                        !(((ulong) o.GetValue(null) &
                                           (ulong) queryRole.Powers)).Equals(0))
                                .Select(o => o.Name));
                            GroupRoleDataReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleDataReply += GroupRoleDataEventHandler;
                            Client.Groups.RequestGroupRoles(groupUUID);
                            if (!GroupRoleDataReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupRoleDataReply -= GroupRoleDataEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_ROLE_POWERS));
                            }
                            Client.Groups.GroupRoleDataReply -= GroupRoleDataEventHandler;
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.DELETEROLE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.DeleteRole,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT) ||
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.RemoveMember,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        UUID roleUUID;
                        if (!UUID.TryParse(role, out roleUUID) && !RoleNameToRoleUUID(role, groupUUID,
                            Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                            ref roleUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ROLE_NOT_FOUND));
                        }
                        if (roleUUID.Equals(UUID.Zero))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.CANNOT_DELETE_THE_EVERYONE_ROLE));
                        }
                        OpenMetaverse.Group commandGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(groupUUID, Configuration.SERVICES_TIMEOUT, ref commandGroup))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                        }
                        if (commandGroup.OwnerRole.Equals(roleUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.CANNOT_REMOVE_OWNER_ROLE));
                        }
                        // remove members from role
                        ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesMembersReplyEventArgs> GroupRolesMembersEventHandler = (sender, args) =>
                        {
                            Parallel.ForEach(args.RolesMembers.AsParallel().Where(o => o.Key.Equals(roleUUID)),
                                o => Client.Groups.RemoveFromRole(groupUUID, roleUUID, o.Value));
                            GroupRoleMembersReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleMembersReply += GroupRolesMembersEventHandler;
                            Client.Groups.RequestGroupRolesMembers(groupUUID);
                            if (!GroupRoleMembersReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_EJECTING_AGENT));
                            }
                            Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                        }
                        Client.Groups.DeleteRole(groupUUID, roleUUID);
                    };
                    break;
                case ScriptKeys.ADDTOROLE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.AssignMember,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        UUID roleUUID;
                        if (!UUID.TryParse(role, out roleUUID) && !RoleNameToRoleUUID(role, groupUUID,
                            Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                            ref roleUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ROLE_NOT_FOUND));
                        }
                        if (roleUUID.Equals(UUID.Zero))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(
                                    ScriptError.GROUP_MEMBERS_ARE_BY_DEFAULT_IN_THE_EVERYONE_ROLE));
                        }
                        Client.Groups.AddToRole(groupUUID, roleUUID, agentUUID);
                    };
                    break;
                case ScriptKeys.DELETEFROMROLE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.RemoveMember,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        UUID roleUUID;
                        if (!UUID.TryParse(role, out roleUUID) && !RoleNameToRoleUUID(role, groupUUID,
                            Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                            ref roleUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ROLE_NOT_FOUND));
                        }
                        if (roleUUID.Equals(UUID.Zero))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(
                                    ScriptError.CANNOT_DELETE_A_GROUP_MEMBER_FROM_THE_EVERYONE_ROLE));
                        }
                        OpenMetaverse.Group commandGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(groupUUID, Configuration.SERVICES_TIMEOUT, ref commandGroup))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                        }
                        if (commandGroup.OwnerRole.Equals(roleUUID))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.CANNOT_REMOVE_USER_FROM_OWNER_ROLE));
                        }
                        Client.Groups.RemoveFromRole(groupUUID, roleUUID,
                            agentUUID);
                    };
                    break;
                case ScriptKeys.TELL:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_TALK))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string data = wasInput(
                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE)),
                                message));
                        List<string> myName =
                            new List<string>(
                                GetAvatarNames(string.Join(" ", Client.Self.FirstName, Client.Self.LastName)));
                        switch (
                            wasGetEnumValueFromDescription<Entity>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                        message)).ToLowerInvariant()))
                        {
                            case Entity.AVATAR:
                                UUID agentUUID;
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out agentUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                                    ref agentUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                                }
                                Client.Self.InstantMessage(agentUUID, data);
                                // Log instant messages,
                                if (Configuration.INSTANT_MESSAGE_LOG_ENABLED)
                                {
                                    string agentName = "";
                                    if (!AgentUUIDToName(
                                        agentUUID,
                                        Configuration.SERVICES_TIMEOUT,
                                        ref agentName))
                                    {
                                        throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                                    }
                                    List<string> fullName =
                                        new List<string>(
                                            GetAvatarNames(agentName));
                                    try
                                    {
                                        lock (InstantMessageLogFileLock)
                                        {
                                            using (
                                                StreamWriter logWriter =
                                                    File.AppendText(
                                                        wasPathCombine(Configuration.INSTANT_MESSAGE_LOG_DIRECTORY,
                                                            string.Join(" ", fullName.First(), fullName.Last())) +
                                                        "." +
                                                        CORRADE_CONSTANTS.LOG_FILE_EXTENSION))
                                            {
                                                logWriter.WriteLine("[{0}] {1} {2} : {3}",
                                                    DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                        DateTimeFormatInfo.InvariantInfo), myName.First(), myName.Last(),
                                                    data);
                                                //logWriter.Flush();
                                                //logWriter.Close();
                                            }
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        // or fail and append the fail message.
                                        Feedback(
                                            wasGetDescriptionFromEnumValue(
                                                ConsoleError.COULD_NOT_WRITE_TO_INSTANT_MESSAGE_LOG_FILE),
                                            ex.Message);
                                    }
                                }
                                break;
                            case Entity.GROUP:
                                Group configuredGroup =
                                    Configuration.GROUPS.AsParallel().FirstOrDefault(
                                        o => o.Name.Equals(group, StringComparison.Ordinal));
                                UUID groupUUID = UUID.Zero;
                                switch (!configuredGroup.Equals(default(Group)))
                                {
                                    case true:
                                        groupUUID = configuredGroup.UUID;
                                        break;
                                    default:
                                        if (
                                            !GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT,
                                                Configuration.DATA_TIMEOUT,
                                                ref groupUUID))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                        }
                                        break;
                                }
                                if (
                                    !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                        Configuration.DATA_TIMEOUT))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                                }
                                if (!Client.Self.GroupChatSessions.ContainsKey(groupUUID))
                                {
                                    if (
                                        !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.JoinChat,
                                            Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                    }

                                    if (!JoinGroupChat(groupUUID, Configuration.SERVICES_TIMEOUT))
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_JOIN_GROUP_CHAT));
                                    }
                                }
                                Client.Self.InstantMessageGroup(groupUUID, data);
                                Parallel.ForEach(
                                    Configuration.GROUPS.AsParallel().Where(
                                        o => o.UUID.Equals(groupUUID) && o.ChatLogEnabled),
                                    o =>
                                    {
                                        // Attempt to write to log file,
                                        try
                                        {
                                            lock (GroupLogFileLock)
                                            {
                                                using (StreamWriter logWriter = File.AppendText(o.ChatLog))
                                                {
                                                    logWriter.WriteLine("[{0}] {1} {2} : {3}",
                                                        DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                            DateTimeFormatInfo.InvariantInfo), myName.First(),
                                                        myName.Last(),
                                                        data);
                                                    //logWriter.Flush();
                                                    //logWriter.Close();
                                                }
                                            }
                                        }
                                        catch (Exception ex)
                                        {
                                            // or fail and append the fail message.
                                            Feedback(
                                                wasGetDescriptionFromEnumValue(
                                                    ConsoleError.COULD_NOT_WRITE_TO_GROUP_CHAT_LOG_FILE),
                                                ex.Message);
                                        }
                                    });
                                break;
                            case Entity.LOCAL:
                                int chatChannel;
                                if (
                                    !int.TryParse(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.CHANNEL)),
                                                message)),
                                        out chatChannel))
                                {
                                    chatChannel = 0;
                                }
                                FieldInfo chatTypeInfo = typeof (ChatType).GetFields(BindingFlags.Public |
                                                                                     BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        o =>
                                            o.Name.Equals(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                        message)),
                                                StringComparison.Ordinal));
                                ChatType chatType = chatTypeInfo != null
                                    ? (ChatType)
                                        chatTypeInfo
                                            .GetValue(null)
                                    : ChatType.Normal;
                                Client.Self.Chat(
                                    data,
                                    chatChannel,
                                    chatType);
                                // Log local chat,
                                if (Configuration.LOCAL_MESSAGE_LOG_ENABLED)
                                {
                                    List<string> fullName =
                                        new List<string>(
                                            GetAvatarNames(string.Join(" ", Client.Self.FirstName, Client.Self.LastName)));
                                    try
                                    {
                                        lock (LocalLogFileLock)
                                        {
                                            using (
                                                StreamWriter logWriter =
                                                    File.AppendText(
                                                        wasPathCombine(Configuration.LOCAL_MESSAGE_LOG_DIRECTORY,
                                                            Client.Network.CurrentSim.Name) + "." +
                                                        CORRADE_CONSTANTS.LOG_FILE_EXTENSION))
                                            {
                                                logWriter.WriteLine("[{0}] {1} {2} ({3}) : {4}",
                                                    DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                        DateTimeFormatInfo.InvariantInfo), fullName.First(),
                                                    fullName.Last(), Enum.GetName(typeof (ChatType), chatType),
                                                    data);
                                                //logWriter.Flush();
                                                //logWriter.Close();
                                            }
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        // or fail and append the fail message.
                                        Feedback(
                                            wasGetDescriptionFromEnumValue(
                                                ConsoleError.COULD_NOT_WRITE_TO_LOCAL_MESSAGE_LOG_FILE),
                                            ex.Message);
                                    }
                                }
                                break;
                            case Entity.ESTATE:
                                Client.Estate.EstateMessage(data);
                                break;
                            case Entity.REGION:
                                Client.Estate.SimulatorMessage(data);
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                        }
                    };
                    break;
                case ScriptKeys.AI:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_TALK))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant()))
                        {
                            case Action.PROCESS:
                                string request =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE)),
                                            message));
                                if (string.IsNullOrEmpty(request))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_MESSAGE_PROVIDED));
                                }
                                if (AIMLBot.isAcceptingUserInput)
                                {
                                    lock (AIMLBotLock)
                                    {
                                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                            AIMLBot.Chat(new Request(request, AIMLBotUser, AIMLBot)).Output);
                                    }
                                }
                                break;
                            case Action.ENABLE:
                                lock (AIMLBotLock)
                                {
                                    switch (!AIMLBotBrainCompiled)
                                    {
                                        case true:
                                            new Thread(
                                                () =>
                                                {
                                                    lock (AIMLBotLock)
                                                    {
                                                        LoadChatBotFiles.Invoke();
                                                        AIMLBotConfigurationWatcher.EnableRaisingEvents = true;
                                                    }
                                                }) {IsBackground = true, Priority = ThreadPriority.BelowNormal}.Start();
                                            break;
                                        default:
                                            AIMLBotConfigurationWatcher.EnableRaisingEvents = true;
                                            AIMLBot.isAcceptingUserInput = true;
                                            break;
                                    }
                                }
                                break;
                            case Action.DISABLE:
                                lock (AIMLBotLock)
                                {
                                    AIMLBotConfigurationWatcher.EnableRaisingEvents = false;
                                    AIMLBot.isAcceptingUserInput = false;
                                }
                                break;
                            case Action.REBUILD:
                                lock (AIMLBotLock)
                                {
                                    AIMLBotConfigurationWatcher.EnableRaisingEvents = false;
                                    string AIMLBotBrain =
                                        wasPathCombine(
                                            Directory.GetCurrentDirectory(), AIML_BOT_CONSTANTS.DIRECTORY,
                                            AIML_BOT_CONSTANTS.BRAIN.DIRECTORY, AIML_BOT_CONSTANTS.BRAIN_FILE);
                                    if (File.Exists(AIMLBotBrain))
                                    {
                                        try
                                        {
                                            File.Delete(AIMLBotBrain);
                                        }
                                        catch (Exception)
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_REMOVE_BRAIN_FILE));
                                        }
                                    }
                                    LoadChatBotFiles.Invoke();
                                    AIMLBotConfigurationWatcher.EnableRaisingEvents = true;
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.NOTICE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.SendNotices,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        GroupNotice notice = new GroupNotice
                        {
                            Message =
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE)),
                                        message)),
                            Subject =
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SUBJECT)),
                                        message)),
                            OwnerID = Client.Self.AgentID
                        };
                        string item =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                message));
                        if (!string.IsNullOrEmpty(item) && !UUID.TryParse(item, out notice.AttachmentID))
                        {
                            InventoryBase inventoryBaseItem =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                    ).FirstOrDefault();
                            if (inventoryBaseItem == null)
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                            }
                            notice.AttachmentID = inventoryBaseItem.UUID;
                        }
                        Client.Groups.SendGroupNotice(groupUUID, notice);
                    };
                    break;
                case ScriptKeys.PAY:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group, (int) Permissions.PERMISSION_ECONOMY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        int amount;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AMOUNT)), message)),
                                out amount))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_PAY_AMOUNT));
                        }
                        if (amount.Equals(0))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_PAY_AMOUNT));
                        }
                        if (!UpdateBalance(Configuration.SERVICES_TIMEOUT))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE));
                        }
                        if (Client.Self.Balance < amount)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INSUFFICIENT_FUNDS));
                        }
                        UUID targetUUID = UUID.Zero;
                        switch (
                            wasGetEnumValueFromDescription<Entity>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                        message)).ToLowerInvariant()))
                        {
                            case Entity.GROUP:
                                Group configuredGroup =
                                    Configuration.GROUPS.AsParallel().FirstOrDefault(
                                        o => o.Name.Equals(group, StringComparison.Ordinal));
                                switch (!configuredGroup.Equals(default(Group)))
                                {
                                    case true:
                                        targetUUID = configuredGroup.UUID;
                                        break;
                                    default:
                                        if (
                                            !GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT,
                                                Configuration.DATA_TIMEOUT,
                                                ref targetUUID))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                        }
                                        break;
                                }
                                Client.Self.GiveGroupMoney(targetUUID, amount,
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REASON)),
                                            message)));
                                break;
                            case Entity.AVATAR:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out targetUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                                    ref targetUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                                }
                                Client.Self.GiveAvatarMoney(targetUUID, amount,
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REASON)),
                                            message)));
                                break;
                            case Entity.OBJECT:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)),
                                                message)),
                                        out targetUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_PAY_TARGET));
                                }
                                Client.Self.GiveObjectMoney(targetUUID, amount,
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REASON)),
                                            message)));
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                        }
                    };
                    break;
                case ScriptKeys.GETBALANCE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group, (int) Permissions.PERMISSION_ECONOMY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        if (!UpdateBalance(Configuration.SERVICES_TIMEOUT))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE));
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                            Client.Self.Balance.ToString(CultureInfo.InvariantCulture));
                    };
                    break;
                case ScriptKeys.TELEPORT:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        // We override the default teleport since region names are unique and case insensitive.
                        ulong regionHandle = 0;
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        if (string.IsNullOrEmpty(region))
                        {
                            region = Client.Network.CurrentSim.Name;
                        }
                        ManualResetEvent GridRegionEvent = new ManualResetEvent(false);
                        EventHandler<GridRegionEventArgs> GridRegionEventHandler =
                            (sender, args) =>
                            {
                                if (!args.Region.Name.Equals(region, StringComparison.InvariantCultureIgnoreCase))
                                    return;
                                regionHandle = args.Region.RegionHandle;
                                GridRegionEvent.Set();
                            };
                        lock (ClientInstanceGridLock)
                        {
                            Client.Grid.GridRegion += GridRegionEventHandler;
                            Client.Grid.RequestMapRegion(region, GridLayerType.Objects);
                            if (!GridRegionEvent.WaitOne(Client.Settings.MAP_REQUEST_TIMEOUT, false))
                            {
                                Client.Grid.GridRegion -= GridRegionEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_REGION));
                            }
                            Client.Grid.GridRegion -= GridRegionEventHandler;
                        }
                        if (regionHandle.Equals(0))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        if (regionHandle.Equals(Client.Network.CurrentSim.Handle) &&
                            Vector3.Distance(Client.Self.SimPosition, position) <
                            LINDEN_CONSTANTS.REGION.TELEPORT_MINIMUM_DISTANCE)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.DESTINATION_TOO_CLOSE));
                        }
                        ManualResetEvent TeleportEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        EventHandler<TeleportEventArgs> TeleportEventHandler = (sender, args) =>
                        {
                            switch (args.Status)
                            {
                                case TeleportStatus.Cancelled:
                                case TeleportStatus.Failed:
                                case TeleportStatus.Finished:
                                    succeeded = args.Status.Equals(TeleportStatus.Finished);
                                    TeleportEvent.Set();
                                    break;
                            }
                        };
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        lock (ClientInstanceSelfLock)
                        {
                            Client.Self.TeleportProgress += TeleportEventHandler;
                            Client.Self.Teleport(regionHandle, position);
                            if (!TeleportEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Self.TeleportProgress -= TeleportEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_DURING_TELEPORT));
                            }
                            Client.Self.TeleportProgress -= TeleportEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TELEPORT_FAILED));
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.LURE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        Client.Self.SendTeleportLure(agentUUID,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE)),
                                message)));
                    };
                    break;
                case ScriptKeys.SETHOME:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        bool succeeded = true;
                        ManualResetEvent AlertMessageEvent = new ManualResetEvent(false);
                        EventHandler<AlertMessageEventArgs> AlertMessageEventHandler = (sender, args) =>
                        {
                            switch (args.Message)
                            {
                                case LINDEN_CONSTANTS.ALERTS.UNABLE_TO_SET_HOME:
                                    succeeded = false;
                                    AlertMessageEvent.Set();
                                    break;
                                case LINDEN_CONSTANTS.ALERTS.HOME_SET:
                                    succeeded = true;
                                    AlertMessageEvent.Set();
                                    break;
                            }
                        };
                        lock (ClientInstanceSelfLock)
                        {
                            Client.Self.AlertMessage += AlertMessageEventHandler;
                            Client.Self.SetHome();
                            if (!AlertMessageEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Self.AlertMessage -= AlertMessageEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_REQUESTING_TO_SET_HOME));
                            }
                            Client.Self.AlertMessage -= AlertMessageEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_SET_HOME));
                        }
                    };
                    break;
                case ScriptKeys.GOHOME:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        bool succeeded = Client.Self.GoHome();
                        if (!succeeded)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_GO_HOME));
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.GETREGIONDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        List<string> data = new List<string>(GetStructuredData(simulator,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message)))
                            );
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETGRIDREGIONDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        if (string.IsNullOrEmpty(region))
                        {
                            region = Client.Network.CurrentSim.Name;
                        }
                        ManualResetEvent GridRegionEvent = new ManualResetEvent(false);
                        GridRegion gridRegion = new GridRegion();
                        EventHandler<GridRegionEventArgs> GridRegionEventHandler = (sender, args) =>
                        {
                            if (!args.Region.Name.Equals(region, StringComparison.InvariantCultureIgnoreCase))
                                return;
                            gridRegion = args.Region;
                            GridRegionEvent.Set();
                        };
                        lock (ClientInstanceGridLock)
                        {
                            Client.Grid.GridRegion += GridRegionEventHandler;
                            Client.Grid.RequestMapRegion(region, GridLayerType.Objects);
                            if (!GridRegionEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Grid.GridRegion -= GridRegionEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_REGION));
                            }
                            Client.Grid.GridRegion -= GridRegionEventHandler;
                        }
                        if (gridRegion.Equals(default(GridRegion)))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        List<string> data = new List<string>(GetStructuredData(gridRegion,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETNETWORKDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> data = new List<string>(GetStructuredData(Client.Network,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETCONNECTEDREGIONS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                            wasEnumerableToCSV(Client.Network.Simulators.Select(o => o.Name)));
                    };
                    break;
                case ScriptKeys.LISTCOMMANDS:
                    execute = () =>
                    {
                        HashSet<string> data = new HashSet<string>();
                        object LockObject = new object();
                        Parallel.ForEach(wasGetEnumDescriptions<ScriptKeys>(), o =>
                        {
                            ScriptKeys scriptKey = wasGetEnumValueFromDescription<ScriptKeys>(o);
                            IsCommandAttribute isCommandAttribute =
                                wasGetAttributeFromEnumValue<IsCommandAttribute>(scriptKey);
                            if (isCommandAttribute == null || !isCommandAttribute.IsCommand)
                                return;
                            CommandPermissionMaskAttribute commandPermissionMaskAttribute =
                                wasGetAttributeFromEnumValue<CommandPermissionMaskAttribute>(scriptKey);
                            if (commandPermissionMaskAttribute == null) return;
                            Group commandGroup =
                                Configuration.GROUPS.AsParallel()
                                    .FirstOrDefault(
                                        p => p.Name.Equals(group, StringComparison.InvariantCultureIgnoreCase));
                            if (commandGroup.Equals(default(Group)) ||
                                (commandGroup.PermissionMask & commandPermissionMaskAttribute.PermissionMask).Equals(0))
                                return;
                            lock (LockObject)
                            {
                                data.Add(o);
                            }
                        });
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETCOMMAND:
                    execute = () =>
                    {
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_NAME_PROVIDED));
                        }
                        IsCommandAttribute isCommandAttribute =
                            wasGetAttributeFromEnumValue<IsCommandAttribute>(
                                wasGetEnumValueFromDescription<ScriptKeys>(name));
                        if (isCommandAttribute == null || isCommandAttribute.IsCommand.Equals(false))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COMMAND_NOT_FOUND));
                        }
                        CommandPermissionMaskAttribute commandPermissionMaskAttribute =
                            wasGetAttributeFromEnumValue<CommandPermissionMaskAttribute>(
                                wasGetEnumValueFromDescription<ScriptKeys>(name));
                        if (commandPermissionMaskAttribute == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group commandGroup =
                            Configuration.GROUPS.AsParallel()
                                .FirstOrDefault(
                                    p => p.Name.Equals(group, StringComparison.InvariantCultureIgnoreCase));
                        if (commandGroup.Equals(default(Group)))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                        }
                        switch (
                            wasGetEnumValueFromDescription<Entity>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                        message)).ToLowerInvariant()))
                        {
                            case Entity.SYNTAX:
                                switch (
                                    wasGetEnumValueFromDescription<Type>(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                message)).ToLowerInvariant()))
                                {
                                    case Type.INPUT:
                                        CommandInputSyntaxAttribute commandInputSyntaxAttribute = wasGetAttributeFromEnumValue
                                            <CommandInputSyntaxAttribute>(
                                                wasGetEnumValueFromDescription<ScriptKeys>(name));
                                        if (commandInputSyntaxAttribute != null &&
                                            !string.IsNullOrEmpty(commandInputSyntaxAttribute.Syntax))
                                        {
                                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                                commandInputSyntaxAttribute.Syntax);
                                        }
                                        break;
                                    default:
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_SYNTAX_TYPE));
                                }
                                break;
                            case Entity.PERMISSION:
                                HashSet<string> data = new HashSet<string>();
                                object LockObject = new object();
                                Parallel.ForEach(wasGetEnumDescriptions<Permissions>(), o =>
                                {
                                    Permissions permission = wasGetEnumValueFromDescription<Permissions>(o);
                                    if ((commandPermissionMaskAttribute.PermissionMask & (uint) permission).Equals(0))
                                        return;
                                    lock (LockObject)
                                    {
                                        data.Add(o);
                                    }
                                });
                                if (!data.Count.Equals(0))
                                {
                                    result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), wasEnumerableToCSV(data));
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                        }
                    };
                    break;
                case ScriptKeys.SIT:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        ManualResetEvent SitEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        EventHandler<AvatarSitResponseEventArgs> AvatarSitEventHandler = (sender, args) =>
                        {
                            succeeded = !args.ObjectID.Equals(UUID.Zero);
                            SitEvent.Set();
                        };
                        EventHandler<AlertMessageEventArgs> AlertMessageEventHandler = (sender, args) =>
                        {
                            if (args.Message.Equals(LINDEN_CONSTANTS.ALERTS.NO_ROOM_TO_SIT_HERE))
                            {
                                succeeded = false;
                            }
                            SitEvent.Set();
                        };
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        lock (ClientInstanceSelfLock)
                        {
                            Client.Self.AvatarSitResponse += AvatarSitEventHandler;
                            Client.Self.AlertMessage += AlertMessageEventHandler;
                            Client.Self.RequestSit(primitive.ID, Vector3.Zero);
                            if (!SitEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Self.AvatarSitResponse -= AvatarSitEventHandler;
                                Client.Self.AlertMessage -= AlertMessageEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_REQUESTING_SIT));
                            }
                            Client.Self.AvatarSitResponse -= AvatarSitEventHandler;
                            Client.Self.AlertMessage -= AlertMessageEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_SIT));
                        }
                        Client.Self.Sit();
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.RELAX:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        Client.Self.SitOnGround();
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.AWAY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant()))
                        {
                            case Action.ENABLE:
                                Client.Self.AnimationStart(Animations.AWAY, true);
                                Client.Self.Movement.Away = true;
                                Client.Self.Movement.SendUpdate(true);
                                break;
                            case Action.DISABLE:
                                Client.Self.Movement.Away = false;
                                Client.Self.AnimationStop(Animations.AWAY, true);
                                Client.Self.Movement.SendUpdate(true);
                                break;
                            case Action.GET:
                                result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    Client.Self.Movement.Away.ToString());
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.BUSY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant()))
                        {
                            case Action.ENABLE:
                                Client.Self.AnimationStart(Animations.BUSY, true);
                                break;
                            case Action.DISABLE:
                                Client.Self.AnimationStop(Animations.BUSY, true);
                                break;
                            case Action.GET:
                                result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    Client.Self.SignaledAnimations.ContainsKey(Animations.BUSY).ToString());
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.TYPING:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant()))
                        {
                            case Action.ENABLE:
                                Client.Self.AnimationStart(Animations.TYPE, true);
                                break;
                            case Action.DISABLE:
                                Client.Self.AnimationStop(Animations.TYPE, true);
                                break;
                            case Action.GET:
                                result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    Client.Self.SignaledAnimations.ContainsKey(Animations.TYPE).ToString());
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.RUN:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Action action = wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.ENABLE:
                            case Action.DISABLE:
                                Client.Self.Movement.AlwaysRun = !action.Equals(Action.DISABLE);
                                Client.Self.Movement.SendUpdate(true);
                                break;
                            case Action.GET:
                                result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    Client.Self.Movement.AlwaysRun.ToString());
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.STAND:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.GETPARCELLIST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                        }
                        FieldInfo accessField = typeof (AccessList).GetFields(
                            BindingFlags.Public | BindingFlags.Static)
                            .AsParallel().FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                message)),
                                        StringComparison.Ordinal));
                        if (accessField == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACCESS_LIST_TYPE));
                        }
                        AccessList accessType = (AccessList) accessField.GetValue(null);
                        if (!simulator.IsEstateManager)
                        {
                            if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                            {
                                if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(groupUUID))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                }
                                switch (accessType)
                                {
                                    case AccessList.Access:
                                        if (
                                            !HasGroupPowers(Client.Self.AgentID, groupUUID,
                                                GroupPowers.LandManageAllowed, Configuration.SERVICES_TIMEOUT,
                                                Configuration.DATA_TIMEOUT))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                        }
                                        break;
                                    case AccessList.Ban:
                                        if (
                                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.LandManageBanned,
                                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                        }
                                        break;
                                    case AccessList.Both:
                                        if (
                                            !HasGroupPowers(Client.Self.AgentID, groupUUID,
                                                GroupPowers.LandManageAllowed, Configuration.SERVICES_TIMEOUT,
                                                Configuration.DATA_TIMEOUT))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                        }
                                        if (
                                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.LandManageBanned,
                                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                        }
                                        break;
                                }
                            }
                        }
                        List<string> csv = new List<string>();
                        ManualResetEvent ParcelAccessListEvent = new ManualResetEvent(false);
                        EventHandler<ParcelAccessListReplyEventArgs> ParcelAccessListHandler = (sender, args) =>
                        {
                            foreach (ParcelManager.ParcelAccessEntry parcelAccess in args.AccessList)
                            {
                                string agent = string.Empty;
                                if (
                                    !AgentUUIDToName(parcelAccess.AgentID, Configuration.SERVICES_TIMEOUT, ref agent))
                                    continue;
                                csv.Add(agent);
                                csv.Add(parcelAccess.AgentID.ToString());
                                csv.Add(parcelAccess.Flags.ToString());
                                csv.Add(parcelAccess.Time.ToString(CultureInfo.InvariantCulture));
                            }
                            ParcelAccessListEvent.Set();
                        };
                        lock (ClientInstanceParcelsLock)
                        {
                            Client.Parcels.ParcelAccessListReply += ParcelAccessListHandler;
                            Client.Parcels.RequestParcelAccessList(simulator, parcel.LocalID, accessType, 0);
                            if (!ParcelAccessListEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Parcels.ParcelAccessListReply -= ParcelAccessListHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PARCELS));
                            }
                            Client.Parcels.ParcelAccessListReply -= ParcelAccessListHandler;
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.PARCELRECLAIM:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                        }
                        if (!simulator.IsEstateManager)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_LAND_RIGHTS));
                        }
                        Client.Parcels.Reclaim(simulator, parcel.LocalID);
                    };
                    break;
                case ScriptKeys.PARCELRELEASE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                        }
                        if (!simulator.IsEstateManager)
                        {
                            if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                            {
                                if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(groupUUID))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                }
                                if (
                                    !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.LandRelease,
                                        Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                }
                            }
                        }
                        Client.Parcels.ReleaseParcel(simulator, parcel.LocalID);
                    };
                    break;
                case ScriptKeys.PARCELDEED:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                        }
                        if (!simulator.IsEstateManager)
                        {
                            if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                            {
                                if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(groupUUID))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                }
                            }
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.LandDeed,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        Client.Parcels.DeedToGroup(simulator, parcel.LocalID, groupUUID);
                    };
                    break;
                case ScriptKeys.PARCELBUY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                        }
                        bool forGroup;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FORGROUP)),
                                        message)),
                                out forGroup))
                        {
                            if (
                                !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.LandDeed,
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                            {
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                            }
                            forGroup = true;
                        }
                        bool removeContribution;
                        if (!bool.TryParse(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REMOVECONTRIBUTION)),
                                    message)),
                            out removeContribution))
                        {
                            removeContribution = true;
                        }
                        ManualResetEvent ParcelInfoEvent = new ManualResetEvent(false);
                        UUID parcelUUID = UUID.Zero;
                        EventHandler<ParcelInfoReplyEventArgs> ParcelInfoEventHandler = (sender, args) =>
                        {
                            parcelUUID = args.Parcel.ID;
                            ParcelInfoEvent.Set();
                        };
                        lock (ClientInstanceParcelsLock)
                        {
                            Client.Parcels.ParcelInfoReply += ParcelInfoEventHandler;
                            Client.Parcels.RequestParcelInfo(parcelUUID);
                            if (!ParcelInfoEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Parcels.ParcelInfoReply -= ParcelInfoEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PARCELS));
                            }
                            Client.Parcels.ParcelInfoReply -= ParcelInfoEventHandler;
                        }
                        bool forSale = false;
                        int handledEvents = 0;
                        int counter = 1;
                        ManualResetEvent DirLandReplyEvent = new ManualResetEvent(false);
                        EventHandler<DirLandReplyEventArgs> DirLandReplyEventArgs =
                            (sender, args) =>
                            {
                                handledEvents += args.DirParcels.Count;
                                Parallel.ForEach(args.DirParcels, o =>
                                {
                                    if (o.ID.Equals(parcelUUID))
                                    {
                                        forSale = o.ForSale;
                                        DirLandReplyEvent.Set();
                                    }
                                });
                                if (((handledEvents - counter)%
                                     LINDEN_CONSTANTS.DIRECTORY.LAND.SEARCH_RESULTS_COUNT).Equals(0))
                                {
                                    ++counter;
                                    Client.Directory.StartLandSearch(DirectoryManager.DirFindFlags.SortAsc,
                                        DirectoryManager.SearchTypeFlags.Any, int.MaxValue, int.MaxValue,
                                        handledEvents);
                                }
                                DirLandReplyEvent.Set();
                            };
                        lock (ClientInstanceDirectoryLock)
                        {
                            Client.Directory.DirLandReply += DirLandReplyEventArgs;
                            Client.Directory.StartLandSearch(DirectoryManager.DirFindFlags.SortAsc,
                                DirectoryManager.SearchTypeFlags.Any, int.MaxValue, int.MaxValue, handledEvents);
                            if (!DirLandReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Directory.DirLandReply -= DirLandReplyEventArgs;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PARCELS));
                            }
                            Client.Directory.DirLandReply -= DirLandReplyEventArgs;
                        }
                        if (!forSale)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PARCEL_NOT_FOR_SALE));
                        }
                        if (!UpdateBalance(Configuration.SERVICES_TIMEOUT))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE));
                        }
                        if (Client.Self.Balance < parcel.SalePrice)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INSUFFICIENT_FUNDS));
                        }
                        if (!parcel.SalePrice.Equals(0) &&
                            !HasCorradePermission(group, (int) Permissions.PERMISSION_ECONOMY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Client.Parcels.Buy(simulator, parcel.LocalID, forGroup, groupUUID,
                            removeContribution, parcel.Area, parcel.SalePrice);
                    };
                    break;
                case ScriptKeys.PARCELEJECT:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                        }
                        if (!simulator.IsEstateManager)
                        {
                            if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                            {
                                if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(groupUUID))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                }
                                if (!HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.LandEjectAndFreeze,
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                }
                            }
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        bool alsoban;
                        if (
                            !bool.TryParse(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.BAN)),
                                    message)),
                                out alsoban))
                        {
                            alsoban = false;
                        }
                        Client.Parcels.EjectUser(agentUUID, alsoban);
                    };
                    break;
                case ScriptKeys.PARCELFREEZE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                        }
                        if (!simulator.IsEstateManager)
                        {
                            if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                            {
                                if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(groupUUID))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                }
                                if (!HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.LandEjectAndFreeze,
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                }
                            }
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        bool freeze;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FREEZE)), message)),
                                out freeze))
                        {
                            freeze = false;
                        }
                        Client.Parcels.FreezeUser(agentUUID, freeze);
                    };
                    break;
                case ScriptKeys.SETPROFILEDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        ManualResetEvent[] AvatarProfileDataEvent =
                        {
                            new ManualResetEvent(false),
                            new ManualResetEvent(false)
                        };
                        Avatar.AvatarProperties properties = new Avatar.AvatarProperties();
                        Avatar.Interests interests = new Avatar.Interests();
                        EventHandler<AvatarPropertiesReplyEventArgs> AvatarPropertiesEventHandler = (sender, args) =>
                        {
                            properties = args.Properties;
                            AvatarProfileDataEvent[0].Set();
                        };
                        EventHandler<AvatarInterestsReplyEventArgs> AvatarInterestsEventHandler = (sender, args) =>
                        {
                            interests = args.Interests;
                            AvatarProfileDataEvent[1].Set();
                        };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarPropertiesReply += AvatarPropertiesEventHandler;
                            Client.Avatars.AvatarInterestsReply += AvatarInterestsEventHandler;
                            Client.Avatars.RequestAvatarProperties(Client.Self.AgentID);
                            if (
                                !WaitHandle.WaitAll(AvatarProfileDataEvent.Select(o => (WaitHandle) o).ToArray(),
                                    Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesEventHandler;
                                Client.Avatars.AvatarInterestsReply -= AvatarInterestsEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PROFILE));
                            }
                            Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesEventHandler;
                            Client.Avatars.AvatarInterestsReply -= AvatarInterestsEventHandler;
                        }
                        string fields =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message));
                        wasCSVToStructure(fields, ref properties);
                        wasCSVToStructure(fields, ref interests);
                        Client.Self.UpdateProfile(properties);
                        Client.Self.UpdateInterests(interests);
                    };
                    break;
                case ScriptKeys.GETPROFILEDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        wasAdaptiveAlarm ProfileDataReceivedAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
                        Avatar.AvatarProperties properties = new Avatar.AvatarProperties();
                        Avatar.Interests interests = new Avatar.Interests();
                        List<AvatarGroup> groups = new List<AvatarGroup>();
                        AvatarPicksReplyEventArgs picks = null;
                        AvatarClassifiedReplyEventArgs classifieds = null;
                        object LockObject = new object();
                        EventHandler<AvatarInterestsReplyEventArgs> AvatarInterestsReplyEventHandler = (sender, args) =>
                        {
                            ProfileDataReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                            interests = args.Interests;
                        };
                        EventHandler<AvatarPropertiesReplyEventArgs> AvatarPropertiesReplyEventHandler =
                            (sender, args) =>
                            {
                                ProfileDataReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                properties = args.Properties;
                            };
                        EventHandler<AvatarGroupsReplyEventArgs> AvatarGroupsReplyEventHandler = (sender, args) =>
                        {
                            ProfileDataReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                            lock (LockObject)
                            {
                                groups.AddRange(args.Groups);
                            }
                        };
                        EventHandler<AvatarPicksReplyEventArgs> AvatarPicksReplyEventHandler =
                            (sender, args) =>
                            {
                                ProfileDataReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                picks = args;
                            };
                        EventHandler<AvatarClassifiedReplyEventArgs> AvatarClassifiedReplyEventHandler =
                            (sender, args) =>
                            {
                                ProfileDataReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                classifieds = args;
                            };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarInterestsReply += AvatarInterestsReplyEventHandler;
                            Client.Avatars.AvatarPropertiesReply += AvatarPropertiesReplyEventHandler;
                            Client.Avatars.AvatarGroupsReply += AvatarGroupsReplyEventHandler;
                            Client.Avatars.AvatarPicksReply += AvatarPicksReplyEventHandler;
                            Client.Avatars.AvatarClassifiedReply += AvatarClassifiedReplyEventHandler;
                            Client.Avatars.RequestAvatarProperties(agentUUID);
                            Client.Avatars.RequestAvatarPicks(agentUUID);
                            Client.Avatars.RequestAvatarClassified(agentUUID);
                            if (!ProfileDataReceivedAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Avatars.AvatarInterestsReply -= AvatarInterestsReplyEventHandler;
                                Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesReplyEventHandler;
                                Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                                Client.Avatars.AvatarPicksReply -= AvatarPicksReplyEventHandler;
                                Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedReplyEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_AVATAR_DATA));
                            }
                            Client.Avatars.AvatarInterestsReply -= AvatarInterestsReplyEventHandler;
                            Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesReplyEventHandler;
                            Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                            Client.Avatars.AvatarPicksReply -= AvatarPicksReplyEventHandler;
                            Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedReplyEventHandler;
                        }
                        string fields =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message));
                        List<string> csv = new List<string>();
                        csv.AddRange(GetStructuredData(properties, fields));
                        csv.AddRange(GetStructuredData(interests, fields));
                        csv.AddRange(GetStructuredData(groups, fields));
                        if (picks != null)
                        {
                            csv.AddRange(GetStructuredData(picks, fields));
                        }
                        if (classifieds != null)
                        {
                            csv.AddRange(GetStructuredData(classifieds, fields));
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GIVE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        InventoryBase item =
                            FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))
                                ).FirstOrDefault();
                        if (item == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                        }
                        switch (
                            wasGetEnumValueFromDescription<Entity>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                        message)).ToLowerInvariant()))
                        {
                            case Entity.AVATAR:
                                UUID agentUUID;
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out agentUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                                    ref agentUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                                }
                                InventoryItem inventoryItem = item as InventoryItem;
                                if (inventoryItem != null)
                                {
                                    Client.Inventory.GiveItem(item.UUID, item.Name,
                                        inventoryItem.AssetType, agentUUID, true);
                                }
                                break;
                            case Entity.OBJECT:
                                float range;
                                if (
                                    !float.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)),
                                                message)),
                                        out range))
                                {
                                    range = Configuration.RANGE;
                                }
                                Primitive primitive = null;
                                if (
                                    !FindPrimitive(
                                        StringOrUUID(wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)),
                                                message))),
                                        range,
                                        ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                                }
                                Client.Inventory.UpdateTaskInventory(primitive.LocalID,
                                    item as InventoryItem);
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                        }
                    };
                    break;
                case ScriptKeys.DELETEITEM:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        HashSet<InventoryItem> items =
                            new HashSet<InventoryItem>(FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))
                                ).Cast<InventoryItem>());
                        if (items.Count.Equals(0))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                        }
                        Parallel.ForEach(items, o =>
                        {
                            switch (o.AssetType)
                            {
                                case AssetType.Folder:
                                    Client.Inventory.MoveFolder(o.UUID,
                                        Client.Inventory.FindFolderForType(AssetType.TrashFolder));
                                    break;
                                default:
                                    Client.Inventory.MoveItem(o.UUID,
                                        Client.Inventory.FindFolderForType(AssetType.TrashFolder));
                                    break;
                            }
                        });
                    };
                    break;
                case ScriptKeys.EMPTYTRASH:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Client.Inventory.EmptyTrash();
                    };
                    break;
                case ScriptKeys.FLY:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Action action =
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                    .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.START:
                            case Action.STOP:
                                if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                                {
                                    Client.Self.Stand();
                                }
                                // stop all non-built-in animations
                                List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                                    BindingFlags.Public |
                                    BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                                Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                                {
                                    if (!lindenAnimations.Contains(o))
                                        Client.Self.AnimationStop(o, true);
                                });
                                Client.Self.Fly(action.Equals(Action.START));
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.FLY_ACTION_START_OR_STOP));
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.ADDPICK:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string item =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                message));
                        UUID textureUUID = UUID.Zero;
                        if (!string.IsNullOrEmpty(item) && !UUID.TryParse(item, out textureUUID))
                        {
                            InventoryBase inventoryBaseItem =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                    ).FirstOrDefault();
                            if (inventoryBaseItem == null)
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TEXTURE_NOT_FOUND));
                            }
                            textureUUID = inventoryBaseItem.UUID;
                        }
                        ManualResetEvent AvatarPicksReplyEvent = new ManualResetEvent(false);
                        UUID pickUUID = UUID.Zero;
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EMPTY_PICK_NAME));
                        }
                        EventHandler<AvatarPicksReplyEventArgs> AvatarPicksEventHandler = (sender, args) =>
                        {
                            KeyValuePair<UUID, string> pick =
                                args.Picks.AsParallel()
                                    .FirstOrDefault(o => o.Value.Equals(name, StringComparison.Ordinal));
                            if (!pick.Equals(default(KeyValuePair<UUID, string>)))
                                pickUUID = pick.Key;
                            AvatarPicksReplyEvent.Set();
                        };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarPicksReply += AvatarPicksEventHandler;
                            Client.Avatars.RequestAvatarPicks(Client.Self.AgentID);
                            if (!AvatarPicksReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Avatars.AvatarPicksReply -= AvatarPicksEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PICKS));
                            }
                            Client.Avatars.AvatarPicksReply -= AvatarPicksEventHandler;
                        }
                        if (pickUUID.Equals(UUID.Zero))
                        {
                            pickUUID = UUID.Random();
                        }
                        Client.Self.PickInfoUpdate(pickUUID, false, UUID.Zero, name,
                            Client.Self.GlobalPosition, textureUUID,
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                    message)));
                    };
                    break;
                case ScriptKeys.DELETEPICK:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        ManualResetEvent AvatarPicksReplyEvent = new ManualResetEvent(false);
                        string input =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(input))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EMPTY_PICK_NAME));
                        }
                        UUID pickUUID = UUID.Zero;
                        EventHandler<AvatarPicksReplyEventArgs> AvatarPicksEventHandler = (sender, args) =>
                        {
                            KeyValuePair<UUID, string> pick = args.Picks.AsParallel().FirstOrDefault(
                                o => o.Value.Equals(input, StringComparison.Ordinal));
                            if (!pick.Equals(default(KeyValuePair<UUID, string>)))
                                pickUUID = pick.Key;
                            AvatarPicksReplyEvent.Set();
                        };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarPicksReply += AvatarPicksEventHandler;
                            Client.Avatars.RequestAvatarPicks(Client.Self.AgentID);
                            if (!AvatarPicksReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Avatars.AvatarPicksReply -= AvatarPicksEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PICKS));
                            }
                            Client.Avatars.AvatarPicksReply -= AvatarPicksEventHandler;
                        }
                        if (pickUUID.Equals(UUID.Zero))
                        {
                            pickUUID = UUID.Random();
                        }
                        Client.Self.PickDelete(pickUUID);
                    };
                    break;
                case ScriptKeys.ADDCLASSIFIED:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING) ||
                            !HasCorradePermission(group, (int) Permissions.PERMISSION_ECONOMY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string item =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                message));
                        UUID textureUUID = UUID.Zero;
                        if (!string.IsNullOrEmpty(item) && !UUID.TryParse(item, out textureUUID))
                        {
                            InventoryBase inventoryBaseItem =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                    ).FirstOrDefault();
                            if (inventoryBaseItem == null)
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TEXTURE_NOT_FOUND));
                            }
                            textureUUID = inventoryBaseItem.UUID;
                        }
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EMPTY_CLASSIFIED_NAME));
                        }
                        string classifiedDescription =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                    message));
                        ManualResetEvent AvatarClassifiedReplyEvent = new ManualResetEvent(false);
                        UUID classifiedUUID = UUID.Zero;
                        EventHandler<AvatarClassifiedReplyEventArgs> AvatarClassifiedEventHandler = (sender, args) =>
                        {
                            KeyValuePair<UUID, string> classified = args.Classifieds.AsParallel().FirstOrDefault(
                                o =>
                                    o.Value.Equals(name, StringComparison.Ordinal));
                            if (!classified.Equals(default(KeyValuePair<UUID, string>)))
                                classifiedUUID = classified.Key;
                            AvatarClassifiedReplyEvent.Set();
                        };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarClassifiedReply += AvatarClassifiedEventHandler;
                            Client.Avatars.RequestAvatarClassified(Client.Self.AgentID);
                            if (!AvatarClassifiedReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_CLASSIFIEDS));
                            }
                            Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedEventHandler;
                        }
                        if (classifiedUUID.Equals(UUID.Zero))
                        {
                            classifiedUUID = UUID.Random();
                        }
                        int price;
                        if (
                            !int.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PRICE)), message)),
                                out price))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_PRICE));
                        }
                        if (price < 0)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_PRICE));
                        }
                        bool renew;
                        if (
                            !bool.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RENEW)), message)),
                                out renew))
                        {
                            renew = false;
                        }
                        FieldInfo classifiedCategoriesField = typeof (DirectoryManager.ClassifiedCategories).GetFields(
                            BindingFlags.Public |
                            BindingFlags.Static)
                            .AsParallel().FirstOrDefault(o =>
                                o.Name.Equals(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                            message)),
                                    StringComparison.Ordinal));
                        Client.Self.UpdateClassifiedInfo(classifiedUUID, classifiedCategoriesField != null
                            ? (DirectoryManager.ClassifiedCategories)
                                classifiedCategoriesField.GetValue(null)
                            : DirectoryManager.ClassifiedCategories.Any, textureUUID, price,
                            name, classifiedDescription, renew);
                    };
                    break;
                case ScriptKeys.DELETECLASSIFIED:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EMPTY_CLASSIFIED_NAME));
                        }
                        ManualResetEvent AvatarClassifiedReplyEvent = new ManualResetEvent(false);
                        UUID classifiedUUID = UUID.Zero;
                        EventHandler<AvatarClassifiedReplyEventArgs> AvatarClassifiedEventHandler = (sender, args) =>
                        {
                            KeyValuePair<UUID, string> classified = args.Classifieds.AsParallel().FirstOrDefault(
                                o =>
                                    o.Value.Equals(name, StringComparison.Ordinal));
                            if (!classified.Equals(default(KeyValuePair<UUID, string>)))
                                classifiedUUID = classified.Key;
                            AvatarClassifiedReplyEvent.Set();
                        };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarClassifiedReply += AvatarClassifiedEventHandler;
                            Client.Avatars.RequestAvatarClassified(Client.Self.AgentID);
                            if (!AvatarClassifiedReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_CLASSIFIEDS));
                            }
                            Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedEventHandler;
                        }
                        if (classifiedUUID.Equals(UUID.Zero))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_CLASSIFIED));
                        }
                        Client.Self.DeleteClassfied(classifiedUUID);
                    };
                    break;
                case ScriptKeys.TOUCH:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        Client.Self.Touch(primitive.LocalID);
                    };
                    break;
                case ScriptKeys.MODERATE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.ModerateChat,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        if (
                            !AgentInGroup(agentUUID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_IN_GROUP));
                        }
                        bool silence;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SILENCE)),
                                        message)),
                                out silence))
                        {
                            silence = false;
                        }
                        Type type =
                            wasGetEnumValueFromDescription<Type>(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)), message))
                                    .ToLowerInvariant());
                        switch (type)
                        {
                            case Type.TEXT:
                            case Type.VOICE:
                                Client.Self.ModerateChatSessions(groupUUID, agentUUID,
                                    wasGetDescriptionFromEnumValue(type),
                                    silence);
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TYPE_CAN_BE_VOICE_OR_TEXT));
                        }
                    };
                    break;
                case ScriptKeys.REBAKE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        RebakeTimer.Change(Configuration.REBAKE_DELAY, 0);
                    };
                    break;
                case ScriptKeys.GETWEARABLES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        HashSet<string> data =
                            new HashSet<string>(GetWearables(Client.Inventory.Store.RootNode)
                                .AsParallel()
                                .Select(o => new[]
                                {
                                    o.Value.ToString(),
                                    Client.Inventory.Store[o.Key.ItemID].Name
                                }).SelectMany(o => o));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.WEAR:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string wearables =
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.WEARABLES)), message));
                        if (string.IsNullOrEmpty(wearables))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EMPTY_WEARABLES));
                        }
                        bool replace;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REPLACE)),
                                        message)),
                                out replace))
                        {
                            replace = true;
                        }
                        Parallel.ForEach(wasCSVToEnumerable(
                            wearables), o =>
                            {
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, o
                                        ).AsParallel().FirstOrDefault(p => p is InventoryWearable);
                                if (inventoryBaseItem == null)
                                    return;
                                Wear(inventoryBaseItem as InventoryItem, replace);
                            });
                        RebakeTimer.Change(Configuration.REBAKE_DELAY, 0);
                    };
                    break;
                case ScriptKeys.UNWEAR:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string wearables =
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.WEARABLES)), message));
                        if (string.IsNullOrEmpty(wearables))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EMPTY_WEARABLES));
                        }
                        Parallel.ForEach(wasCSVToEnumerable(
                            wearables), o =>
                            {
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, o
                                        ).AsParallel().FirstOrDefault(p => p is InventoryWearable);
                                if (inventoryBaseItem == null)
                                    return;
                                UnWear(inventoryBaseItem as InventoryItem);
                            });
                        RebakeTimer.Change(Configuration.REBAKE_DELAY, 0);
                    };
                    break;
                case ScriptKeys.GETATTACHMENTS:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> attachments = GetAttachments(
                            Configuration.SERVICES_TIMEOUT).AsParallel().Select(o => new[]
                            {
                                o.Value.ToString(),
                                o.Key.Properties.Name
                            }).SelectMany(o => o).ToList();
                        if (!attachments.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(attachments));
                        }
                    };
                    break;
                case ScriptKeys.ATTACH:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string attachments =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ATTACHMENTS)),
                                    message));
                        if (string.IsNullOrEmpty(attachments))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EMPTY_ATTACHMENTS));
                        }
                        bool replace;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REPLACE)),
                                        message)),
                                out replace))
                        {
                            replace = true;
                        }
                        Parallel.ForEach(
                            wasCSVToEnumerable(attachments).AsParallel().Select((o, p) => new {o, p})
                                .GroupBy(q => q.p/2, q => q.o)
                                .Select(o => o.ToList())
                                .TakeWhile(o => o.Count%2 == 0)
                                .ToDictionary(o => o.First(), p => p.Last()),
                            o =>
                                Parallel.ForEach(
                                    typeof (AttachmentPoint).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(
                                            p =>
                                                p.Name.Equals(o.Key, StringComparison.Ordinal)),
                                    q =>
                                    {
                                        InventoryBase inventoryBaseItem =
                                            FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, o.Value
                                                )
                                                .AsParallel().FirstOrDefault(
                                                    r => r is InventoryObject || r is InventoryAttachment);
                                        if (inventoryBaseItem == null)
                                            return;
                                        Attach(inventoryBaseItem as InventoryItem, (AttachmentPoint) q.GetValue(null),
                                            replace);
                                    }));
                        RebakeTimer.Change(Configuration.REBAKE_DELAY, 0);
                    };
                    break;
                case ScriptKeys.DETACH:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string attachments =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ATTACHMENTS)),
                                    message));
                        if (string.IsNullOrEmpty(attachments))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EMPTY_ATTACHMENTS));
                        }
                        Parallel.ForEach(wasCSVToEnumerable(
                            attachments), o =>
                            {
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, o
                                        )
                                        .AsParallel().FirstOrDefault(
                                            p =>
                                                p is InventoryObject || p is InventoryAttachment);
                                if (inventoryBaseItem == null)
                                    return;
                                Detach(inventoryBaseItem as InventoryItem);
                            });
                        RebakeTimer.Change(Configuration.REBAKE_DELAY, 0);
                    };
                    break;
                case ScriptKeys.RETURNPRIMITIVES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        string type =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                message));
                        switch (
                            wasGetEnumValueFromDescription<Entity>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                        message)).ToLowerInvariant()))
                        {
                            case Entity.PARCEL:
                                Vector3 position;
                                HashSet<Parcel> parcels = new HashSet<Parcel>();
                                switch (Vector3.TryParse(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                            message)),
                                    out position))
                                {
                                    case false:
                                        // Get all sim parcels
                                        ManualResetEvent SimParcelsDownloadedEvent = new ManualResetEvent(false);
                                        EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedEventHandler =
                                            (sender, args) => SimParcelsDownloadedEvent.Set();
                                        lock (ClientInstanceParcelsLock)
                                        {
                                            Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedEventHandler;
                                            Client.Parcels.RequestAllSimParcels(simulator);
                                            if (simulator.IsParcelMapFull())
                                            {
                                                SimParcelsDownloadedEvent.Set();
                                            }
                                            if (
                                                !SimParcelsDownloadedEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                            {
                                                Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                                throw new Exception(
                                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PARCELS));
                                            }
                                            Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                        }
                                        simulator.Parcels.ForEach(o => parcels.Add(o));
                                        break;
                                    case true:
                                        Parcel parcel = null;
                                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                                        }
                                        parcels.Add(parcel);
                                        break;
                                }
                                FieldInfo objectReturnTypeField = typeof (ObjectReturnType).GetFields(
                                    BindingFlags.Public |
                                    BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        o =>
                                            o.Name.Equals(type
                                                .ToLowerInvariant(),
                                                StringComparison.Ordinal));
                                ObjectReturnType returnType = objectReturnTypeField != null
                                    ? (ObjectReturnType)
                                        objectReturnTypeField
                                            .GetValue(null)
                                    : ObjectReturnType.Other;
                                if (!simulator.IsEstateManager)
                                {
                                    Parallel.ForEach(
                                        parcels.AsParallel().Where(o => !o.OwnerID.Equals(Client.Self.AgentID)), o =>
                                        {
                                            if (!o.IsGroupOwned || !o.GroupID.Equals(groupUUID))
                                            {
                                                throw new Exception(
                                                    wasGetDescriptionFromEnumValue(
                                                        ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                            }
                                            GroupPowers power = new GroupPowers();
                                            switch (returnType)
                                            {
                                                case ObjectReturnType.Other:
                                                    power = GroupPowers.ReturnNonGroup;
                                                    break;
                                                case ObjectReturnType.Group:
                                                    power = GroupPowers.ReturnGroupSet;
                                                    break;
                                                case ObjectReturnType.Owner:
                                                    power = GroupPowers.ReturnGroupOwned;
                                                    break;
                                            }
                                            if (!HasGroupPowers(Client.Self.AgentID, groupUUID, power,
                                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                                            {
                                                throw new Exception(
                                                    wasGetDescriptionFromEnumValue(
                                                        ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                            }
                                        });
                                }
                                Parallel.ForEach(parcels,
                                    o =>
                                        Client.Parcels.ReturnObjects(simulator, o.LocalID,
                                            returnType
                                            , new List<UUID> {agentUUID}));

                                break;
                            case Entity.ESTATE:
                                if (!simulator.IsEstateManager)
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_LAND_RIGHTS));
                                }
                                bool allEstates;
                                if (
                                    !bool.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ALL)),
                                                message)),
                                        out allEstates))
                                {
                                    allEstates = false;
                                }
                                FieldInfo estateReturnFlagsField = typeof (EstateTools.EstateReturnFlags).GetFields(
                                    BindingFlags.Public | BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        o =>
                                            o.Name.Equals(type,
                                                StringComparison.Ordinal));
                                Client.Estate.SimWideReturn(agentUUID, estateReturnFlagsField != null
                                    ? (EstateTools.EstateReturnFlags)
                                        estateReturnFlagsField
                                            .GetValue(null)
                                    : EstateTools.EstateReturnFlags.ReturnScriptedAndOnOthers, allEstates);
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEOWNERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Vector3 position;
                        HashSet<Parcel> parcels = new HashSet<Parcel>();
                        switch (Vector3.TryParse(
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)), message)),
                            out position))
                        {
                            case true:
                                Parcel parcel = null;
                                if (!GetParcelAtPosition(simulator, position, ref parcel))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                                }
                                parcels.Add(parcel);
                                break;
                            default:
                                // Get all sim parcels
                                ManualResetEvent SimParcelsDownloadedEvent = new ManualResetEvent(false);
                                EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedEventHandler =
                                    (sender, args) => SimParcelsDownloadedEvent.Set();
                                lock (ClientInstanceParcelsLock)
                                {
                                    Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedEventHandler;
                                    Client.Parcels.RequestAllSimParcels(simulator);
                                    if (simulator.IsParcelMapFull())
                                    {
                                        SimParcelsDownloadedEvent.Set();
                                    }
                                    if (!SimParcelsDownloadedEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PARCELS));
                                    }
                                    Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                }
                                simulator.Parcels.ForEach(o => parcels.Add(o));
                                break;
                        }
                        Parallel.ForEach(parcels.AsParallel().Where(o => !o.OwnerID.Equals(Client.Self.AgentID)),
                            o =>
                            {
                                if (!o.IsGroupOwned || !o.GroupID.Equals(groupUUID))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                }
                                bool permissions = false;
                                Parallel.ForEach(
                                    new HashSet<GroupPowers>
                                    {
                                        GroupPowers.ReturnGroupSet,
                                        GroupPowers.ReturnGroupOwned,
                                        GroupPowers.ReturnNonGroup
                                    }, p =>
                                    {
                                        if (HasGroupPowers(Client.Self.AgentID, groupUUID, p,
                                            Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                                        {
                                            permissions = true;
                                        }
                                    });
                                if (!permissions)
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                }
                            });
                        ManualResetEvent ParcelObjectOwnersReplyEvent = new ManualResetEvent(false);
                        Dictionary<string, int> primitives = new Dictionary<string, int>();
                        EventHandler<ParcelObjectOwnersReplyEventArgs> ParcelObjectOwnersEventHandler =
                            (sender, args) =>
                            {
                                //object LockObject = new object();
                                foreach (ParcelManager.ParcelPrimOwners primowner in args.PrimOwners)
                                {
                                    string owner = string.Empty;
                                    if (
                                        !AgentUUIDToName(primowner.OwnerID, Configuration.SERVICES_TIMEOUT, ref owner))
                                        continue;
                                    if (!primitives.ContainsKey(owner))
                                    {
                                        primitives.Add(owner, primowner.Count);
                                        continue;
                                    }
                                    primitives[owner] += primowner.Count;
                                }
                                ParcelObjectOwnersReplyEvent.Set();
                            };
                        foreach (Parcel parcel in parcels)
                        {
                            lock (ClientInstanceParcelsLock)
                            {
                                Client.Parcels.ParcelObjectOwnersReply += ParcelObjectOwnersEventHandler;
                                Client.Parcels.RequestObjectOwners(simulator, parcel.LocalID);
                                if (!ParcelObjectOwnersReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                {
                                    Client.Parcels.ParcelObjectOwnersReply -= ParcelObjectOwnersEventHandler;
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_LAND_USERS));
                                }
                                Client.Parcels.ParcelObjectOwnersReply -= ParcelObjectOwnersEventHandler;
                            }
                        }
                        if (primitives.Count.Equals(0))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_GET_LAND_USERS));
                        }
                        List<string> data = new List<string>(primitives.AsParallel().Select(
                            p => wasEnumerableToCSV(new[] {p.Key, p.Value.ToString(CultureInfo.InvariantCulture)})));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETGROUPDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        OpenMetaverse.Group dataGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(groupUUID, Configuration.SERVICES_TIMEOUT, ref dataGroup))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                        }
                        List<string> data = new List<string>(GetStructuredData(dataGroup,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        List<string> data = new List<string>(GetStructuredData(primitive,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPARCELDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                        }
                        List<string> data = new List<string>(GetStructuredData(parcel,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.SETPARCELDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                        }
                        if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                        {
                            if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(groupUUID))
                            {
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                            }
                        }
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message)), ref parcel);
                        parcel.Update(simulator, true);
                    };
                    break;
                case ScriptKeys.GETREGIONPARCELSBOUNDINGBOX:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        // Get all sim parcels
                        ManualResetEvent SimParcelsDownloadedEvent = new ManualResetEvent(false);
                        EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedEventHandler =
                            (sender, args) => SimParcelsDownloadedEvent.Set();
                        lock (ClientInstanceParcelsLock)
                        {
                            Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedEventHandler;
                            Client.Parcels.RequestAllSimParcels(simulator);
                            if (simulator.IsParcelMapFull())
                            {
                                SimParcelsDownloadedEvent.Set();
                            }
                            if (!SimParcelsDownloadedEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PARCELS));
                            }
                            Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                        }
                        List<Vector3> csv = new List<Vector3>();
                        simulator.Parcels.ForEach(o => csv.AddRange(new[] {o.AABBMin, o.AABBMax}));
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv.Select(o => o.ToString())));
                        }
                    };
                    break;
                case ScriptKeys.DOWNLOAD:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string item =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                message));
                        if (string.IsNullOrEmpty(item))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_ITEM_SPECIFIED));
                        }
                        UUID itemUUID;
                        InventoryItem inventoryItem = null;
                        if (!UUID.TryParse(item, out itemUUID))
                        {
                            InventoryBase inventoryBase =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                    ).FirstOrDefault();
                            if (inventoryBase == null)
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                            }
                            inventoryItem = inventoryBase as InventoryItem;
                            if (inventoryItem == null)
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                            }
                            itemUUID = inventoryItem.AssetUUID;
                        }
                        byte[] assetData = null;
                        switch (!Client.Assets.Cache.HasAsset(itemUUID))
                        {
                            case true:
                                FieldInfo assetTypeInfo = typeof (AssetType).GetFields(BindingFlags.Public |
                                                                                       BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        o =>
                                            o.Name.Equals(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                        message)),
                                                StringComparison.Ordinal));
                                if (assetTypeInfo == null)
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ASSET_TYPE));
                                }
                                AssetType assetType = (AssetType) assetTypeInfo.GetValue(null);
                                ManualResetEvent RequestAssetEvent = new ManualResetEvent(false);
                                bool succeeded = false;
                                switch (assetType)
                                {
                                    case AssetType.Mesh:
                                        Client.Assets.RequestMesh(itemUUID, delegate(bool completed, AssetMesh asset)
                                        {
                                            if (!asset.AssetID.Equals(itemUUID)) return;
                                            succeeded = completed;
                                            if (succeeded)
                                            {
                                                assetData = asset.MeshData.AsBinary();
                                            }
                                            RequestAssetEvent.Set();
                                        });
                                        if (!RequestAssetEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_TRANSFERRING_ASSET));
                                        }
                                        break;
                                    // All of these can only be fetched if they exist locally.
                                    case AssetType.LSLText:
                                    case AssetType.Notecard:
                                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INVENTORY))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                                        }
                                        Client.Assets.RequestInventoryAsset(inventoryItem, true,
                                            delegate(AssetDownload transfer, Asset asset)
                                            {
                                                succeeded = transfer.Success;
                                                if (transfer.Success)
                                                {
                                                    assetData = asset.AssetData;
                                                }
                                                RequestAssetEvent.Set();
                                            });
                                        if (!RequestAssetEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_TRANSFERRING_ASSET));
                                        }
                                        break;
                                    // All images go through RequestImage and can be fetched directly from the asset server.
                                    case AssetType.Texture:
                                        Client.Assets.RequestImage(itemUUID, ImageType.Normal,
                                            delegate(TextureRequestState state, AssetTexture asset)
                                            {
                                                if (!asset.AssetID.Equals(itemUUID)) return;
                                                if (!state.Equals(TextureRequestState.Finished)) return;
                                                assetData = asset.AssetData;
                                                succeeded = true;
                                                RequestAssetEvent.Set();
                                            });
                                        if (!RequestAssetEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_TRANSFERRING_ASSET));
                                        }
                                        // Convert to desired format if specified.
                                        string format =
                                            wasInput(wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FORMAT)),
                                                message));
                                        if (!string.IsNullOrEmpty(format))
                                        {
                                            PropertyInfo formatProperty = typeof (ImageFormat).GetProperties(
                                                BindingFlags.Public |
                                                BindingFlags.Static)
                                                .AsParallel().FirstOrDefault(
                                                    o =>
                                                        string.Equals(o.Name, format, StringComparison.Ordinal));
                                            if (formatProperty == null)
                                            {
                                                throw new Exception(
                                                    wasGetDescriptionFromEnumValue(
                                                        ScriptError.UNKNOWN_IMAGE_FORMAT_REQUESTED));
                                            }
                                            ManagedImage managedImage;
                                            if (!OpenJPEG.DecodeToImage(assetData, out managedImage))
                                            {
                                                throw new Exception(
                                                    wasGetDescriptionFromEnumValue(
                                                        ScriptError.UNABLE_TO_DECODE_ASSET_DATA));
                                            }
                                            using (MemoryStream imageStream = new MemoryStream())
                                            {
                                                try
                                                {
                                                    using (Bitmap bitmapImage = managedImage.ExportBitmap())
                                                    {
                                                        EncoderParameters encoderParameters = new EncoderParameters(1);
                                                        encoderParameters.Param[0] =
                                                            new EncoderParameter(Encoder.Quality, 100L);
                                                        bitmapImage.Save(imageStream,
                                                            ImageCodecInfo.GetImageDecoders()
                                                                .AsParallel()
                                                                .FirstOrDefault(
                                                                    o =>
                                                                        o.FormatID.Equals(
                                                                            ((ImageFormat)
                                                                                formatProperty.GetValue(
                                                                                    new ImageFormat(Guid.Empty))).Guid)),
                                                            encoderParameters);
                                                    }
                                                }
                                                catch (Exception)
                                                {
                                                    throw new Exception(
                                                        wasGetDescriptionFromEnumValue(
                                                            ScriptError.UNABLE_TO_CONVERT_TO_REQUESTED_FORMAT));
                                                }
                                                assetData = imageStream.ToArray();
                                            }
                                        }
                                        break;
                                    // All of these can be fetched directly from the asset server.
                                    case AssetType.Landmark:
                                    case AssetType.Gesture:
                                    case AssetType.Animation: // Animatn
                                    case AssetType.Sound: // Ogg Vorbis
                                    case AssetType.Clothing:
                                    case AssetType.Bodypart:
                                        Client.Assets.RequestAsset(itemUUID, assetType, true,
                                            delegate(AssetDownload transfer, Asset asset)
                                            {
                                                if (!transfer.AssetID.Equals(itemUUID)) return;
                                                succeeded = transfer.Success;
                                                if (transfer.Success)
                                                {
                                                    assetData = asset.AssetData;
                                                }
                                                RequestAssetEvent.Set();
                                            });
                                        if (!RequestAssetEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_TRANSFERRING_ASSET));
                                        }
                                        break;
                                    default:
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ASSET_TYPE));
                                }
                                if (!succeeded)
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.FAILED_TO_DOWNLOAD_ASSET));
                                }
                                Client.Assets.Cache.SaveAssetToCache(itemUUID, assetData);
                                break;
                            default:
                                assetData = Client.Assets.Cache.GetCachedAssetBytes(itemUUID);
                                break;
                        }
                        // If no path was specificed, then send the data.
                        string path =
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATH)),
                                message));
                        if (string.IsNullOrEmpty(path))
                        {
                            result.Add(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                Convert.ToBase64String(assetData));
                            return;
                        }
                        if (
                            !HasCorradePermission(group, (int) Permissions.PERMISSION_SYSTEM))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        // Otherwise, save it to the specified file.
                        using (FileStream fs = File.Open(path, FileMode.Create))
                        {
                            using (BinaryWriter bw = new BinaryWriter(fs))
                            {
                                bw.Write(assetData);
                                bw.Flush();
                            }
                            fs.Flush();
                        }
                    };
                    break;
                case ScriptKeys.UPLOAD:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_NAME_PROVIDED));
                        }
                        uint permissions = 0;
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PERMISSIONS)),
                                    message))),
                            o =>
                                Parallel.ForEach(
                                    typeof (PermissionMask).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                    q => { permissions |= ((uint) q.GetValue(null)); }));
                        FieldInfo assetTypeInfo = typeof (AssetType).GetFields(BindingFlags.Public |
                                                                               BindingFlags.Static)
                            .AsParallel().FirstOrDefault(o =>
                                o.Name.Equals(
                                    wasInput(
                                        wasKeyValueGet(
                                            wasGetDescriptionFromEnumValue(
                                                ScriptKeys.TYPE),
                                            message)),
                                    StringComparison.Ordinal));
                        if (assetTypeInfo == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ASSET_TYPE));
                        }
                        AssetType assetType = (AssetType) assetTypeInfo.GetValue(null);
                        byte[] data;
                        try
                        {
                            data = Convert.FromBase64String(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                    message)));
                        }
                        catch (Exception)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_ASSET_DATA));
                        }
                        bool succeeded = false;
                        switch (assetType)
                        {
                            case AssetType.Texture:
                            case AssetType.Sound:
                            case AssetType.Animation:
                                // the holy asset trinity is charged money
                                if (!HasCorradePermission(group, (int) Permissions.PERMISSION_ECONOMY))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                                }
                                if (!UpdateBalance(Configuration.SERVICES_TIMEOUT))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE));
                                }
                                if (Client.Self.Balance < Client.Settings.UPLOAD_COST)
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INSUFFICIENT_FUNDS));
                                }
                                switch (assetType)
                                {
                                    case AssetType.Texture:
                                        // If the user did not send a JPEG-2000 Codestream, attempt to convert the data
                                        // and then encode to JPEG-2000 Codestream since that is what Second Life expects.
                                        ManagedImage managedImage;
                                        if (!OpenJPEG.DecodeToImage(data, out managedImage))
                                        {
                                            try
                                            {
                                                using (Image image = (Image) (new ImageConverter().ConvertFrom(data)))
                                                {
                                                    using (Bitmap bitmap = new Bitmap(image))
                                                    {
                                                        data = OpenJPEG.EncodeFromImage(bitmap, true);
                                                    }
                                                }
                                            }
                                            catch (Exception)
                                            {
                                                throw new Exception(
                                                    wasGetDescriptionFromEnumValue(
                                                        ScriptError.UNKNOWN_IMAGE_FORMAT_PROVIDED));
                                            }
                                        }
                                        break;
                                }
                                // now create and upload the asset
                                ManualResetEvent CreateItemFromAssetEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestCreateItemFromAsset(data, name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    (InventoryType)
                                        (typeof (InventoryType).GetFields(BindingFlags.Public | BindingFlags.Static)
                                            .AsParallel().FirstOrDefault(
                                                o => o.Name.Equals(Enum.GetName(typeof (AssetType), assetType),
                                                    StringComparison.Ordinal))).GetValue(null),
                                    Client.Inventory.FindFolderForType(assetType),
                                    delegate(bool completed, string status, UUID itemID, UUID assetID)
                                    {
                                        succeeded = completed;
                                        CreateItemFromAssetEvent.Set();
                                    });
                                if (!CreateItemFromAssetEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_UPLOADING_ASSET));
                                }
                                break;
                            case AssetType.Bodypart:
                            case AssetType.Clothing:
                                FieldInfo wearTypeInfo = typeof (MuteType).GetFields(BindingFlags.Public |
                                                                                     BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        o =>
                                            o.Name.Equals(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.WEAR)),
                                                        message)),
                                                StringComparison.Ordinal));
                                if (wearTypeInfo == null)
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_WEARABLE_TYPE));
                                }
                                UUID wearableUUID = Client.Assets.RequestUpload(assetType, data, false);
                                if (wearableUUID.Equals(UUID.Zero))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ASSET_UPLOAD_FAILED));
                                }
                                ManualResetEvent CreateWearableEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(assetType),
                                    name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    wearableUUID, InventoryType.Wearable, (WearableType) wearTypeInfo.GetValue(null),
                                    permissions == 0 ? PermissionMask.Transfer : (PermissionMask) permissions,
                                    delegate(bool completed, InventoryItem createdItem)
                                    {
                                        succeeded = completed;
                                        CreateWearableEvent.Set();
                                    });
                                if (!CreateWearableEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_CREATING_ITEM));
                                }
                                break;
                            case AssetType.Landmark:
                                UUID landmarkUUID = Client.Assets.RequestUpload(assetType, data, false);
                                if (landmarkUUID.Equals(UUID.Zero))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ASSET_UPLOAD_FAILED));
                                }
                                ManualResetEvent CreateLandmarkEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(assetType),
                                    name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    landmarkUUID, InventoryType.Landmark, PermissionMask.All,
                                    delegate(bool completed, InventoryItem createdItem)
                                    {
                                        succeeded = completed;
                                        CreateLandmarkEvent.Set();
                                    });
                                if (!CreateLandmarkEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_CREATING_ITEM));
                                }
                                break;
                            case AssetType.Gesture:
                                ManualResetEvent CreateGestureEvent = new ManualResetEvent(false);
                                InventoryItem newGesture = null;
                                Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(assetType),
                                    name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    UUID.Random(), InventoryType.Gesture,
                                    permissions == 0 ? PermissionMask.Transfer : (PermissionMask) permissions,
                                    delegate(bool completed, InventoryItem createdItem)
                                    {
                                        succeeded = completed;
                                        newGesture = createdItem;
                                        CreateGestureEvent.Set();
                                    });
                                if (!CreateGestureEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_CREATING_ITEM));
                                }
                                if (!succeeded)
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_CREATE_ITEM));
                                }
                                ManualResetEvent UploadGestureAssetEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestUploadGestureAsset(data, newGesture.UUID,
                                    delegate(bool completed, string status, UUID itemUUID, UUID assetUUID)
                                    {
                                        succeeded = completed;
                                        UploadGestureAssetEvent.Set();
                                    });
                                if (!UploadGestureAssetEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_UPLOADING_ASSET));
                                }
                                break;
                            case AssetType.Notecard:
                                ManualResetEvent CreateNotecardEvent = new ManualResetEvent(false);
                                InventoryItem newNotecard = null;
                                Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(assetType),
                                    name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    UUID.Random(), InventoryType.Notecard,
                                    permissions == 0 ? PermissionMask.Transfer : (PermissionMask) permissions,
                                    delegate(bool completed, InventoryItem createdItem)
                                    {
                                        succeeded = completed;
                                        newNotecard = createdItem;
                                        CreateNotecardEvent.Set();
                                    });
                                if (!CreateNotecardEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_CREATING_ITEM));
                                }
                                if (!succeeded)
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_CREATE_ITEM));
                                }
                                ManualResetEvent UploadNotecardAssetEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestUploadNotecardAsset(data, newNotecard.UUID,
                                    delegate(bool completed, string status, UUID itemUUID, UUID assetUUID)
                                    {
                                        succeeded = completed;
                                        UploadNotecardAssetEvent.Set();
                                    });
                                if (!UploadNotecardAssetEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_UPLOADING_ASSET));
                                }
                                break;
                            case AssetType.LSLText:
                                ManualResetEvent CreateScriptEvent = new ManualResetEvent(false);
                                InventoryItem newScript = null;
                                Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(assetType),
                                    name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    UUID.Random(), InventoryType.LSL,
                                    permissions == 0 ? PermissionMask.Transfer : (PermissionMask) permissions,
                                    delegate(bool completed, InventoryItem createdItem)
                                    {
                                        succeeded = completed;
                                        newScript = createdItem;
                                        CreateScriptEvent.Set();
                                    });
                                if (!CreateScriptEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_CREATING_ITEM));
                                }
                                ManualResetEvent UpdateScriptEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestUpdateScriptAgentInventory(data, newScript.UUID, true,
                                    delegate(bool completed, string status, bool compiled, List<string> messages,
                                        UUID itemID, UUID assetID)
                                    {
                                        succeeded = completed;
                                        UpdateScriptEvent.Set();
                                    });
                                if (!UpdateScriptEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_UPLOADING_ASSET));
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_INVENTORY_TYPE));
                        }
                        if (!succeeded)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ASSET_UPLOAD_FAILED));
                        }
                    };
                    break;
                case ScriptKeys.REZ:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        InventoryBase inventoryBaseItem =
                            FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))
                                ).FirstOrDefault();
                        if (inventoryBaseItem == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_POSITION));
                        }
                        Quaternion rotation;
                        if (
                            !Quaternion.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION)),
                                        message)),
                                out rotation))
                        {
                            rotation = Quaternion.CreateFromEulers(0, 0, 0);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                        }
                        if (((uint) parcel.Flags & (uint) ParcelFlags.CreateObjects).Equals(0))
                        {
                            if (!simulator.IsEstateManager)
                            {
                                if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                                {
                                    if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(groupUUID))
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                    }
                                    if (!HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.AllowRez,
                                        Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                    }
                                }
                            }
                        }
                        Client.Inventory.RequestRezFromInventory(simulator, rotation, position,
                            inventoryBaseItem as InventoryItem,
                            groupUUID);
                    };
                    break;
                case ScriptKeys.DEREZ:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        UUID folderUUID;
                        string folder =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FOLDER)),
                                message));
                        if (string.IsNullOrEmpty(folder) || !UUID.TryParse(folder, out folderUUID))
                        {
                            folderUUID =
                                Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(AssetType.Object)].Data
                                    .UUID;
                        }
                        if (folderUUID.Equals(UUID.Zero))
                        {
                            InventoryBase inventoryBaseItem =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, folder
                                    ).FirstOrDefault();
                            if (inventoryBaseItem != null)
                            {
                                InventoryItem item = inventoryBaseItem as InventoryItem;
                                if (item == null || !item.AssetType.Equals(AssetType.Folder))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.FOLDER_NOT_FOUND));
                                }
                                folderUUID = inventoryBaseItem.UUID;
                            }
                        }
                        FieldInfo deRezDestionationTypeInfo = typeof (DeRezDestination).GetFields(BindingFlags.Public |
                                                                                                  BindingFlags.Static)
                            .AsParallel().FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                message)),
                                        StringComparison.Ordinal));
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        Client.Inventory.RequestDeRezToInventory(primitive.LocalID, deRezDestionationTypeInfo != null
                            ? (DeRezDestination)
                                deRezDestionationTypeInfo
                                    .GetValue(null)
                            : DeRezDestination.AgentInventoryTake, folderUUID, UUID.Random());
                    };
                    break;
                case ScriptKeys.SETSCRIPTRUNNING:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        string entity =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                message));
                        UUID entityUUID;
                        if (!UUID.TryParse(entity, out entityUUID))
                        {
                            if (string.IsNullOrEmpty(entity))
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                            }
                            entityUUID = UUID.Zero;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        List<InventoryBase> inventory =
                            Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                Configuration.SERVICES_TIMEOUT).ToList();
                        InventoryItem item = !entityUUID.Equals(UUID.Zero)
                            ? inventory.AsParallel().FirstOrDefault(o => o.UUID.Equals(entityUUID)) as InventoryItem
                            : inventory.AsParallel().FirstOrDefault(o => o.Name.Equals(entity)) as InventoryItem;
                        if (item == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                        }
                        switch (item.AssetType)
                        {
                            case AssetType.LSLBytecode:
                            case AssetType.LSLText:
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_A_SCRIPT));
                        }
                        Action action =
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                    .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.START:
                            case Action.STOP:
                                Client.Inventory.RequestSetScriptRunning(primitive.ID, item.UUID,
                                    action.Equals(Action.START));
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                        ManualResetEvent ScriptRunningReplyEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        EventHandler<ScriptRunningReplyEventArgs> ScriptRunningEventHandler = (sender, args) =>
                        {
                            switch (action)
                            {
                                case Action.START:
                                    succeeded = args.IsRunning;
                                    break;
                                case Action.STOP:
                                    succeeded = !args.IsRunning;
                                    break;
                            }
                            ScriptRunningReplyEvent.Set();
                        };
                        lock (ClientInstanceInventoryLock)
                        {
                            Client.Inventory.ScriptRunningReply += ScriptRunningEventHandler;
                            Client.Inventory.RequestGetScriptRunning(primitive.ID, item.UUID);
                            if (!ScriptRunningReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Inventory.ScriptRunningReply -= ScriptRunningEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_SCRIPT_STATE));
                            }
                            Client.Inventory.ScriptRunningReply -= ScriptRunningEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_SET_SCRIPT_STATE));
                        }
                    };
                    break;
                case ScriptKeys.GETSCRIPTRUNNING:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        string entity =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                message));
                        UUID entityUUID;
                        if (!UUID.TryParse(entity, out entityUUID))
                        {
                            if (string.IsNullOrEmpty(entity))
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                            }
                            entityUUID = UUID.Zero;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        List<InventoryBase> inventory =
                            Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                Configuration.SERVICES_TIMEOUT).ToList();
                        InventoryItem item = !entityUUID.Equals(UUID.Zero)
                            ? inventory.AsParallel().FirstOrDefault(o => o.UUID.Equals(entityUUID)) as InventoryItem
                            : inventory.AsParallel().FirstOrDefault(o => o.Name.Equals(entity)) as InventoryItem;
                        if (item == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                        }
                        switch (item.AssetType)
                        {
                            case AssetType.LSLBytecode:
                            case AssetType.LSLText:
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_A_SCRIPT));
                        }
                        ManualResetEvent ScriptRunningReplyEvent = new ManualResetEvent(false);
                        bool running = false;
                        EventHandler<ScriptRunningReplyEventArgs> ScriptRunningEventHandler = (sender, args) =>
                        {
                            running = args.IsRunning;
                            ScriptRunningReplyEvent.Set();
                        };
                        lock (ClientInstanceInventoryLock)
                        {
                            Client.Inventory.ScriptRunningReply += ScriptRunningEventHandler;
                            Client.Inventory.RequestGetScriptRunning(primitive.ID, item.UUID);
                            if (!ScriptRunningReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Inventory.ScriptRunningReply -= ScriptRunningEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_SCRIPT_STATE));
                            }
                            Client.Inventory.ScriptRunningReply -= ScriptRunningEventHandler;
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), running.ToString());
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEINVENTORY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        List<string> data =
                            new List<string>(Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                Configuration.SERVICES_TIMEOUT).AsParallel().Select(o => new[]
                                {
                                    o.Name,
                                    o.UUID.ToString()
                                }).SelectMany(o => o));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEINVENTORYDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        string entity =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                message));
                        UUID entityUUID;
                        if (!UUID.TryParse(entity, out entityUUID))
                        {
                            if (string.IsNullOrEmpty(entity))
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                            }
                            entityUUID = UUID.Zero;
                        }
                        List<InventoryBase> inventory =
                            Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                Configuration.SERVICES_TIMEOUT).ToList();
                        InventoryItem item = !entityUUID.Equals(UUID.Zero)
                            ? inventory.AsParallel().FirstOrDefault(o => o.UUID.Equals(entityUUID)) as InventoryItem
                            : inventory.AsParallel().FirstOrDefault(o => o.Name.Equals(entity)) as InventoryItem;
                        if (item == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                        }
                        List<string> data = new List<string>(GetStructuredData(item,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.UPDATEPRIMITIVEINVENTORY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        string entity =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                message));
                        UUID entityUUID;
                        if (!UUID.TryParse(entity, out entityUUID))
                        {
                            if (string.IsNullOrEmpty(entity))
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                            }
                            entityUUID = UUID.Zero;
                        }
                        InventoryBase inventoryBaseItem;
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.ADD:
                                inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                        !entityUUID.Equals(UUID.Zero) ? entityUUID.ToString() : entity
                                        ).FirstOrDefault();
                                if (inventoryBaseItem == null)
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                                }
                                Client.Inventory.UpdateTaskInventory(primitive.LocalID,
                                    inventoryBaseItem as InventoryItem);
                                break;
                            case Action.REMOVE:
                                if (entityUUID.Equals(UUID.Zero))
                                {
                                    inventoryBaseItem = Client.Inventory.GetTaskInventory(primitive.ID,
                                        primitive.LocalID,
                                        Configuration.SERVICES_TIMEOUT)
                                        .AsParallel()
                                        .FirstOrDefault(o => o.Name.Equals(entity));
                                    if (inventoryBaseItem == null)
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                                    }
                                    entityUUID = inventoryBaseItem.UUID;
                                }
                                Client.Inventory.RemoveTaskInventory(primitive.LocalID, entityUUID,
                                    Client.Network.Simulators.FirstOrDefault(
                                        o => o.Handle.Equals(primitive.RegionHandle)));
                                break;
                            case Action.TAKE:
                                inventoryBaseItem = !entityUUID.Equals(UUID.Zero)
                                    ? Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                        Configuration.SERVICES_TIMEOUT)
                                        .AsParallel()
                                        .FirstOrDefault(o => o.UUID.Equals(entityUUID))
                                    : Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                        Configuration.SERVICES_TIMEOUT)
                                        .AsParallel()
                                        .FirstOrDefault(o => o.Name.Equals(entity));
                                InventoryItem inventoryItem = inventoryBaseItem as InventoryItem;
                                if (inventoryItem == null)
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                                }
                                UUID folderUUID;
                                string folder =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FOLDER)),
                                            message));
                                if (string.IsNullOrEmpty(folder) || !UUID.TryParse(folder, out folderUUID))
                                {
                                    folderUUID =
                                        Client.Inventory.Store.Items[
                                            Client.Inventory.FindFolderForType(inventoryItem.AssetType)].Data
                                            .UUID;
                                }
                                Client.Inventory.MoveTaskInventory(primitive.LocalID, inventoryItem.UUID, folderUUID,
                                    Client.Network.Simulators.FirstOrDefault(
                                        o => o.Handle.Equals(primitive.RegionHandle)));
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.GETINVENTORYDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        InventoryBase inventoryBaseItem =
                            FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))
                                ).FirstOrDefault();
                        if (inventoryBaseItem == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                        }
                        List<string> data = new List<string>(GetStructuredData(inventoryBaseItem as InventoryItem,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.SEARCHINVENTORY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        HashSet<AssetType> assetTypes = new HashSet<AssetType>();
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                message))),
                            o => Parallel.ForEach(
                                typeof (AssetType).GetFields(BindingFlags.Public | BindingFlags.Static)
                                    .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                q => assetTypes.Add((AssetType) q.GetValue(null))));
                        string pattern =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATTERN)),
                                message));
                        if (string.IsNullOrEmpty(pattern))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_PATTERN_PROVIDED));
                        }
                        Regex search;
                        try
                        {
                            search = new Regex(pattern, RegexOptions.Compiled);
                        }
                        catch
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_COMPILE_REGULAR_EXPRESSION));
                        }
                        List<string> csv = new List<string>();
                        object LockObject = new object();
                        Parallel.ForEach(FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, search
                            ),
                            o =>
                            {
                                InventoryItem inventoryItem = o as InventoryItem;
                                if (inventoryItem == null) return;
                                if (!assetTypes.Count.Equals(0) && !assetTypes.Contains(inventoryItem.AssetType))
                                    return;
                                lock (LockObject)
                                {
                                    csv.Add(Enum.GetName(typeof (AssetType), inventoryItem.AssetType));
                                    csv.Add(inventoryItem.Name);
                                    csv.Add(inventoryItem.AssetUUID.ToString());
                                }
                            });
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETINVENTORYPATH:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        HashSet<AssetType> assetTypes = new HashSet<AssetType>();
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                message))),
                            o => Parallel.ForEach(
                                typeof (AssetType).GetFields(BindingFlags.Public | BindingFlags.Static)
                                    .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                q => assetTypes.Add((AssetType) q.GetValue(null))));
                        string pattern =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATTERN)),
                                message));
                        if (string.IsNullOrEmpty(pattern))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_PATTERN_PROVIDED));
                        }
                        Regex search;
                        try
                        {
                            search = new Regex(pattern, RegexOptions.Compiled);
                        }
                        catch
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_COMPILE_REGULAR_EXPRESSION));
                        }
                        List<string> csv = new List<string>();
                        Parallel.ForEach(FindInventoryPath<InventoryBase>(Client.Inventory.Store.RootNode,
                            search, new LinkedList<string>()).AsParallel().Select(o => o.Value),
                            o => csv.Add(string.Join(CORRADE_CONSTANTS.PATH_SEPARATOR, o.ToArray())));
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETPARTICLESYSTEM:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        StringBuilder particleSystem = new StringBuilder();
                        particleSystem.Append("PSYS_PART_FLAGS, 0");
                        if (!((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.InterpColor).Equals(0))
                            particleSystem.Append(" | PSYS_PART_INTERP_COLOR_MASK");
                        if (!((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.InterpScale).Equals(0))
                            particleSystem.Append(" | PSYS_PART_INTERP_SCALE_MASK");
                        if (
                            !((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.Bounce).Equals(0))
                            particleSystem.Append(" | PSYS_PART_BOUNCE_MASK");
                        if (
                            !((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.Wind).Equals(0))
                            particleSystem.Append(" | PSYS_PART_WIND_MASK");
                        if (
                            !((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.FollowSrc).Equals(0))
                            particleSystem.Append(" | PSYS_PART_FOLLOW_SRC_MASK");
                        if (!((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.FollowVelocity).Equals(0))
                            particleSystem.Append(" | PSYS_PART_FOLLOW_VELOCITY_MASK");
                        if (
                            !((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.TargetPos).Equals(0))
                            particleSystem.Append(" | PSYS_PART_TARGET_POS_MASK");
                        if (!((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.TargetLinear).Equals(0))
                            particleSystem.Append(" | PSYS_PART_TARGET_LINEAR_MASK");
                        if (
                            !((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.Emissive).Equals(0))
                            particleSystem.Append(" | PSYS_PART_EMISSIVE_MASK");
                        particleSystem.Append(",");
                        particleSystem.Append("PSYS_SRC_PATTERN, 0");
                        if (
                            !((long) primitive.ParticleSys.Pattern & (long) Primitive.ParticleSystem.SourcePattern.Drop)
                                .Equals(0))
                            particleSystem.Append(" | PSYS_SRC_PATTERN_DROP");
                        if (!((long) primitive.ParticleSys.Pattern &
                              (long) Primitive.ParticleSystem.SourcePattern.Explode).Equals(0))
                            particleSystem.Append(" | PSYS_SRC_PATTERN_EXPLODE");
                        if (
                            !((long) primitive.ParticleSys.Pattern & (long) Primitive.ParticleSystem.SourcePattern.Angle)
                                .Equals(0))
                            particleSystem.Append(" | PSYS_SRC_PATTERN_ANGLE");
                        if (!((long) primitive.ParticleSys.Pattern &
                              (long) Primitive.ParticleSystem.SourcePattern.AngleCone).Equals(0))
                            particleSystem.Append(" | PSYS_SRC_PATTERN_ANGLE_CONE");
                        if (!((long) primitive.ParticleSys.Pattern &
                              (long) Primitive.ParticleSystem.SourcePattern.AngleConeEmpty).Equals(0))
                            particleSystem.Append(" | PSYS_SRC_PATTERN_ANGLE_CONE_EMPTY");
                        particleSystem.Append(",");
                        particleSystem.Append("PSYS_PART_START_ALPHA, " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartStartColor.A) +
                                              ",");
                        particleSystem.Append("PSYS_PART_END_ALPHA, " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartEndColor.A) +
                                              ",");
                        particleSystem.Append("PSYS_PART_START_COLOR, " +
                                              primitive.ParticleSys.PartStartColor.ToRGBString() +
                                              ",");
                        particleSystem.Append("PSYS_PART_END_COLOR, " + primitive.ParticleSys.PartEndColor.ToRGBString() +
                                              ",");
                        particleSystem.Append("PSYS_PART_START_SCALE, <" +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartStartScaleX) + ", " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartStartScaleY) +
                                              ", 0>, ");
                        particleSystem.Append("PSYS_PART_END_SCALE, <" +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartEndScaleX) + ", " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartEndScaleY) +
                                              ", 0>, ");
                        particleSystem.Append("PSYS_PART_MAX_AGE, " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartMaxAge) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_MAX_AGE, " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.MaxAge) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_ACCEL, " + primitive.ParticleSys.PartAcceleration +
                                              ",");
                        particleSystem.Append("PSYS_SRC_BURST_PART_COUNT, " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0}",
                                                  primitive.ParticleSys.BurstPartCount) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_BURST_RADIUS, " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.BurstRadius) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_BURST_RATE, " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.BurstRate) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_BURST_SPEED_MIN, " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.BurstSpeedMin) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_BURST_SPEED_MAX, " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.BurstSpeedMax) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_INNERANGLE, " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.InnerAngle) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_OUTERANGLE, " +
                                              string.Format(CultureInfo.InvariantCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.OuterAngle) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_OMEGA, " + primitive.ParticleSys.AngularVelocity +
                                              ",");
                        particleSystem.Append("PSYS_SRC_TEXTURE, (key)\"" + primitive.ParticleSys.Texture + "\"" +
                                              ",");
                        particleSystem.Append("PSYS_SRC_TARGET_KEY, (key)\"" + primitive.ParticleSys.Target + "\"");
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), particleSystem.ToString());
                    };
                    break;
                case ScriptKeys.CREATENOTECARD:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_NAME_PROVIDED));
                        }
                        ManualResetEvent CreateNotecardEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        InventoryItem newItem = null;
                        Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(AssetType.Notecard),
                            name,
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                    message)),
                            AssetType.Notecard,
                            UUID.Random(), InventoryType.Notecard, PermissionMask.All,
                            delegate(bool completed, InventoryItem createdItem)
                            {
                                succeeded = completed;
                                newItem = createdItem;
                                CreateNotecardEvent.Set();
                            });
                        if (!CreateNotecardEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_CREATING_ITEM));
                        }
                        if (!succeeded)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_CREATE_ITEM));
                        }
                        AssetNotecard blank = new AssetNotecard
                        {
                            BodyText = LINDEN_CONSTANTS.ASSETS.NOTECARD.NEWLINE
                        };
                        blank.Encode();
                        ManualResetEvent UploadBlankNotecardEvent = new ManualResetEvent(false);
                        succeeded = false;
                        Client.Inventory.RequestUploadNotecardAsset(blank.AssetData, newItem.UUID,
                            delegate(bool completed, string status, UUID itemUUID, UUID assetUUID)
                            {
                                succeeded = completed;
                                UploadBlankNotecardEvent.Set();
                            });
                        if (!UploadBlankNotecardEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_UPLOADING_ITEM));
                        }
                        if (!succeeded)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_UPLOAD_ITEM));
                        }
                        string text =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TEXT)),
                                message));
                        if (!string.IsNullOrEmpty(text))
                        {
                            AssetNotecard notecard = new AssetNotecard
                            {
                                BodyText = text
                            };
                            notecard.Encode();
                            ManualResetEvent UploadNotecardDataEvent = new ManualResetEvent(false);
                            succeeded = false;
                            Client.Inventory.RequestUploadNotecardAsset(notecard.AssetData, newItem.UUID,
                                delegate(bool completed, string status, UUID itemUUID, UUID assetUUID)
                                {
                                    succeeded = completed;
                                    UploadNotecardDataEvent.Set();
                                });
                            if (!UploadNotecardDataEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_UPLOADING_ITEM_DATA));
                            }
                            if (!succeeded)
                            {
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_UPLOAD_ITEM_DATA));
                            }
                        }
                    };
                    break;
                case ScriptKeys.ACTIVATE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_IN_GROUP));
                        }
                        Client.Groups.ActivateGroup(groupUUID);
                    };
                    break;
                case ScriptKeys.TAG:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_IN_GROUP));
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant()))
                        {
                            case Action.SET:
                                ManualResetEvent GroupRoleDataReplyEvent = new ManualResetEvent(false);
                                Dictionary<string, UUID> roleData = new Dictionary<string, UUID>();
                                EventHandler<GroupRolesDataReplyEventArgs> Groups_GroupRoleDataReply = (sender, args) =>
                                {
                                    roleData = args.Roles.ToDictionary(o => o.Value.Title, o => o.Value.ID);
                                    GroupRoleDataReplyEvent.Set();
                                };
                                lock (ClientInstanceGroupsLock)
                                {
                                    Client.Groups.GroupRoleDataReply += Groups_GroupRoleDataReply;
                                    Client.Groups.RequestGroupRoles(groupUUID);
                                    if (!GroupRoleDataReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Groups.GroupRoleDataReply -= Groups_GroupRoleDataReply;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_GROUP_ROLES));
                                    }
                                    Client.Groups.GroupRoleDataReply -= Groups_GroupRoleDataReply;
                                }
                                KeyValuePair<string, UUID> role = roleData.AsParallel().FirstOrDefault(
                                    o =>
                                        o.Key.Equals(
                                            wasInput(
                                                wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TITLE)),
                                                    message)),
                                            StringComparison.Ordinal));
                                if (role.Equals(default(KeyValuePair<string, UUID>)))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_TITLE));
                                }
                                Client.Groups.ActivateTitle(groupUUID, role.Value);
                                break;
                            case Action.GET:
                                string title = string.Empty;
                                ManualResetEvent GroupTitlesReplyEvent = new ManualResetEvent(false);
                                EventHandler<GroupTitlesReplyEventArgs> GroupTitlesReplyEventHandler = (sender, args) =>
                                {
                                    KeyValuePair<UUID, GroupTitle> pair =
                                        args.Titles.AsParallel().FirstOrDefault(o => o.Value.Selected);
                                    if (!pair.Equals(default(KeyValuePair<UUID, GroupTitle>)))
                                    {
                                        title = pair.Value.Title;
                                    }
                                    GroupTitlesReplyEvent.Set();
                                };
                                lock (ClientInstanceGroupsLock)
                                {
                                    Client.Groups.GroupTitlesReply += GroupTitlesReplyEventHandler;
                                    Client.Groups.RequestGroupTitles(groupUUID);
                                    if (!GroupTitlesReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Groups.GroupTitlesReply -= GroupTitlesReplyEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_GROUP_TITLES));
                                    }
                                    Client.Groups.GroupTitlesReply -= GroupTitlesReplyEventHandler;
                                }
                                if (!title.Equals(string.Empty))
                                {
                                    result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), title);
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.GETTITLES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_IN_GROUP));
                        }
                        List<string> csv = new List<string>();
                        ManualResetEvent GroupTitlesReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupTitlesReplyEventArgs> GroupTitlesReplyEventHandler = (sender, args) =>
                        {
                            foreach (KeyValuePair<UUID, GroupTitle> title in args.Titles)
                            {
                                string roleName = string.Empty;
                                if (
                                    !RoleUUIDToName(title.Value.RoleID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                        Configuration.DATA_TIMEOUT,
                                        ref roleName))
                                    continue;
                                csv.Add(title.Value.Title);
                                csv.Add(title.Key.ToString());
                                csv.Add(roleName);
                                csv.Add(title.Value.RoleID.ToString());
                            }
                            GroupTitlesReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupTitlesReply += GroupTitlesReplyEventHandler;
                            Client.Groups.RequestGroupTitles(groupUUID);
                            if (!GroupTitlesReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Groups.GroupTitlesReply -= GroupTitlesReplyEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_GROUP_TITLES));
                            }
                            Client.Groups.GroupTitlesReply -= GroupTitlesReplyEventHandler;
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.AUTOPILOT:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.START:
                                Vector3 position;
                                if (
                                    !Vector3.TryParse(
                                        wasInput(wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)), message)),
                                        out position))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_POSITION));
                                }
                                uint moveRegionX, moveRegionY;
                                Utils.LongToUInts(Client.Network.CurrentSim.Handle, out moveRegionX, out moveRegionY);
                                if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                                {
                                    Client.Self.Stand();
                                }
                                // stop all non-built-in animations
                                List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                                    BindingFlags.Public |
                                    BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                                Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                                {
                                    if (!lindenAnimations.Contains(o))
                                        Client.Self.AnimationStop(o, true);
                                });
                                Client.Self.AutoPilotCancel();
                                Client.Self.Movement.TurnToward(position, true);
                                Client.Self.AutoPilot(position.X + moveRegionX, position.Y + moveRegionY, position.Z);
                                break;
                            case Action.STOP:
                                Client.Self.AutoPilotCancel();
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_MOVE_ACTION));
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.TURNTO:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_POSITION));
                        }
                        Client.Self.Movement.TurnToward(position, true);
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.NUDGE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        switch (wasGetEnumValueFromDescription<Direction>(
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DIRECTION)),
                                message))
                                .ToLowerInvariant()))
                        {
                            case Direction.BACK:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.AGENT_CONTROL_AT_NEG,
                                    Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None, AgentState.None, true);
                                break;
                            case Direction.FORWARD:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.AGENT_CONTROL_AT_POS,
                                    Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None,
                                    AgentState.None, true);
                                break;
                            case Direction.LEFT:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.
                                    AGENT_CONTROL_LEFT_POS, Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None,
                                    AgentState.None, true);
                                break;
                            case Direction.RIGHT:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.
                                    AGENT_CONTROL_LEFT_NEG, Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None,
                                    AgentState.None, true);
                                break;
                            case Direction.UP:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.AGENT_CONTROL_UP_POS,
                                    Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None,
                                    AgentState.None, true);
                                break;
                            case Direction.DOWN:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.AGENT_CONTROL_UP_NEG,
                                    Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None,
                                    AgentState.None, true);
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_DIRECTION));
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.SETVIEWEREFFECT:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID effectUUID;
                        if (!UUID.TryParse(wasInput(wasKeyValueGet(
                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ID)), message)), out effectUUID))
                        {
                            effectUUID = UUID.Random();
                        }
                        Vector3 offset;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(
                                        wasOutput(
                                            wasGetDescriptionFromEnumValue(ScriptKeys.OFFSET)),
                                        message)),
                                out offset))
                        {
                            offset = Client.Self.SimPosition;
                        }
                        ViewerEffectType viewerEffectType = wasGetEnumValueFromDescription<ViewerEffectType>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.EFFECT)), message))
                                .ToLowerInvariant());
                        switch (viewerEffectType)
                        {
                            case ViewerEffectType.BEAM:
                            case ViewerEffectType.POINT:
                            case ViewerEffectType.LOOK:
                                string item = wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message));
                                UUID targetUUID;
                                switch (!string.IsNullOrEmpty(item))
                                {
                                    case true:
                                        float range;
                                        if (
                                            !float.TryParse(
                                                wasInput(wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                                out range))
                                        {
                                            range = Configuration.RANGE;
                                        }
                                        Primitive primitive = null;
                                        if (
                                            !FindPrimitive(
                                                StringOrUUID(item),
                                                range,
                                                ref primitive, Configuration.SERVICES_TIMEOUT,
                                                Configuration.DATA_TIMEOUT))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                                        }
                                        targetUUID = primitive.ID;
                                        break;
                                    default:
                                        if (
                                            !UUID.TryParse(
                                                wasInput(wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                                out targetUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                                    ref targetUUID))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                                        }
                                        break;
                                }
                                switch (viewerEffectType)
                                {
                                    case ViewerEffectType.LOOK:
                                        FieldInfo lookAtTypeInfo = typeof (LookAtType).GetFields(BindingFlags.Public |
                                                                                                 BindingFlags.Static)
                                            .AsParallel().FirstOrDefault(
                                                o =>
                                                    o.Name.Equals(
                                                        wasInput(
                                                            wasKeyValueGet(
                                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                                message)),
                                                        StringComparison.Ordinal));
                                        LookAtType lookAtType = lookAtTypeInfo != null
                                            ? (LookAtType)
                                                lookAtTypeInfo
                                                    .GetValue(null)
                                            : LookAtType.None;
                                        Client.Self.LookAtEffect(Client.Self.AgentID, targetUUID, offset,
                                            lookAtType, effectUUID);
                                        if (LookAtEffects.AsParallel().Any(o => o.Effect.Equals(effectUUID)))
                                        {
                                            LookAtEffects.RemoveWhere(o => o.Effect.Equals(effectUUID));
                                        }
                                        if (!lookAtType.Equals(LookAtType.None))
                                        {
                                            LookAtEffects.Add(new LookAtEffect
                                            {
                                                Effect = effectUUID,
                                                Offset = offset,
                                                Source = Client.Self.AgentID,
                                                Target = targetUUID,
                                                Type = lookAtType
                                            });
                                        }
                                        break;
                                    case ViewerEffectType.POINT:
                                        FieldInfo pointAtTypeInfo = typeof (PointAtType).GetFields(BindingFlags.Public |
                                                                                                   BindingFlags.Static)
                                            .AsParallel().FirstOrDefault(
                                                o =>
                                                    o.Name.Equals(
                                                        wasInput(
                                                            wasKeyValueGet(
                                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                                message)),
                                                        StringComparison.Ordinal));
                                        PointAtType pointAtType = pointAtTypeInfo != null
                                            ? (PointAtType)
                                                pointAtTypeInfo
                                                    .GetValue(null)
                                            : PointAtType.None;
                                        Client.Self.PointAtEffect(Client.Self.AgentID, targetUUID, offset,
                                            pointAtType, effectUUID);
                                        if (PointAtEffects.AsParallel().Any(o => o.Effect.Equals(effectUUID)))
                                        {
                                            PointAtEffects.RemoveWhere(o => o.Effect.Equals(effectUUID));
                                        }
                                        if (!pointAtType.Equals(PointAtType.None))
                                        {
                                            PointAtEffects.Add(new PointAtEffect
                                            {
                                                Effect = effectUUID,
                                                Offset = offset,
                                                Source = Client.Self.AgentID,
                                                Target = targetUUID,
                                                Type = pointAtType
                                            });
                                        }
                                        break;
                                    case ViewerEffectType.BEAM:
                                    case ViewerEffectType.SPHERE:
                                        Vector3 RGB;
                                        if (
                                            !Vector3.TryParse(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.COLOR)),
                                                        message)),
                                                out RGB))
                                        {
                                            RGB = new Vector3(Client.Settings.DEFAULT_EFFECT_COLOR.R,
                                                Client.Settings.DEFAULT_EFFECT_COLOR.G,
                                                Client.Settings.DEFAULT_EFFECT_COLOR.B);
                                        }
                                        float alpha;
                                        if (!float.TryParse(
                                            wasInput(
                                                wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ALPHA)),
                                                    message)), out alpha))
                                        {
                                            alpha = Client.Settings.DEFAULT_EFFECT_COLOR.A;
                                        }
                                        float duration;
                                        if (
                                            !float.TryParse(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DURATION)),
                                                        message)),
                                                out duration))
                                        {
                                            duration = 1;
                                        }
                                        Color4 color = new Color4(RGB.X, RGB.Y, RGB.Z, alpha);
                                        switch (viewerEffectType)
                                        {
                                            case ViewerEffectType.BEAM:
                                                Client.Self.BeamEffect(Client.Self.AgentID, targetUUID, offset,
                                                    color, duration, effectUUID);
                                                lock (BeamEffectsLock)
                                                {
                                                    if (BeamEffects.AsParallel().Any(o => o.Effect.Equals(effectUUID)))
                                                    {
                                                        BeamEffects.RemoveWhere(o => o.Effect.Equals(effectUUID));
                                                    }
                                                    BeamEffects.Add(new BeamEffect
                                                    {
                                                        Effect = effectUUID,
                                                        Source = Client.Self.AgentID,
                                                        Target = targetUUID,
                                                        Color = new Vector3(color.R, color.G, color.B),
                                                        Alpha = color.A,
                                                        Duration = duration,
                                                        Offset = offset,
                                                        Termination = DateTime.Now.AddSeconds(duration)
                                                    });
                                                }
                                                break;
                                            case ViewerEffectType.SPHERE:
                                                Client.Self.SphereEffect(offset, color, duration,
                                                    effectUUID);
                                                lock (SphereEffectsLock)
                                                {
                                                    if (SphereEffects.AsParallel().Any(o => o.Effect.Equals(effectUUID)))
                                                    {
                                                        SphereEffects.RemoveWhere(o => o.Effect.Equals(effectUUID));
                                                    }
                                                    SphereEffects.Add(new SphereEffect
                                                    {
                                                        Color = new Vector3(color.R, color.G, color.B),
                                                        Alpha = color.A,
                                                        Duration = duration,
                                                        Effect = effectUUID,
                                                        Offset = offset,
                                                        Termination = DateTime.Now.AddSeconds(duration)
                                                    });
                                                }
                                                break;
                                        }
                                        break;
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_EFFECT));
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), effectUUID.ToString());
                    };
                    break;
                case ScriptKeys.GETVIEWEREFFECTS:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> csv = new List<string>();
                        object LockObject = new object();
                        ViewerEffectType viewerEffectType = wasGetEnumValueFromDescription<ViewerEffectType>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.EFFECT)), message))
                                .ToLowerInvariant());
                        switch (viewerEffectType)
                        {
                            case ViewerEffectType.LOOK:
                                Parallel.ForEach(LookAtEffects, o =>
                                {
                                    lock (LockObject)
                                    {
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Effect), o.Effect.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Source), o.Source.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Target), o.Target.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Offset), o.Offset.ToString()});
                                        csv.AddRange(new[]
                                        {
                                            wasGetStructureMemberDescription(o, o.Type),
                                            Enum.GetName(typeof (LookAtType), o.Type)
                                        });
                                    }
                                });
                                break;
                            case ViewerEffectType.POINT:
                                Parallel.ForEach(PointAtEffects, o =>
                                {
                                    lock (LockObject)
                                    {
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Effect), o.Effect.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Source), o.Source.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Target), o.Target.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Offset), o.Offset.ToString()});
                                        csv.AddRange(new[]
                                        {
                                            wasGetStructureMemberDescription(o, o.Type),
                                            Enum.GetName(typeof (PointAtType), o.Type)
                                        });
                                    }
                                });
                                break;
                            case ViewerEffectType.SPHERE:
                                lock (SphereEffectsLock)
                                {
                                    Parallel.ForEach(SphereEffects, o =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Effect), o.Effect.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Offset), o.Offset.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Color), o.Color.ToString()});
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Alpha),
                                                o.Alpha.ToString(CultureInfo.InvariantCulture)
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Duration),
                                                o.Duration.ToString(CultureInfo.InvariantCulture)
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Termination),
                                                o.Termination.ToString(CultureInfo.InvariantCulture)
                                            });
                                        }
                                    });
                                }
                                break;
                            case ViewerEffectType.BEAM:
                                lock (BeamEffectsLock)
                                {
                                    Parallel.ForEach(BeamEffects, o =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Effect), o.Effect.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Offset), o.Offset.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Source), o.Source.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Target), o.Target.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Color), o.Color.ToString()});
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Alpha),
                                                o.Alpha.ToString(CultureInfo.InvariantCulture)
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Duration),
                                                o.Duration.ToString(CultureInfo.InvariantCulture)
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Termination),
                                                o.Termination.ToString(CultureInfo.InvariantCulture)
                                            });
                                        }
                                    });
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_EFFECT));
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.DELETEVIEWEREFFECT:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID effectUUID;
                        if (!UUID.TryParse(wasInput(wasKeyValueGet(
                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ID)), message)), out effectUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_EFFECT_UUID_PROVIDED));
                        }
                        ViewerEffectType viewerEffectType = wasGetEnumValueFromDescription<ViewerEffectType>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.EFFECT)), message))
                                .ToLowerInvariant());
                        switch (viewerEffectType)
                        {
                            case ViewerEffectType.LOOK:
                                LookAtEffect lookAtEffect =
                                    LookAtEffects.AsParallel().FirstOrDefault(o => o.Effect.Equals(effectUUID));
                                if (lookAtEffect.Equals(default(LookAtEffect)))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EFFECT_NOT_FOUND));
                                }
                                Client.Self.LookAtEffect(Client.Self.AgentID, lookAtEffect.Target, Vector3.Zero,
                                    LookAtType.None, effectUUID);
                                LookAtEffects.Remove(lookAtEffect);
                                break;
                            case ViewerEffectType.POINT:
                                PointAtEffect pointAtEffect =
                                    PointAtEffects.AsParallel().FirstOrDefault(o => o.Effect.Equals(effectUUID));
                                if (pointAtEffect.Equals(default(PointAtEffect)))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EFFECT_NOT_FOUND));
                                }
                                Client.Self.PointAtEffect(Client.Self.AgentID, pointAtEffect.Target, Vector3.Zero,
                                    PointAtType.None, effectUUID);
                                PointAtEffects.Remove(pointAtEffect);
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_VIEWER_EFFECT));
                        }
                    };
                    break;
                case ScriptKeys.STARTPROPOSAL:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROUP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        if (
                            !AgentInGroup(Client.Self.AgentID, groupUUID, Configuration.SERVICES_TIMEOUT,
                                Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NOT_IN_GROUP));
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, groupUUID, GroupPowers.StartProposal,
                                Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                        }
                        int duration;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DURATION)),
                                        message)),
                                out duration))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_PROPOSAL_DURATION));
                        }
                        float majority;
                        if (
                            !float.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MAJORITY)),
                                        message)),
                                out majority))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_PROPOSAL_MAJORITY));
                        }
                        int quorum;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.QUORUM)), message)),
                                out quorum))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_PROPOSAL_QUORUM));
                        }
                        string text =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TEXT)),
                                message));
                        if (string.IsNullOrEmpty(text))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_PROPOSAL_TEXT));
                        }
                        Client.Groups.StartProposal(groupUUID, new GroupProposal
                        {
                            Duration = duration,
                            Majority = majority,
                            Quorum = quorum,
                            VoteText = text
                        });
                    };
                    break;
                case ScriptKeys.MUTE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group, (int) Permissions.PERMISSION_MUTE))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID targetUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)), message)),
                                out targetUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_MUTE_TARGET));
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.MUTE:
                                FieldInfo muteTypeInfo = typeof (MuteType).GetFields(BindingFlags.Public |
                                                                                     BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        o =>
                                            o.Name.Equals(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                        message)),
                                                StringComparison.Ordinal));
                                ManualResetEvent MuteListUpdatedEvent = new ManualResetEvent(false);
                                EventHandler<EventArgs> MuteListUpdatedEventHandler =
                                    (sender, args) => MuteListUpdatedEvent.Set();
                                lock (ClientInstanceSelfLock)
                                {
                                    Client.Self.MuteListUpdated += MuteListUpdatedEventHandler;
                                    Client.Self.UpdateMuteListEntry(muteTypeInfo != null
                                        ? (MuteType)
                                            muteTypeInfo
                                                .GetValue(null)
                                        : MuteType.ByName, targetUUID,
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                                message)));
                                    if (!MuteListUpdatedEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Self.MuteListUpdated -= MuteListUpdatedEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_UPDATING_MUTE_LIST));
                                    }
                                    Client.Self.MuteListUpdated -= MuteListUpdatedEventHandler;
                                }
                                break;
                            case Action.UNMUTE:
                                Client.Self.RemoveMuteListEntry(targetUUID,
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                            message)));
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.GETMUTES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_MUTE))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> data = new List<string>(Client.Self.MuteList.Copy().AsParallel().Select(o => new[]
                        {
                            o.Value.Name,
                            o.Value.ID.ToString()
                        }).SelectMany(o => o));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.DATABASE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_DATABASE))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case false:
                                UUID groupUUID = UUID.Zero;
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                configuredGroup =
                                    Configuration.GROUPS.AsParallel().FirstOrDefault(o => o.UUID.Equals(groupUUID));
                                if (configuredGroup.Equals(default(Group)))
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                break;
                        }
                        if (string.IsNullOrEmpty(configuredGroup.DatabaseFile))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_DATABASE_FILE_CONFIGURED));
                        }
                        if (!File.Exists(configuredGroup.DatabaseFile))
                        {
                            // create the file and close it
                            File.Create(configuredGroup.DatabaseFile).Close();
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.GET:
                                string databaseGetkey =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.KEY)),
                                            message));
                                if (string.IsNullOrEmpty(databaseGetkey))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_DATABASE_KEY_SPECIFIED));
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (!DatabaseLocks.ContainsKey(configuredGroup.Name))
                                    {
                                        DatabaseLocks.Add(configuredGroup.Name, new object());
                                    }
                                }
                                lock (DatabaseLocks[configuredGroup.Name])
                                {
                                    string databaseGetValue = wasKeyValueGet(databaseGetkey,
                                        File.ReadAllText(configuredGroup.DatabaseFile));
                                    if (!string.IsNullOrEmpty(databaseGetValue))
                                    {
                                        result.Add(databaseGetkey,
                                            wasInput(databaseGetValue));
                                    }
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (DatabaseLocks.ContainsKey(configuredGroup.Name))
                                    {
                                        DatabaseLocks.Remove(configuredGroup.Name);
                                    }
                                }
                                break;
                            case Action.SET:
                                string databaseSetKey =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.KEY)),
                                            message));
                                if (string.IsNullOrEmpty(databaseSetKey))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_DATABASE_KEY_SPECIFIED));
                                }
                                string databaseSetValue =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.VALUE)),
                                            message));
                                if (string.IsNullOrEmpty(databaseSetValue))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_DATABASE_VALUE_SPECIFIED));
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (!DatabaseLocks.ContainsKey(configuredGroup.Name))
                                    {
                                        DatabaseLocks.Add(configuredGroup.Name, new object());
                                    }
                                }
                                lock (DatabaseLocks[configuredGroup.Name])
                                {
                                    string contents = File.ReadAllText(configuredGroup.DatabaseFile);
                                    using (
                                        StreamWriter recreateDatabase = new StreamWriter(configuredGroup.DatabaseFile,
                                            false))
                                    {
                                        recreateDatabase.Write(wasKeyValueSet(databaseSetKey,
                                            databaseSetValue, contents));
                                        recreateDatabase.Flush();
                                        //recreateDatabase.Close();
                                    }
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (DatabaseLocks.ContainsKey(configuredGroup.Name))
                                    {
                                        DatabaseLocks.Remove(configuredGroup.Name);
                                    }
                                }
                                break;
                            case Action.DELETE:
                                string databaseDeleteKey =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.KEY)),
                                            message));
                                if (string.IsNullOrEmpty(databaseDeleteKey))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_DATABASE_KEY_SPECIFIED));
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (!DatabaseLocks.ContainsKey(configuredGroup.Name))
                                    {
                                        DatabaseLocks.Add(configuredGroup.Name, new object());
                                    }
                                }
                                lock (DatabaseLocks[configuredGroup.Name])
                                {
                                    string contents = File.ReadAllText(configuredGroup.DatabaseFile);
                                    using (
                                        StreamWriter recreateDatabase = new StreamWriter(configuredGroup.DatabaseFile,
                                            false))
                                    {
                                        recreateDatabase.Write(wasKeyValueDelete(databaseDeleteKey, contents));
                                        recreateDatabase.Flush();
                                        //recreateDatabase.Close();
                                    }
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (DatabaseLocks.ContainsKey(configuredGroup.Name))
                                    {
                                        DatabaseLocks.Remove(configuredGroup.Name);
                                    }
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_DATABASE_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.NOTIFY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_NOTIFICATIONS))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case false:
                                UUID groupUUID = UUID.Zero;
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                configuredGroup =
                                    Configuration.GROUPS.AsParallel().FirstOrDefault(o => o.UUID.Equals(groupUUID));
                                if (configuredGroup.Equals(default(Group)))
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                break;
                        }
                        string url = wasInput(
                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.URL)),
                                message));
                        string notificationTypes =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                    message))
                                .ToLowerInvariant();
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.ADD:
                                if (string.IsNullOrEmpty(url))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_URL_PROVIDED));
                                }
                                Uri notifyURL;
                                if (!Uri.TryCreate(url, UriKind.Absolute, out notifyURL))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_URL_PROVIDED));
                                }
                                if (string.IsNullOrEmpty(notificationTypes))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.INVALID_NOTIFICATION_TYPES));
                                }
                                Notification notification;
                                lock (GroupNotificationsLock)
                                {
                                    notification =
                                        GroupNotifications.AsParallel().FirstOrDefault(
                                            o => o.GroupName.Equals(configuredGroup.Name, StringComparison.Ordinal));
                                }
                                if (notification.Equals(default(Notification)))
                                {
                                    notification = new Notification
                                    {
                                        GroupName = configuredGroup.Name,
                                        NotificationMask = 0,
                                        NotificationDestination =
                                            new SerializableDictionary<Notifications, HashSet<string>>()
                                    };
                                }
                                Parallel.ForEach(wasCSVToEnumerable(
                                    notificationTypes),
                                    o =>
                                    {
                                        uint notificationValue = (uint) wasGetEnumValueFromDescription<Notifications>(o);
                                        if (!GroupHasNotification(configuredGroup.Name, notificationValue))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.NOTIFICATION_NOT_ALLOWED));
                                        }
                                        notification.NotificationMask |= notificationValue;
                                        switch (
                                            !notification.NotificationDestination.ContainsKey(
                                                (Notifications) notificationValue))
                                        {
                                            case true:
                                                notification.NotificationDestination.Add(
                                                    (Notifications) notificationValue, new HashSet<string> {url});
                                                break;
                                            default:
                                                // notification destination is already there
                                                if (notification.NotificationDestination[
                                                    (Notifications) notificationValue].Contains(url)) break;
                                                notification.NotificationDestination[(Notifications) notificationValue]
                                                    .Add(url);
                                                break;
                                        }
                                    });
                                lock (GroupNotificationsLock)
                                {
                                    // Replace notification.
                                    GroupNotifications.RemoveWhere(
                                        o => o.GroupName.Equals(configuredGroup.Name, StringComparison.Ordinal));
                                    GroupNotifications.Add(notification);
                                }
                                break;
                            case Action.REMOVE:
                                HashSet<Notification> groupNotifications = new HashSet<Notification>();
                                lock (GroupNotificationsLock)
                                {
                                    Parallel.ForEach(GroupNotifications, o =>
                                    {
                                        if ((!wasCSVToEnumerable(notificationTypes)
                                            .AsParallel()
                                            .Any(p => !(o.NotificationMask &
                                                        (uint) wasGetEnumValueFromDescription<Notifications>(p))
                                                .Equals(0)) &&
                                             !o.NotificationDestination.Values.Any(p => p.Contains(url))) ||
                                            !o.GroupName.Equals(configuredGroup.Name, StringComparison.Ordinal))
                                        {
                                            groupNotifications.Add(o);
                                            return;
                                        }
                                        SerializableDictionary<Notifications, HashSet<string>>
                                            notificationDestination =
                                                new SerializableDictionary<Notifications, HashSet<string>>();
                                        Parallel.ForEach(o.NotificationDestination, p =>
                                        {
                                            switch (!wasCSVToEnumerable(notificationTypes)
                                                .AsParallel()
                                                .Any(
                                                    q =>
                                                        wasGetEnumValueFromDescription<Notifications>(q)
                                                            .Equals(p.Key)))
                                            {
                                                case true:
                                                    notificationDestination.Add(p.Key, p.Value);
                                                    break;
                                                default:
                                                    HashSet<string> URLs =
                                                        new HashSet<string>(p.Value.Where(q => !q.Equals(url)));
                                                    if (URLs.Count.Equals(0)) return;
                                                    notificationDestination.Add(p.Key, URLs);
                                                    break;
                                            }
                                        });
                                        groupNotifications.Add(new Notification
                                        {
                                            GroupName = o.GroupName,
                                            NotificationMask =
                                                notificationDestination.Keys.Cast<uint>().Aggregate((p, q) => p |= q),
                                            NotificationDestination = notificationDestination
                                        });
                                    });
                                    // Now assign the new notifications.
                                    GroupNotifications = groupNotifications;
                                }
                                break;
                            case Action.LIST:
                                // If the group has no installed notifications, bail
                                List<string> csv = new List<string>();
                                object LockObject = new object();
                                lock (GroupNotificationsLock)
                                {
                                    Notification groupNotification =
                                        GroupNotifications.AsParallel().FirstOrDefault(
                                            o => o.GroupName.Equals(configuredGroup.Name, StringComparison.Ordinal));
                                    if (!groupNotification.Equals(default(Notification)))
                                    {
                                        Parallel.ForEach(wasGetEnumDescriptions<Notifications>(), o =>
                                        {
                                            if ((groupNotification.NotificationMask &
                                                 (uint) wasGetEnumValueFromDescription<Notifications>(o)).Equals(0))
                                                return;
                                            lock (LockObject)
                                            {
                                                csv.Add(o);
                                                csv.AddRange(groupNotification.NotificationDestination[
                                                    wasGetEnumValueFromDescription<Notifications>(o)]);
                                            }
                                        });
                                    }
                                }
                                if (!csv.Count.Equals(0))
                                {
                                    result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                        wasEnumerableToCSV(csv));
                                }
                                break;
                            case Action.CLEAR:
                                lock (GroupNotificationsLock)
                                {
                                    GroupNotifications.RemoveWhere(
                                        o => o.GroupName.Equals(configuredGroup.Name, StringComparison.Ordinal));
                                }
                                break;
                            default:
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                        // Now save the state.
                        lock (GroupNotificationsLock)
                        {
                            SaveNotificationState.Invoke();
                        }
                    };
                    break;
                case ScriptKeys.REPLYTOTELEPORTLURE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        UUID sessionUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION)),
                                        message)),
                                out sessionUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_SESSION_SPECIFIED));
                        }
                        Client.Self.TeleportLureRespond(agentUUID, sessionUUID, wasGetEnumValueFromDescription<Action>(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                message))
                                .ToLowerInvariant()).Equals(Action.ACCEPT));
                    };
                    break;
                case ScriptKeys.GETTELEPORTLURES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> csv = new List<string>();
                        object LockObject = new object();
                        lock (TeleportLureLock)
                        {
                            Parallel.ForEach(TeleportLures, o =>
                            {
                                lock (LockObject)
                                {
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.FirstName), o.Agent.FirstName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.LastName), o.Agent.LastName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.UUID), o.Agent.UUID.ToString()});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o, o.Session), o.Session.ToString()});
                                }
                            });
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.REPLYTOSCRIPTPERMISSIONREQUEST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID itemUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message)),
                                out itemUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_ITEM_SPECIFIED));
                        }
                        UUID taskUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TASK)), message)),
                                out taskUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_TASK_SPECIFIED));
                        }
                        int permissionMask = 0;
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PERMISSIONS)),
                                    message))),
                            o =>
                                Parallel.ForEach(
                                    typeof (ScriptPermission).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                    q => { permissionMask |= ((int) q.GetValue(null)); }));
                        Simulator simulator = Client.Network.Simulators.FirstOrDefault(
                            o => o.Name.Equals(wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                    message)), StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Client.Self.ScriptQuestionReply(simulator, itemUUID, taskUUID,
                            (ScriptPermission) permissionMask);
                    };
                    break;
                case ScriptKeys.GETSCRIPTPERMISSIONREQUESTS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> csv = new List<string>();
                        object LockObject = new object();
                        lock (ScriptPermissionRequestLock)
                        {
                            Parallel.ForEach(ScriptPermissionRequests, o =>
                            {
                                lock (LockObject)
                                {
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Name), o.Name});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.FirstName), o.Agent.FirstName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.LastName), o.Agent.LastName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.UUID), o.Agent.UUID.ToString()});
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Item), o.Item.ToString()});
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Task), o.Task.ToString()});
                                    csv.Add(wasGetStructureMemberDescription(o, o.Permission));
                                    csv.AddRange(typeof (ScriptPermission).GetFields(BindingFlags.Public |
                                                                                     BindingFlags.Static)
                                        .AsParallel().Where(
                                            p =>
                                                !(((int) p.GetValue(null) &
                                                   (int) o.Permission)).Equals(0))
                                        .Select(p => p.Name).ToArray());
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Region), o.Region});
                                }
                            });
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.REPLYTOSCRIPTDIALOG:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        int channel;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.CHANNEL)),
                                        message)),
                                out channel))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CHANNEL_SPECIFIED));
                        }
                        int index;
                        if (
                            !int.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.INDEX)), message)),
                                out index))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_BUTTON_INDEX_SPECIFIED));
                        }
                        string label =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.BUTTON)),
                                message));
                        if (string.IsNullOrEmpty(label))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_BUTTON_SPECIFIED));
                        }
                        UUID itemUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message)),
                                out itemUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_ITEM_SPECIFIED));
                        }
                        Client.Self.ReplyToScriptDialog(channel, index, label, itemUUID);
                    };
                    break;
                case ScriptKeys.GETSCRIPTDIALOGS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> csv = new List<string>();
                        object LockObject = new object();
                        lock (ScriptDialogLock)
                        {
                            Parallel.ForEach(ScriptDialogs, o =>
                            {
                                lock (LockObject)
                                {
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Message), o.Message});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.FirstName), o.Agent.FirstName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.LastName), o.Agent.LastName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.UUID), o.Agent.UUID.ToString()});
                                    csv.AddRange(new[]
                                    {
                                        wasGetStructureMemberDescription(o, o.Channel),
                                        o.Channel.ToString(CultureInfo.InvariantCulture)
                                    });
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Name), o.Name});
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Item), o.Item.ToString()});
                                    csv.Add(wasGetStructureMemberDescription(o, o.Button));
                                    csv.AddRange(o.Button.ToArray());
                                }
                            });
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.ANIMATION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string item =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                message));
                        if (string.IsNullOrEmpty(item))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_ITEM_SPECIFIED));
                        }
                        UUID itemUUID;
                        if (!UUID.TryParse(item, out itemUUID))
                        {
                            InventoryBase inventoryBaseItem =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                    ).FirstOrDefault();
                            if (inventoryBaseItem == null)
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                            }
                            InventoryItem inventoryItem = inventoryBaseItem as InventoryItem;
                            if (inventoryItem == null)
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                            }
                            itemUUID = inventoryItem.AssetUUID;
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.START:
                                Client.Self.AnimationStart(itemUUID, true);
                                break;
                            case Action.STOP:
                                Client.Self.AnimationStop(itemUUID, true);
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ANIMATION_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.PLAYGESTURE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string item =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                message));
                        if (string.IsNullOrEmpty(item))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_ITEM_SPECIFIED));
                        }
                        UUID itemUUID;
                        if (!UUID.TryParse(item, out itemUUID))
                        {
                            InventoryBase inventoryBaseItem =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                    ).FirstOrDefault();
                            if (inventoryBaseItem == null)
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                            }
                            itemUUID = inventoryBaseItem.UUID;
                        }
                        Client.Self.PlayGesture(itemUUID);
                    };
                    break;
                case ScriptKeys.GETANIMATIONS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> csv = new List<string>();
                        Client.Self.SignaledAnimations.ForEach(
                            o =>
                                csv.AddRange(new List<string>
                                {
                                    o.Key.ToString(),
                                    o.Value.ToString(CultureInfo.InvariantCulture)
                                }));
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.RESTARTREGION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        if (!Client.Network.CurrentSim.IsEstateManager)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_LAND_RIGHTS));
                        }
                        int delay;
                        if (
                            !int.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DELAY)), message))
                                    .ToLowerInvariant(), out delay))
                        {
                            delay = LINDEN_CONSTANTS.ESTATE.REGION_RESTART_DELAY;
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.RESTART:
                                // Manually override Client.Estate.RestartRegion();
                                Client.Estate.EstateOwnerMessage(
                                    LINDEN_CONSTANTS.ESTATE.MESSAGES.REGION_RESTART_MESSAGE,
                                    delay.ToString(CultureInfo.InvariantCulture));
                                break;
                            case Action.CANCEL:
                                Client.Estate.CancelRestart();
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_RESTART_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.SETREGIONDEBUG:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        if (!Client.Network.CurrentSim.IsEstateManager)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_LAND_RIGHTS));
                        }
                        bool scripts;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SCRIPTS)),
                                        message))
                                    .ToLowerInvariant(), out scripts))
                        {
                            scripts = false;
                        }
                        bool collisions;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.COLLISIONS)),
                                        message))
                                    .ToLowerInvariant(), out collisions))
                        {
                            collisions = false;
                        }
                        bool physics;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PHYSICS)),
                                        message))
                                    .ToLowerInvariant(), out physics))
                        {
                            physics = false;
                        }
                        Client.Estate.SetRegionDebug(!scripts, !collisions, !physics);
                    };
                    break;
                case ScriptKeys.GETREGIONTOP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        if (!Client.Network.CurrentSim.IsEstateManager)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_LAND_RIGHTS));
                        }
                        Dictionary<UUID, EstateTask> topTasks = new Dictionary<UUID, EstateTask>();
                        switch (
                            wasGetEnumValueFromDescription<Type>(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)), message))
                                    .ToLowerInvariant()))
                        {
                            case Type.SCRIPTS:
                                ManualResetEvent TopScriptsReplyEvent = new ManualResetEvent(false);
                                EventHandler<TopScriptsReplyEventArgs> TopScriptsReplyEventHandler = (sender, args) =>
                                {
                                    topTasks =
                                        args.Tasks.OrderByDescending(o => o.Value.Score)
                                            .ToDictionary(o => o.Key, o => o.Value);
                                    TopScriptsReplyEvent.Set();
                                };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.TopScriptsReply += TopScriptsReplyEventHandler;
                                    Client.Estate.RequestTopScripts();
                                    if (!TopScriptsReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Estate.TopScriptsReply -= TopScriptsReplyEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_TOP_SCRIPTS));
                                    }
                                    Client.Estate.TopScriptsReply -= TopScriptsReplyEventHandler;
                                }
                                break;
                            case Type.COLLIDERS:
                                ManualResetEvent TopCollidersReplyEvent = new ManualResetEvent(false);
                                EventHandler<TopCollidersReplyEventArgs> TopCollidersReplyEventHandler =
                                    (sender, args) =>
                                    {
                                        topTasks =
                                            args.Tasks.OrderByDescending(o => o.Value.Score)
                                                .ToDictionary(o => o.Key, o => o.Value);
                                        TopCollidersReplyEvent.Set();
                                    };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.TopCollidersReply += TopCollidersReplyEventHandler;
                                    Client.Estate.RequestTopScripts();
                                    if (!TopCollidersReplyEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Estate.TopCollidersReply -= TopCollidersReplyEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_TOP_SCRIPTS));
                                    }
                                    Client.Estate.TopCollidersReply -= TopCollidersReplyEventHandler;
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_TOP_TYPE));
                        }
                        int amount;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AMOUNT)), message)),
                                out amount))
                        {
                            amount = topTasks.Count;
                        }
                        List<string> data = new List<string>(topTasks.Take(amount).Select(o => new[]
                        {
                            o.Value.Score.ToString(CultureInfo.InvariantCulture),
                            o.Value.TaskName,
                            o.Key.ToString(),
                            o.Value.OwnerName,
                            o.Value.Position.ToString()
                        }).SelectMany(o => o));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.SETESTATELIST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        if (!Client.Network.CurrentSim.IsEstateManager)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_LAND_RIGHTS));
                        }
                        bool allEstates;
                        if (
                            !bool.TryParse(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ALL)),
                                    message)),
                                out allEstates))
                        {
                            allEstates = false;
                        }
                        UUID targetUUID;
                        switch (
                            wasGetEnumValueFromDescription<Type>(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)), message))
                                    .ToLowerInvariant()))
                        {
                            case Type.BAN:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out targetUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                                    ref targetUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                                }
                                switch (
                                    wasGetEnumValueFromDescription<Action>(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                            .ToLowerInvariant()))
                                {
                                    case Action.ADD:
                                        Client.Estate.BanUser(targetUUID, allEstates);
                                        break;
                                    case Action.REMOVE:
                                        Client.Estate.UnbanUser(targetUUID, allEstates);
                                        break;
                                    default:
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ESTATE_LIST_ACTION));
                                }
                                break;
                            case Type.GROUP:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)),
                                                message)),
                                        out targetUUID) && !GroupNameToUUID(
                                            wasInput(
                                                wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)),
                                                    message)),
                                            Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref targetUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                switch (
                                    wasGetEnumValueFromDescription<Action>(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                            .ToLowerInvariant()))
                                {
                                    case Action.ADD:
                                        Client.Estate.AddAllowedGroup(targetUUID, allEstates);
                                        break;
                                    case Action.REMOVE:
                                        Client.Estate.RemoveAllowedGroup(targetUUID, allEstates);
                                        break;
                                    default:
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ESTATE_LIST_ACTION));
                                }
                                break;
                            case Type.USER:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out targetUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                                    ref targetUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                                }
                                switch (
                                    wasGetEnumValueFromDescription<Action>(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                            .ToLowerInvariant()))
                                {
                                    case Action.ADD:
                                        Client.Estate.AddAllowedUser(targetUUID, allEstates);
                                        break;
                                    case Action.REMOVE:
                                        Client.Estate.RemoveAllowedUser(targetUUID, allEstates);
                                        break;
                                    default:
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ESTATE_LIST_ACTION));
                                }
                                break;
                            case Type.MANAGER:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out targetUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                                    ref targetUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                                }
                                switch (
                                    wasGetEnumValueFromDescription<Action>(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                            .ToLowerInvariant()))
                                {
                                    case Action.ADD:
                                        Client.Estate.AddEstateManager(targetUUID, allEstates);
                                        break;
                                    case Action.REMOVE:
                                        Client.Estate.RemoveEstateManager(targetUUID, allEstates);
                                        break;
                                    default:
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ESTATE_LIST_ACTION));
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ESTATE_LIST));
                        }
                    };
                    break;
                case ScriptKeys.GETESTATELIST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        if (!Client.Network.CurrentSim.IsEstateManager)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_LAND_RIGHTS));
                        }
                        List<UUID> estateList = new List<UUID>();
                        wasAdaptiveAlarm EstateListReceivedAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
                        switch (
                            wasGetEnumValueFromDescription<Type>(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)), message))
                                    .ToLowerInvariant()))
                        {
                            case Type.BAN:
                                EventHandler<EstateBansReplyEventArgs> EstateBansReplyEventHandler = (sender, args) =>
                                {
                                    EstateListReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                    if (args.Count.Equals(0))
                                    {
                                        EstateListReceivedAlarm.Signal.Set();
                                        return;
                                    }
                                    estateList.AddRange(args.Banned);
                                };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.EstateBansReply += EstateBansReplyEventHandler;
                                    Client.Estate.RequestInfo();
                                    if (!EstateListReceivedAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Estate.EstateBansReply -= EstateBansReplyEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST));
                                    }
                                    Client.Estate.EstateBansReply -= EstateBansReplyEventHandler;
                                }
                                break;
                            case Type.GROUP:
                                EventHandler<EstateGroupsReplyEventArgs> EstateGroupsReplyEvenHandler =
                                    (sender, args) =>
                                    {
                                        EstateListReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                        if (args.Count.Equals(0))
                                        {
                                            EstateListReceivedAlarm.Signal.Set();
                                            return;
                                        }
                                        estateList.AddRange(args.AllowedGroups);
                                    };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.EstateGroupsReply += EstateGroupsReplyEvenHandler;
                                    Client.Estate.RequestInfo();
                                    if (!EstateListReceivedAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Estate.EstateGroupsReply -= EstateGroupsReplyEvenHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST));
                                    }
                                    Client.Estate.EstateGroupsReply -= EstateGroupsReplyEvenHandler;
                                }
                                break;
                            case Type.MANAGER:
                                EventHandler<EstateManagersReplyEventArgs> EstateManagersReplyEventHandler =
                                    (sender, args) =>
                                    {
                                        EstateListReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                        if (args.Count.Equals(0))
                                        {
                                            EstateListReceivedAlarm.Signal.Set();
                                            return;
                                        }
                                        estateList.AddRange(args.Managers);
                                    };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.EstateManagersReply += EstateManagersReplyEventHandler;
                                    Client.Estate.RequestInfo();
                                    if (!EstateListReceivedAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Estate.EstateManagersReply -= EstateManagersReplyEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST));
                                    }
                                    Client.Estate.EstateManagersReply -= EstateManagersReplyEventHandler;
                                }
                                break;
                            case Type.USER:
                                EventHandler<EstateUsersReplyEventArgs> EstateUsersReplyEventHandler =
                                    (sender, args) =>
                                    {
                                        EstateListReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                        if (args.Count.Equals(0))
                                        {
                                            EstateListReceivedAlarm.Signal.Set();
                                            return;
                                        }
                                        estateList.AddRange(args.AllowedUsers);
                                    };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.EstateUsersReply += EstateUsersReplyEventHandler;
                                    Client.Estate.RequestInfo();
                                    if (!EstateListReceivedAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Estate.EstateUsersReply -= EstateUsersReplyEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST));
                                    }
                                    Client.Estate.EstateUsersReply -= EstateUsersReplyEventHandler;
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ESTATE_LIST));
                        }
                        List<string> data = new List<string>(estateList.ConvertAll(o => o.ToString()));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETAVATARDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Avatar avatar =
                            GetAvatars(range, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT)
                                .FirstOrDefault(o => o.ID.Equals(agentUUID));
                        if (avatar == null)
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AVATAR_NOT_IN_RANGE));
                        wasAdaptiveAlarm ProfileDataReceivedAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
                        object LockObject = new object();
                        EventHandler<AvatarInterestsReplyEventArgs> AvatarInterestsReplyEventHandler = (sender, args) =>
                        {
                            ProfileDataReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                            avatar.ProfileInterests = args.Interests;
                        };
                        EventHandler<AvatarPropertiesReplyEventArgs> AvatarPropertiesReplyEventHandler =
                            (sender, args) =>
                            {
                                ProfileDataReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                avatar.ProfileProperties = args.Properties;
                            };
                        EventHandler<AvatarGroupsReplyEventArgs> AvatarGroupsReplyEventHandler = (sender, args) =>
                        {
                            ProfileDataReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                            lock (LockObject)
                            {
                                avatar.Groups.AddRange(args.Groups.Select(o => o.GroupID));
                            }
                        };
                        EventHandler<AvatarPicksReplyEventArgs> AvatarPicksReplyEventHandler =
                            (sender, args) => ProfileDataReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                        EventHandler<AvatarClassifiedReplyEventArgs> AvatarClassifiedReplyEventHandler =
                            (sender, args) => ProfileDataReceivedAlarm.Alarm(Configuration.DATA_TIMEOUT);
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarInterestsReply += AvatarInterestsReplyEventHandler;
                            Client.Avatars.AvatarPropertiesReply += AvatarPropertiesReplyEventHandler;
                            Client.Avatars.AvatarGroupsReply += AvatarGroupsReplyEventHandler;
                            Client.Avatars.AvatarPicksReply += AvatarPicksReplyEventHandler;
                            Client.Avatars.AvatarClassifiedReply += AvatarClassifiedReplyEventHandler;
                            Client.Avatars.RequestAvatarProperties(agentUUID);
                            Client.Avatars.RequestAvatarPicks(agentUUID);
                            Client.Avatars.RequestAvatarClassified(agentUUID);
                            if (!ProfileDataReceivedAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Avatars.AvatarInterestsReply -= AvatarInterestsReplyEventHandler;
                                Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesReplyEventHandler;
                                Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                                Client.Avatars.AvatarPicksReply -= AvatarPicksReplyEventHandler;
                                Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedReplyEventHandler;
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_AVATAR_DATA));
                            }
                            Client.Avatars.AvatarInterestsReply -= AvatarInterestsReplyEventHandler;
                            Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesReplyEventHandler;
                            Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                            Client.Avatars.AvatarPicksReply -= AvatarPicksReplyEventHandler;
                            Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedReplyEventHandler;
                        }
                        List<string> data = new List<string>(GetStructuredData(avatar,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETAVATARPOSITIONS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        Entity entity = wasGetEnumValueFromDescription<Entity>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)), message))
                                .ToLowerInvariant());
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Parcel parcel = null;
                        switch (entity)
                        {
                            case Entity.REGION:
                                break;
                            case Entity.PARCEL:
                                if (
                                    !GetParcelAtPosition(simulator, position, ref parcel))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                        }
                        List<string> csv = new List<string>();
                        Dictionary<UUID, Vector3> avatarPositions = new Dictionary<UUID, Vector3>();
                        simulator.AvatarPositions.ForEach(o => avatarPositions.Add(o.Key, o.Value));
                        foreach (KeyValuePair<UUID, Vector3> p in avatarPositions)
                        {
                            string name = string.Empty;
                            if (
                                !AgentUUIDToName(p.Key, Configuration.SERVICES_TIMEOUT,
                                    ref name)) continue;
                            switch (entity)
                            {
                                case Entity.REGION:
                                    break;
                                case Entity.PARCEL:
                                    if (parcel == null) return;
                                    Parcel avatarParcel = null;
                                    if (!GetParcelAtPosition(simulator, p.Value, ref avatarParcel))
                                        continue;
                                    if (!avatarParcel.LocalID.Equals(parcel.LocalID)) continue;
                                    break;
                            }
                            csv.Add(name);
                            csv.Add(p.Key.ToString());
                            csv.Add(p.Value.ToString());
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETMAPAVATARPOSITIONS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        if (string.IsNullOrEmpty(region))
                        {
                            region = Client.Network.CurrentSim.Name;
                        }
                        ulong regionHandle = 0;
                        ManualResetEvent GridRegionEvent = new ManualResetEvent(false);
                        EventHandler<GridRegionEventArgs> GridRegionEventHandler = (sender, args) =>
                        {
                            if (!args.Region.Name.Equals(region, StringComparison.InvariantCultureIgnoreCase))
                                return;
                            regionHandle = args.Region.RegionHandle;
                            GridRegionEvent.Set();
                        };
                        lock (ClientInstanceGridLock)
                        {
                            Client.Grid.GridRegion += GridRegionEventHandler;
                            Client.Grid.RequestMapRegion(region, GridLayerType.Objects);
                            if (!GridRegionEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Grid.GridRegion -= GridRegionEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_REGION));
                            }
                            Client.Grid.GridRegion -= GridRegionEventHandler;
                        }
                        if (regionHandle.Equals(0))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        HashSet<MapItem> mapItems =
                            new HashSet<MapItem>(Client.Grid.MapItems(regionHandle, GridItemType.AgentLocations,
                                GridLayerType.Objects, Configuration.SERVICES_TIMEOUT));
                        if (mapItems.Count.Equals(0))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_MAP_ITEMS_FOUND));
                        }
                        List<string> data =
                            new List<string>(mapItems.AsParallel()
                                .Where(o => (o as MapAgentLocation) != null)
                                .Select(o => new[]
                                {
                                    ((MapAgentLocation) o).AvatarCount.ToString(CultureInfo.InvariantCulture),
                                    new Vector3(o.LocalX, o.LocalY, 0).ToString()
                                }).SelectMany(o => o));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETSELFDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> data = new List<string>(GetStructuredData(Client.Self,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.DISPLAYNAME:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string previous = string.Empty;
                        Client.Avatars.GetDisplayNames(new List<UUID> {Client.Self.AgentID},
                            (succeded, names, IDs) =>
                            {
                                if (!succeded || names.Length < 1)
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.FAILED_TO_GET_DISPLAY_NAME));
                                }
                                previous = names[0].DisplayName;
                            });
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.GET:
                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), previous);
                                break;
                            case Action.SET:
                                string name =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                            message));
                                if (string.IsNullOrEmpty(name))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_NAME_PROVIDED));
                                }
                                bool succeeded = true;
                                ManualResetEvent SetDisplayNameEvent = new ManualResetEvent(false);
                                EventHandler<SetDisplayNameReplyEventArgs> SetDisplayNameEventHandler =
                                    (sender, args) =>
                                    {
                                        succeeded = args.Status.Equals(LINDEN_CONSTANTS.AVATARS.SET_DISPLAY_NAME_SUCCESS);
                                        SetDisplayNameEvent.Set();
                                    };
                                lock (ClientInstanceSelfLock)
                                {
                                    Client.Self.SetDisplayNameReply += SetDisplayNameEventHandler;
                                    Client.Self.SetDisplayName(previous, name);
                                    if (!SetDisplayNameEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Self.SetDisplayNameReply -= SetDisplayNameEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_WAITING_FOR_ESTATE_LIST));
                                    }
                                    Client.Self.SetDisplayNameReply -= SetDisplayNameEventHandler;
                                }
                                if (!succeeded)
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_SET_DISPLAY_NAME));
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.GETINVENTORYOFFERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        object LockObject = new object();
                        List<string> csv = new List<string>();
                        lock (InventoryOffersLock)
                        {
                            Parallel.ForEach(InventoryOffers, o =>
                            {
                                List<string> name =
                                    new List<string>(
                                        GetAvatarNames(o.Key.Offer.FromAgentName));
                                lock (LockObject)
                                {
                                    csv.AddRange(new[]
                                    {wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME), name.First()});
                                    csv.AddRange(new[]
                                    {wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME), name.Last()});
                                    csv.AddRange(new[]
                                    {
                                        wasGetDescriptionFromEnumValue(ScriptKeys.TYPE),
                                        o.Key.AssetType.ToString()
                                    });
                                    csv.AddRange(new[]
                                    {wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE), o.Key.Offer.Message});
                                    csv.AddRange(new[]
                                    {
                                        wasGetDescriptionFromEnumValue(ScriptKeys.SESSION),
                                        o.Key.Offer.IMSessionID.ToString()
                                    });
                                }
                            });
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.REPLYTOINVENTORYOFFER:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID session;
                        if (
                            !UUID.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION)),
                                        message)),
                                out session))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_SESSION_SPECIFIED));
                        }
                        lock (InventoryOffersLock)
                        {
                            if (!InventoryOffers.AsParallel().Any(o => o.Key.Offer.IMSessionID.Equals(session)))
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_OFFER_NOT_FOUND));
                            }
                        }
                        KeyValuePair<InventoryObjectOfferedEventArgs, ManualResetEvent> offer;
                        lock (InventoryOffersLock)
                        {
                            offer =
                                InventoryOffers.AsParallel()
                                    .FirstOrDefault(o => o.Key.Offer.IMSessionID.Equals(session));
                        }
                        UUID folderUUID;
                        string folder =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FOLDER)),
                                message));
                        if (string.IsNullOrEmpty(folder) || !UUID.TryParse(folder, out folderUUID))
                        {
                            folderUUID =
                                Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(offer.Key.AssetType)]
                                    .Data.UUID;
                        }
                        if (folderUUID.Equals(UUID.Zero))
                        {
                            InventoryBase inventoryBaseItem =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, folder
                                    ).FirstOrDefault();
                            InventoryItem item = inventoryBaseItem as InventoryItem;
                            if (item != null && item.AssetType.Equals(AssetType.Folder))
                            {
                                folderUUID = inventoryBaseItem.UUID;
                            }
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.ACCEPT:
                                lock (InventoryOffersLock)
                                {
                                    if (!folderUUID.Equals(UUID.Zero))
                                    {
                                        offer.Key.FolderID = folderUUID;
                                    }
                                    offer.Key.Accept = true;
                                    offer.Value.Set();
                                    SaveInventoryOffersState.Invoke();
                                }
                                break;
                            case Action.DECLINE:
                                lock (InventoryOffersLock)
                                {
                                    offer.Key.Accept = false;
                                    offer.Value.Set();
                                    SaveInventoryOffersState.Invoke();
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.GETFRIENDSLIST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_FRIENDSHIP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> csv = new List<string>();
                        Client.Friends.FriendList.ForEach(o =>
                        {
                            csv.Add(o.Name);
                            csv.Add(o.UUID.ToString());
                        });
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETFRIENDSHIPREQUESTS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_FRIENDSHIP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        List<string> csv = new List<string>();
                        Client.Friends.FriendRequests.ForEach(o =>
                        {
                            string name = string.Empty;
                            if (
                                !AgentUUIDToName(o.Key, Configuration.SERVICES_TIMEOUT,
                                    ref name))
                            {
                                return;
                            }
                            csv.Add(name);
                            csv.Add(o.Key.ToString());
                        });
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.REPLYTOFRIENDSHIPREQUEST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_FRIENDSHIP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        UUID session = UUID.Zero;
                        Client.Friends.FriendRequests.ForEach(o =>
                        {
                            if (o.Key.Equals(agentUUID))
                            {
                                session = o.Value;
                            }
                        });
                        if (session.Equals(UUID.Zero))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_FRIENDSHIP_OFFER_FOUND));
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.ACCEPT:
                                Client.Friends.AcceptFriendship(agentUUID, session);
                                break;
                            case Action.DECLINE:
                                Client.Friends.DeclineFriendship(agentUUID, session);
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.GETFRIENDDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_FRIENDSHIP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        FriendInfo friend = Client.Friends.FriendList.Find(o => o.UUID.Equals(agentUUID));
                        if (friend == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.FRIEND_NOT_FOUND));
                        }
                        List<string> data = new List<string>(GetStructuredData(friend,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.OFFERFRIENDSHIP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_FRIENDSHIP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        FriendInfo friend = Client.Friends.FriendList.Find(o => o.UUID.Equals(agentUUID));
                        if (friend != null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_ALREADY_FRIEND));
                        }
                        Client.Friends.OfferFriendship(agentUUID,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE)),
                                message)));
                    };
                    break;
                case ScriptKeys.TERMINATEFRIENDSHIP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_FRIENDSHIP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        FriendInfo friend = Client.Friends.FriendList.Find(o => o.UUID.Equals(agentUUID));
                        if (friend == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.FRIEND_NOT_FOUND));
                        }
                        Client.Friends.TerminateFriendship(agentUUID);
                    };
                    break;
                case ScriptKeys.GRANTFRIENDRIGHTS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_FRIENDSHIP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        FriendInfo friend = Client.Friends.FriendList.Find(o => o.UUID.Equals(agentUUID));
                        if (friend == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.FRIEND_NOT_FOUND));
                        }
                        int rights = 0;
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RIGHTS)),
                                message))),
                            o =>
                                Parallel.ForEach(
                                    typeof (FriendRights).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                    q => { rights |= ((int) q.GetValue(null)); }));
                        Client.Friends.GrantRights(agentUUID, (FriendRights) rights);
                    };
                    break;
                case ScriptKeys.MAPFRIEND:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_FRIENDSHIP))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT, ref agentUUID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                        }
                        FriendInfo friend = Client.Friends.FriendList.Find(o => o.UUID.Equals(agentUUID));
                        if (friend == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.FRIEND_NOT_FOUND));
                        }
                        if (!friend.CanSeeThemOnMap)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.FRIEND_DOES_NOT_ALLOW_MAPPING));
                        }
                        ulong regionHandle = 0;
                        Vector3 position = Vector3.Zero;
                        ManualResetEvent FriendFoundEvent = new ManualResetEvent(false);
                        bool offline = false;
                        EventHandler<FriendFoundReplyEventArgs> FriendFoundEventHandler = (sender, args) =>
                        {
                            if (args.RegionHandle.Equals(0))
                            {
                                offline = true;
                                FriendFoundEvent.Set();
                                return;
                            }
                            regionHandle = args.RegionHandle;
                            position = args.Location;
                            FriendFoundEvent.Set();
                        };
                        lock (ClientInstanceFriendsLock)
                        {
                            Client.Friends.FriendFoundReply += FriendFoundEventHandler;
                            Client.Friends.MapFriend(agentUUID);
                            if (!FriendFoundEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Friends.FriendFoundReply -= FriendFoundEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_MAPPING_FRIEND));
                            }
                            Client.Friends.FriendFoundReply -= FriendFoundEventHandler;
                        }
                        if (offline)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.FRIEND_OFFLINE));
                        }
                        UUID parcelUUID = Client.Parcels.RequestRemoteParcelID(position, regionHandle, UUID.Zero);
                        ManualResetEvent ParcelInfoEvent = new ManualResetEvent(false);
                        string regionName = string.Empty;
                        EventHandler<ParcelInfoReplyEventArgs> ParcelInfoEventHandler = (sender, args) =>
                        {
                            regionName = args.Parcel.SimName;
                            ParcelInfoEvent.Set();
                        };
                        lock (ClientInstanceParcelsLock)
                        {
                            Client.Parcels.ParcelInfoReply += ParcelInfoEventHandler;
                            Client.Parcels.RequestParcelInfo(parcelUUID);
                            if (!ParcelInfoEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                            {
                                Client.Parcels.ParcelInfoReply -= ParcelInfoEventHandler;
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PARCELS));
                            }
                            Client.Parcels.ParcelInfoReply -= ParcelInfoEventHandler;
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                            wasEnumerableToCSV(new[] {regionName, position.ToString()}));
                    };
                    break;
                case ScriptKeys.GETOBJECTPERMISSIONS:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_AN_OBJECT));
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.PERMISSIONS),
                            wasPermissionsToString(primitive.Properties.Permissions));
                    };
                    break;
                case ScriptKeys.SETOBJECTPERMISSIONS:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_AN_OBJECT));
                        }
                        string itemPermissions =
                            wasInput(
                                wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PERMISSIONS)), message));
                        if (string.IsNullOrEmpty(itemPermissions))
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.NO_PERMISSIONS_PROVIDED));
                        }
                        OpenMetaverse.Permissions permissions = wasStringToPermissions(itemPermissions);
                        Client.Objects.SetPermissions(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            PermissionWho.Base, permissions.BaseMask, true);
                        Client.Objects.SetPermissions(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            PermissionWho.Owner, permissions.OwnerMask, true);
                        Client.Objects.SetPermissions(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            PermissionWho.Group, permissions.GroupMask, true);
                        Client.Objects.SetPermissions(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            PermissionWho.Everyone, permissions.EveryoneMask, true);
                        Client.Objects.SetPermissions(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            PermissionWho.NextOwner, permissions.NextOwnerMask, true);
                    };
                    break;
                case ScriptKeys.OBJECTDEED:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_AN_OBJECT));
                        }
                        Client.Objects.DeedObject(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, groupUUID);
                    };
                    break;
                case ScriptKeys.SETOBJECTGROUP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_AN_OBJECT));
                        }
                        Client.Objects.SetObjectsGroup(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            groupUUID);
                    };
                    break;
                case ScriptKeys.SETOBJECTSALEINFO:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        int price;
                        if (
                            !int.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PRICE)), message)),
                                out price))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_PRICE));
                        }
                        if (price < 0)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_PRICE));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_AN_OBJECT));
                        }
                        FieldInfo saleTypeInfo = typeof (SaleType).GetFields(BindingFlags.Public |
                                                                             BindingFlags.Static)
                            .AsParallel().FirstOrDefault(o =>
                                o.Name.Equals(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                            message)),
                                    StringComparison.Ordinal));
                        Client.Objects.SetSaleInfo(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, saleTypeInfo != null
                                ? (SaleType)
                                    saleTypeInfo.GetValue(null)
                                : SaleType.Copy, price);
                    };
                    break;
                case ScriptKeys.SETOBJECTPOSITION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_AN_OBJECT));
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_POSITION));
                        }
                        Client.Objects.SetPosition(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, position);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVEPOSITION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_POSITION));
                        }
                        Client.Objects.SetPosition(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, position, true);
                    };
                    break;
                case ScriptKeys.SETOBJECTROTATION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_AN_OBJECT));
                        }
                        Quaternion rotation;
                        if (
                            !Quaternion.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION)),
                                        message)),
                                out rotation))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_ROTATION));
                        }
                        Client.Objects.SetRotation(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, rotation);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVEROTATION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        Quaternion rotation;
                        if (
                            !Quaternion.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION)),
                                        message)),
                                out rotation))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_ROTATION));
                        }
                        Client.Objects.SetRotation(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, rotation, true);
                    };
                    break;
                case ScriptKeys.SETOBJECTSCALE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        bool uniform;
                        if (
                            !bool.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.UNIFORM)), message)),
                                out uniform))
                        {
                            uniform = true;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_AN_OBJECT));
                        }
                        Vector3 scale;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SCALE)),
                                        message)),
                                out scale))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_SCALE));
                        }
                        Client.Objects.SetScale(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, scale, false, uniform);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVESCALE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        bool uniform;
                        if (
                            !bool.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.UNIFORM)), message)),
                                out uniform))
                        {
                            uniform = true;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        Vector3 scale;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SCALE)),
                                        message)),
                                out scale))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_SCALE));
                        }
                        Client.Objects.SetScale(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, scale, true, uniform);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVENAME:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_NAME_PROVIDED));
                        }
                        Client.Objects.SetName(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, name);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVEDESCRIPTION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }
                        string description =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                    message));
                        if (string.IsNullOrEmpty(description))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_DESCRIPTION_PROVIDED));
                        }
                        Client.Objects.SetDescription(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, description);
                    };
                    break;
                case ScriptKeys.CHANGEAPPEARANCE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_GROOMING))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string folder =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FOLDER)),
                                message));
                        if (string.IsNullOrEmpty(folder))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_FOLDER_SPECIFIED));
                        }
                        // Check for items that can be worn.
                        List<InventoryBase> items =
                            GetInventoryFolderContents<InventoryBase>(Client.Inventory.Store.RootNode, folder)
                                .AsParallel().Where(CanBeWorn)
                                .ToList();
                        if (items.Count.Equals(0))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_EQUIPABLE_ITEMS));
                        }
                        // Now remove the current outfit items.
                        Client.Inventory.Store.GetContents(
                            Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)).FindAll(
                                o => CanBeWorn(o) && ((InventoryItem) o).AssetType.Equals(AssetType.Link))
                            .ForEach(p =>
                            {
                                InventoryItem item = ResolveItemLink(p as InventoryItem);
                                if (item is InventoryWearable)
                                {
                                    if (!IsBodyPart(item))
                                    {
                                        UnWear(item);
                                        return;
                                    }
                                    if (items.AsParallel().Any(q =>
                                    {
                                        InventoryWearable i = q as InventoryWearable;
                                        return i != null &&
                                               ((InventoryWearable) item).WearableType.Equals(i.WearableType);
                                    })) UnWear(item);
                                    return;
                                }
                                if (item is InventoryAttachment || item is InventoryObject)
                                {
                                    Detach(item);
                                }
                            });
                        // And equip the specified folder.
                        Parallel.ForEach(items, o =>
                        {
                            InventoryItem item = o as InventoryItem;
                            if (item is InventoryWearable)
                            {
                                Wear(item, false);
                                return;
                            }
                            if (item is InventoryAttachment || item is InventoryObject)
                            {
                                Attach(item, AttachmentPoint.Default, false);
                            }
                        });
                        // And rebake.
                        RebakeTimer.Change(Configuration.REBAKE_DELAY, 0);
                    };
                    break;
                case ScriptKeys.PLAYSOUND:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        float gain;
                        if (!float.TryParse(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.GAIN)),
                                message)),
                            out gain))
                        {
                            gain = 1;
                        }
                        UUID itemUUID;
                        string item =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                message));
                        if (!UUID.TryParse(item, out itemUUID))
                        {
                            InventoryBase inventoryBaseItem =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                    ).FirstOrDefault();
                            if (inventoryBaseItem == null)
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVENTORY_ITEM_NOT_FOUND));
                            }
                            itemUUID = inventoryBaseItem.UUID;
                        }
                        Client.Sound.SendSoundTrigger(itemUUID, position, gain);
                    };
                    break;
                case ScriptKeys.TERRAIN:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        byte[] data = null;
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                message))
                                .ToLowerInvariant()))
                        {
                            case Action.GET:
                                ManualResetEvent[] DownloadTerrainEvents =
                                {
                                    new ManualResetEvent(false),
                                    new ManualResetEvent(false)
                                };
                                EventHandler<InitiateDownloadEventArgs> InitiateDownloadEventHandler =
                                    (sender, args) =>
                                    {
                                        Client.Assets.RequestAssetXfer(args.SimFileName, false, false, UUID.Zero,
                                            AssetType.Unknown, false);
                                        DownloadTerrainEvents[0].Set();
                                    };
                                EventHandler<XferReceivedEventArgs> XferReceivedEventHandler = (sender, args) =>
                                {
                                    data = args.Xfer.AssetData;
                                    DownloadTerrainEvents[1].Set();
                                };
                                lock (ClientInstanceAssetsLock)
                                {
                                    Client.Assets.InitiateDownload += InitiateDownloadEventHandler;
                                    Client.Assets.XferReceived += XferReceivedEventHandler;
                                    Client.Estate.EstateOwnerMessage("terrain", new List<string>
                                    {
                                        "download filename",
                                        simulator.Name
                                    });
                                    if (!WaitHandle.WaitAll(DownloadTerrainEvents.Select(o => (WaitHandle) o).ToArray(),
                                        Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Assets.InitiateDownload -= InitiateDownloadEventHandler;
                                        Client.Assets.XferReceived -= XferReceivedEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_DOWNLOADING_ASSET));
                                    }
                                    Client.Assets.InitiateDownload -= InitiateDownloadEventHandler;
                                    Client.Assets.XferReceived -= XferReceivedEventHandler;
                                }
                                if (data == null || !data.Length.Equals(0))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EMPTY_ASSET_DATA));
                                }
                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), Convert.ToBase64String(data));
                                break;
                            case Action.SET:
                                try
                                {
                                    data = Convert.FromBase64String(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                                message)));
                                }
                                catch (Exception)
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.INVALID_ASSET_DATA));
                                }
                                if (!data.Length.Equals(0))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.EMPTY_ASSET_DATA));
                                }
                                ManualResetEvent AssetUploadEvent = new ManualResetEvent(false);
                                EventHandler<AssetUploadEventArgs> AssetUploadEventHandler = (sender, args) =>
                                {
                                    if (args.Upload.Transferred.Equals(args.Upload.Size))
                                    {
                                        AssetUploadEvent.Set();
                                    }
                                };
                                lock (ClientInstanceAssetsLock)
                                {
                                    Client.Assets.UploadProgress += AssetUploadEventHandler;
                                    Client.Estate.UploadTerrain(data, simulator.Name);
                                    if (!AssetUploadEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Assets.UploadProgress -= AssetUploadEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_UPLOADING_ASSET));
                                    }
                                    Client.Assets.UploadProgress -= AssetUploadEventHandler;
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.GETTERRAINHEIGHT:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_LAND))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.REGION_NOT_FOUND));
                        }
                        Vector3 southwest;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SOUTHWEST)),
                                        message)),
                                out southwest))
                        {
                            southwest = new Vector3(0, 0, 0);
                        }
                        Vector3 northeast;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NORTHEAST)),
                                        message)),
                                out northeast))
                        {
                            northeast = new Vector3(255, 255, 0);
                        }

                        int x1 = Convert.ToInt32(southwest.X);
                        int y1 = Convert.ToInt32(southwest.Y);
                        int x2 = Convert.ToInt32(northeast.X);
                        int y2 = Convert.ToInt32(northeast.Y);

                        if (x1 > x2)
                        {
                            wasXORSwap(ref x1, ref x2);
                        }
                        if (y1 > y2)
                        {
                            wasXORSwap(ref y1, ref y2);
                        }

                        int sx = x2 - x1 + 1;
                        int sy = y2 - y1 + 1;

                        float[] csv = new float[sx*sy];
                        Parallel.ForEach(Enumerable.Range(x1, sx), x => Parallel.ForEach(Enumerable.Range(y1, sy), y =>
                        {
                            float height;
                            csv[sx*x + y] = simulator.TerrainHeightAtPoint(x, y, out height)
                                ? height
                                : -1;
                        }));

                        if (!csv.Length.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv.Select(o => o.ToString(CultureInfo.InvariantCulture))));
                        }
                    };
                    break;
                case ScriptKeys.CROUCH:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Action action =
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                    .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.START:
                            case Action.STOP:
                                if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                                {
                                    Client.Self.Stand();
                                }
                                // stop all non-built-in animations
                                List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                                    BindingFlags.Public |
                                    BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                                Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                                {
                                    if (!lindenAnimations.Contains(o))
                                        Client.Self.AnimationStop(o, true);
                                });
                                Client.Self.Crouch(action.Equals(Action.START));
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.FLY_ACTION_START_OR_STOP));
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.JUMP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_MOVEMENT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Action action =
                            wasGetEnumValueFromDescription<Action>(wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.START:
                            case Action.STOP:
                                if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                                {
                                    Client.Self.Stand();
                                }
                                // stop all non-built-in animations
                                List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                                    BindingFlags.Public |
                                    BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                                Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                                {
                                    if (!lindenAnimations.Contains(o))
                                        Client.Self.AnimationStop(o, true);
                                });
                                Client.Self.Jump(action.Equals(Action.START));
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.FLY_ACTION_START_OR_STOP));
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.EXECUTE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_EXECUTE))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        string file =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FILE)),
                                message));
                        if (string.IsNullOrEmpty(file))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_EXECUTABLE_FILE_PROVIDED));
                        }
                        ProcessStartInfo p = new ProcessStartInfo(file,
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PARAMETER)), message)))
                        {
                            RedirectStandardOutput = true,
                            RedirectStandardError = true,
                            WindowStyle = ProcessWindowStyle.Normal,
                            UseShellExecute = false
                        };
                        StringBuilder stdout = new StringBuilder();
                        StringBuilder stderr = new StringBuilder();
                        ManualResetEvent[] StdEvent =
                        {
                            new ManualResetEvent(false),
                            new ManualResetEvent(false)
                        };
                        Process q;
                        try
                        {
                            q = Process.Start(p);
                        }
                        catch (Exception)
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_START_PROCESS));
                        }
                        q.OutputDataReceived += (sender, output) =>
                        {
                            if (output.Data == null)
                            {
                                StdEvent[0].Set();
                                return;
                            }
                            stdout.AppendLine(output.Data);
                        };
                        q.ErrorDataReceived += (sender, output) =>
                        {
                            if (output.Data == null)
                            {
                                StdEvent[1].Set();
                                return;
                            }
                            stderr.AppendLine(output.Data);
                        };
                        q.BeginErrorReadLine();
                        q.BeginOutputReadLine();
                        if (!q.WaitForExit(Configuration.SERVICES_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_WAITING_FOR_EXECUTION));
                        }
                        if (StdEvent[0].WaitOne(Configuration.SERVICES_TIMEOUT) && !stdout.Length.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), stdout.ToString());
                        }
                        if (StdEvent[1].WaitOne(Configuration.SERVICES_TIMEOUT) && !stderr.Length.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), stderr.ToString());
                        }
                    };
                    break;
                case ScriptKeys.CONFIGURATION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_SYSTEM))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Action action = wasGetEnumValueFromDescription<Action>(wasInput(
                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                            .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.READ:
                                try
                                {
                                    result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                        Configuration.Read(CORRADE_CONSTANTS.CONFIGURATION_FILE));
                                }
                                catch (Exception)
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_LOAD_CONFIGURATION));
                                }
                                break;
                            case Action.WRITE:
                                try
                                {
                                    Configuration.Write(CORRADE_CONSTANTS.CONFIGURATION_FILE, wasKeyValueGet(
                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                        message));
                                }
                                catch (Exception)
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_SAVE_CONFIGURATION));
                                }
                                break;
                            case Action.SET:
                            case Action.GET:
                                string path =
                                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATH)),
                                        message));
                                if (string.IsNullOrEmpty(path))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_PATH_PROVIDED));
                                }
                                XmlDocument conf = new XmlDocument();
                                try
                                {
                                    conf.LoadXml(Configuration.Read(CORRADE_CONSTANTS.CONFIGURATION_FILE));
                                }
                                catch (Exception)
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_LOAD_CONFIGURATION));
                                }
                                string data;
                                switch (action)
                                {
                                    case Action.GET:
                                        try
                                        {
                                            data = conf.SelectSingleNode(path).InnerXml;
                                        }
                                        catch (Exception)
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.INVALID_XML_PATH));
                                        }
                                        if (!string.IsNullOrEmpty(data))
                                        {
                                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), data);
                                        }
                                        break;
                                    case Action.SET:
                                        data =
                                            wasInput(
                                                wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                                    message));
                                        if (string.IsNullOrEmpty(data))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.NO_DATA_PROVIDED));
                                        }
                                        try
                                        {
                                            conf.SelectSingleNode(path).InnerXml = data;
                                        }
                                        catch (Exception)
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.INVALID_XML_PATH));
                                        }
                                        try
                                        {
                                            Configuration.Write(CORRADE_CONSTANTS.CONFIGURATION_FILE, conf);
                                        }
                                        catch (Exception)
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_SAVE_CONFIGURATION));
                                        }
                                        break;
                                }
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.CACHE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_SYSTEM))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        switch (wasGetEnumValueFromDescription<Action>(wasInput(
                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                            .ToLowerInvariant()))
                        {
                            case Action.PURGE:
                                Cache.Purge();
                                break;
                            case Action.SAVE:
                                SaveCorradeCache.Invoke();
                                break;
                            case Action.LOAD:
                                LoadCorradeCache.Invoke();
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                    };
                    break;
                case ScriptKeys.LOGOUT:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_SYSTEM))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        ConnectionSemaphores['u'].Set();
                    };
                    break;
                case ScriptKeys.RLV:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_SYSTEM))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                    message)).ToLowerInvariant()))
                        {
                            case Action.ENABLE:
                                EnableRLV = true;
                                break;
                            case Action.DISABLE:
                                EnableRLV = false;
                                lock (RLVRulesLock)
                                {
                                    RLVRules.Clear();
                                }
                                break;
                        }
                    };
                    break;
                case ScriptKeys.FILTER:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_FILTER))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                    message)).ToLowerInvariant()))
                        {
                            case Action.SET:
                                List<Filter> inputFilters = new List<Filter>();
                                string input =
                                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.INPUT)),
                                        message));
                                if (!string.IsNullOrEmpty(input))
                                {
                                    foreach (
                                        KeyValuePair<string, string> i in
                                            wasCSVToEnumerable(input).AsParallel().Select((o, p) => new {o, p})
                                                .GroupBy(q => q.p/2, q => q.o)
                                                .Select(o => o.ToList())
                                                .TakeWhile(o => o.Count%2 == 0)
                                                .ToDictionary(o => o.First(), p => p.Last()))
                                    {
                                        inputFilters.Add(wasGetEnumValueFromDescription<Filter>(i.Key));
                                        inputFilters.Add(wasGetEnumValueFromDescription<Filter>(i.Value));
                                    }
                                    lock (InputFiltersLock)
                                    {
                                        Configuration.INPUT_FILTERS = inputFilters;
                                    }
                                }
                                List<Filter> outputFilters = new List<Filter>();
                                string output =
                                    wasInput(wasKeyValueGet(
                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.OUTPUT)),
                                        message));
                                if (!string.IsNullOrEmpty(output))
                                {
                                    foreach (
                                        KeyValuePair<string, string> i in
                                            wasCSVToEnumerable(output).AsParallel().Select((o, p) => new {o, p})
                                                .GroupBy(q => q.p/2, q => q.o)
                                                .Select(o => o.ToList())
                                                .TakeWhile(o => o.Count%2 == 0)
                                                .ToDictionary(o => o.First(), p => p.Last()))
                                    {
                                        outputFilters.Add(wasGetEnumValueFromDescription<Filter>(i.Key));
                                        outputFilters.Add(wasGetEnumValueFromDescription<Filter>(i.Value));
                                    }
                                    lock (OutputFiltersLock)
                                    {
                                        Configuration.OUTPUT_FILTERS = outputFilters;
                                    }
                                }
                                break;
                            case Action.GET:
                                switch (wasGetEnumValueFromDescription<Type>(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                            message)).ToLowerInvariant()))
                                {
                                    case Type.INPUT:
                                        lock (InputFiltersLock)
                                        {
                                            if (!Configuration.INPUT_FILTERS.Count.Equals(0))
                                            {
                                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                                    wasEnumerableToCSV(Configuration.INPUT_FILTERS.Select(
                                                        o => wasGetDescriptionFromEnumValue(o))));
                                            }
                                        }
                                        break;
                                    case Type.OUTPUT:
                                        lock (OutputFiltersLock)
                                        {
                                            if (!Configuration.OUTPUT_FILTERS.Count.Equals(0))
                                            {
                                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                                    wasEnumerableToCSV(Configuration.OUTPUT_FILTERS.Select(
                                                        o => wasGetDescriptionFromEnumValue(o))));
                                            }
                                        }
                                        break;
                                }
                                break;
                        }
                    };
                    break;
                case ScriptKeys.INVENTORY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_INVENTORY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        Group configuredGroup =
                            Configuration.GROUPS.AsParallel().FirstOrDefault(
                                o => o.Name.Equals(group, StringComparison.Ordinal));
                        UUID groupUUID = UUID.Zero;
                        switch (!configuredGroup.Equals(default(Group)))
                        {
                            case true:
                                groupUUID = configuredGroup.UUID;
                                break;
                            default:
                                if (!GroupNameToUUID(group, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                    ref groupUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.GROUP_NOT_FOUND));
                                }
                                break;
                        }
                        lock (GroupDirectoryTrackersLock)
                        {
                            if (!GroupDirectoryTrackers.Contains(groupUUID))
                            {
                                GroupDirectoryTrackers.Add(groupUUID, Client.Inventory.Store.RootFolder);
                            }
                        }
                        string path =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATH)),
                                message));
                        Func<string, InventoryBase, InventoryBase> findPath = null;
                        findPath = (o, p) =>
                        {
                            if (string.IsNullOrEmpty(o)) return p;

                            // Split all paths.
                            string[] unpack = o.Split(CORRADE_CONSTANTS.PATH_SEPARATOR[0]);
                            // Pop first item to process.
                            string first = unpack.First();
                            // Remove item.
                            unpack = unpack.AsParallel().Where(q => !q.Equals(first)).ToArray();

                            InventoryBase next = p;

                            // Avoid preceeding slashes.
                            if (string.IsNullOrEmpty(first)) goto CONTINUE;

                            HashSet<InventoryBase> contents =
                                new HashSet<InventoryBase>(Client.Inventory.Store.GetContents(p.UUID));
                            try
                            {
                                UUID itemUUID;
                                switch (!UUID.TryParse(first, out itemUUID))
                                {
                                    case true:
                                        next = contents.SingleOrDefault(q => q.Name.Equals(first));
                                        break;
                                    default:
                                        next = contents.SingleOrDefault(q => q.UUID.Equals(itemUUID));
                                        break;
                                }
                            }
                            catch (Exception)
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AMBIGUOUS_PATH));
                            }

                            if (next == null || next.Equals(default(InventoryBase)))
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PATH_NOT_FOUND));
                            }

                            if (!(next is InventoryFolder))
                            {
                                return next;
                            }

                            CONTINUE:
                            return findPath(string.Join(CORRADE_CONSTANTS.PATH_SEPARATOR, unpack),
                                Client.Inventory.Store[next.UUID]);
                        };
                        InventoryBase item;
                        List<string> csv = new List<string>();
                        Action action = wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.LS:
                                switch (!string.IsNullOrEmpty(path))
                                {
                                    case true:
                                        if (path[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            item = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            item = GroupDirectoryTrackers[groupUUID] as InventoryBase;
                                        }
                                        break;
                                }
                                item = findPath(path, item);
                                switch (item is InventoryFolder)
                                {
                                    case true:
                                        foreach (DirItem dirItem in Client.Inventory.Store.GetContents(
                                            item.UUID).AsParallel().Select(
                                                o => DirItem.FromInventoryBase(o)))
                                        {
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(dirItem, dirItem.Name), dirItem.Name});
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(dirItem, dirItem.Item),
                                                dirItem.Item.ToString()
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(dirItem, dirItem.Type),
                                                wasGetDescriptionFromEnumValue(dirItem.Type)
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(dirItem, dirItem.Permissions),
                                                dirItem.Permissions
                                            });
                                        }
                                        break;
                                    case false:
                                        DirItem dir = DirItem.FromInventoryBase(item);
                                        csv.AddRange(new[] {wasGetStructureMemberDescription(dir, dir.Name), dir.Name});
                                        csv.AddRange(new[]
                                        {
                                            wasGetStructureMemberDescription(dir, dir.Item),
                                            dir.Item.ToString()
                                        });
                                        csv.AddRange(new[]
                                        {
                                            wasGetStructureMemberDescription(dir, dir.Type),
                                            wasGetDescriptionFromEnumValue(dir.Type)
                                        });
                                        csv.AddRange(new[]
                                        {
                                            wasGetStructureMemberDescription(dir, dir.Permissions),
                                            dir.Permissions
                                        });
                                        break;
                                }
                                break;
                            case Action.CWD:
                                lock (GroupDirectoryTrackersLock)
                                {
                                    DirItem dirItem =
                                        DirItem.FromInventoryBase(
                                            GroupDirectoryTrackers[groupUUID] as InventoryBase);
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(dirItem, dirItem.Name), dirItem.Name});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(dirItem, dirItem.Item), dirItem.Item.ToString()});
                                    csv.AddRange(new[]
                                    {
                                        wasGetStructureMemberDescription(dirItem, dirItem.Type),
                                        wasGetDescriptionFromEnumValue(dirItem.Type)
                                    });
                                    csv.AddRange(new[]
                                    {
                                        wasGetStructureMemberDescription(dirItem, dirItem.Permissions),
                                        dirItem.Permissions
                                    });
                                }
                                break;
                            case Action.CD:
                                if (string.IsNullOrEmpty(path))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_PATH_PROVIDED));
                                }
                                switch (!path[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                {
                                    case true:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            item = GroupDirectoryTrackers[groupUUID] as InventoryBase;
                                        }
                                        break;
                                    default:
                                        item = Client.Inventory.Store.RootFolder;
                                        break;
                                }
                                item = findPath(path, item);
                                if (!(item is InventoryFolder))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.UNEXPECTED_ITEM_IN_PATH));
                                }
                                lock (GroupDirectoryTrackersLock)
                                {
                                    GroupDirectoryTrackers[groupUUID] = item;
                                }
                                break;
                            case Action.MKDIR:
                                string mkdirName =
                                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                        message));
                                if (string.IsNullOrEmpty(mkdirName))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_NAME_PROVIDED));
                                }
                                switch (!string.IsNullOrEmpty(path))
                                {
                                    case true:
                                        if (path[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            item = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            item = GroupDirectoryTrackers[groupUUID] as InventoryBase;
                                        }
                                        break;
                                }
                                item = findPath(path, item);
                                if (!(item is InventoryFolder))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.UNEXPECTED_ITEM_IN_PATH));
                                }
                                if (Client.Inventory.CreateFolder(item.UUID, mkdirName) == UUID.Zero)
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_CREATE_FOLDER));
                                }
                                UpdateInventoryRecursive.Invoke(Client.Inventory.Store.RootFolder);
                                break;
                            case Action.CHMOD:
                                string itemPermissions =
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PERMISSIONS)), message));
                                if (string.IsNullOrEmpty(itemPermissions))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_PERMISSIONS_PROVIDED));
                                }
                                switch (!string.IsNullOrEmpty(path))
                                {
                                    case true:
                                        if (path[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            item = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            item = GroupDirectoryTrackers[groupUUID] as InventoryBase;
                                        }
                                        break;
                                }
                                item = findPath(path, item);
                                Action<InventoryItem, string> setPermissions = (o, p) =>
                                {
                                    OpenMetaverse.Permissions permissions = wasStringToPermissions(p);
                                    o.Permissions = permissions;
                                    Client.Inventory.RequestUpdateItem(o);
                                    bool succeeded = false;
                                    ManualResetEvent ItemReceivedEvent = new ManualResetEvent(false);
                                    EventHandler<ItemReceivedEventArgs> ItemReceivedEventHandler =
                                        (sender, args) =>
                                        {
                                            if (!args.Item.UUID.Equals(o.UUID)) return;
                                            succeeded = args.Item.Permissions.Equals(permissions);
                                            ItemReceivedEvent.Set();
                                        };
                                    lock (ClientInstanceInventoryLock)
                                    {
                                        Client.Inventory.ItemReceived += ItemReceivedEventHandler;
                                        Client.Inventory.RequestFetchInventory(o.UUID, o.OwnerID);
                                        if (!ItemReceivedEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                        {
                                            Client.Inventory.ItemReceived -= ItemReceivedEventHandler;
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_RETRIEVING_ITEM));
                                        }
                                        Client.Inventory.ItemReceived -= ItemReceivedEventHandler;
                                    }
                                    if (!succeeded)
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.SETTING_PERMISSIONS_FAILED));
                                    }
                                };
                                switch (item is InventoryFolder)
                                {
                                    case true:
                                        foreach (InventoryItem inventoryItem in Client.Inventory.Store.GetContents(
                                            item.UUID).OfType<InventoryItem>())
                                        {
                                            setPermissions.Invoke(inventoryItem, itemPermissions);
                                        }
                                        break;
                                    default:
                                        setPermissions.Invoke(item as InventoryItem, itemPermissions);
                                        break;
                                }
                                UpdateInventoryRecursive.Invoke(Client.Inventory.Store.RootFolder);
                                break;
                            case Action.RM:
                                switch (!string.IsNullOrEmpty(path))
                                {
                                    case true:
                                        if (path[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            item = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            item = GroupDirectoryTrackers[groupUUID] as InventoryBase;
                                        }
                                        break;
                                }
                                item = findPath(path, item);
                                switch (item is InventoryFolder)
                                {
                                    case true:
                                        Client.Inventory.MoveFolder(item.UUID,
                                            Client.Inventory.FindFolderForType(AssetType.TrashFolder));
                                        break;
                                    default:
                                        Client.Inventory.MoveItem(item.UUID,
                                            Client.Inventory.FindFolderForType(AssetType.TrashFolder));
                                        break;
                                }
                                UpdateInventoryRecursive.Invoke(Client.Inventory.Store.RootFolder);
                                break;
                            case Action.CP:
                            case Action.MV:
                            case Action.LN:
                                string lnSourcePath =
                                    wasInput(wasKeyValueGet(
                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SOURCE)),
                                        message));
                                InventoryBase sourceItem;
                                switch (!string.IsNullOrEmpty(lnSourcePath))
                                {
                                    case true:
                                        if (lnSourcePath[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            sourceItem = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            sourceItem = GroupDirectoryTrackers[groupUUID] as InventoryBase;
                                        }
                                        break;
                                }
                                sourceItem = findPath(lnSourcePath, sourceItem);
                                switch (action)
                                {
                                    case Action.CP:
                                    case Action.LN:
                                        if (sourceItem is InventoryFolder)
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.EXPECTED_ITEM_AS_SOURCE));
                                        }
                                        break;
                                }
                                string lnTargetPath =
                                    wasInput(wasKeyValueGet(
                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)),
                                        message));
                                InventoryBase targetItem;
                                switch (!string.IsNullOrEmpty(lnTargetPath))
                                {
                                    case true:
                                        if (lnTargetPath[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            targetItem = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            targetItem = GroupDirectoryTrackers[groupUUID] as InventoryBase;
                                        }
                                        break;
                                }
                                targetItem = findPath(lnTargetPath, targetItem);
                                if (!(targetItem is InventoryFolder))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.EXPECTED_FOLDER_AS_TARGET));
                                }
                                switch (action)
                                {
                                    case Action.LN:
                                        Client.Inventory.CreateLink(targetItem.UUID, sourceItem, (succeeded, newItem) =>
                                        {
                                            if (!succeeded)
                                            {
                                                throw new Exception(
                                                    wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_CREATE_ITEM));
                                            }
                                            Client.Inventory.RequestFetchInventory(newItem.UUID, newItem.OwnerID);
                                        });
                                        break;
                                    case Action.MV:
                                        switch (sourceItem is InventoryFolder)
                                        {
                                            case true:
                                                Client.Inventory.MoveFolder(sourceItem.UUID, targetItem.UUID);
                                                break;
                                            default:
                                                Client.Inventory.MoveItem(sourceItem.UUID, targetItem.UUID);
                                                break;
                                        }
                                        break;
                                    case Action.CP:
                                        Client.Inventory.RequestCopyItem(sourceItem.UUID, targetItem.UUID,
                                            sourceItem.Name,
                                            newItem =>
                                            {
                                                if (newItem == null)
                                                {
                                                    throw new Exception(
                                                        wasGetDescriptionFromEnumValue(ScriptError.UNABLE_TO_CREATE_ITEM));
                                                }
                                            });
                                        break;
                                }
                                UpdateInventoryRecursive.Invoke(Client.Inventory.Store.RootFolder);
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ACTION));
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETAVATARSDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        HashSet<Avatar> avatars = new HashSet<Avatar>();
                        object LockObject = new object();
                        switch (wasGetEnumValueFromDescription<Entity>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)), message))
                                .ToLowerInvariant()))
                        {
                            case Entity.RANGE:
                                Parallel.ForEach(
                                    GetAvatars(range, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT)
                                        .AsParallel()
                                        .Where(o => Vector3.Distance(o.Position, Client.Self.SimPosition) <= range),
                                    o =>
                                    {
                                        lock (LockObject)
                                        {
                                            avatars.Add(o);
                                        }
                                    });
                                break;
                            case Entity.PARCEL:
                                Vector3 position;
                                if (
                                    !Vector3.TryParse(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                                message)),
                                        out position))
                                {
                                    position = Client.Self.SimPosition;
                                }
                                Parcel parcel = null;
                                if (
                                    !GetParcelAtPosition(Client.Network.CurrentSim, position, ref parcel))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                                }
                                Parallel.ForEach(GetAvatars(new[]
                                {
                                    Vector3.Distance(Client.Self.SimPosition, parcel.AABBMin),
                                    Vector3.Distance(Client.Self.SimPosition, parcel.AABBMax),
                                    Vector3.Distance(Client.Self.SimPosition,
                                        new Vector3(parcel.AABBMin.X, parcel.AABBMax.Y, 0)),
                                    Vector3.Distance(Client.Self.SimPosition,
                                        new Vector3(parcel.AABBMax.X, parcel.AABBMin.Y, 0))
                                }.Max(), Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT)
                                    .AsParallel()
                                    .Where(o => IsVectorInParcel(o.Position, parcel)), o =>
                                    {
                                        lock (LockObject)
                                        {
                                            avatars.Add(o);
                                        }
                                    });
                                break;
                            case Entity.REGION:
                                // Get all sim parcels
                                ManualResetEvent SimParcelsDownloadedEvent = new ManualResetEvent(false);
                                EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedEventHandler =
                                    (sender, args) => SimParcelsDownloadedEvent.Set();
                                lock (ClientInstanceParcelsLock)
                                {
                                    Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedEventHandler;
                                    Client.Parcels.RequestAllSimParcels(Client.Network.CurrentSim);
                                    if (Client.Network.CurrentSim.IsParcelMapFull())
                                    {
                                        SimParcelsDownloadedEvent.Set();
                                    }
                                    if (!SimParcelsDownloadedEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PARCELS));
                                    }
                                    Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                }
                                HashSet<Parcel> regionParcels =
                                    new HashSet<Parcel>(Client.Network.CurrentSim.Parcels.Copy().Values);
                                Parallel.ForEach(
                                    GetAvatars(
                                        regionParcels.AsParallel().Select(o => new[]
                                        {
                                            Vector3.Distance(Client.Self.SimPosition, o.AABBMin),
                                            Vector3.Distance(Client.Self.SimPosition, o.AABBMax),
                                            Vector3.Distance(Client.Self.SimPosition,
                                                new Vector3(o.AABBMin.X, o.AABBMax.Y, 0)),
                                            Vector3.Distance(Client.Self.SimPosition,
                                                new Vector3(o.AABBMax.X, o.AABBMin.Y, 0))
                                        }.Max()).Max(), Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT)
                                        .AsParallel()
                                        .Where(o => regionParcels.AsParallel().Any(p => IsVectorInParcel(o.Position, p))),
                                    o =>
                                    {
                                        lock (LockObject)
                                        {
                                            avatars.Add(o);
                                        }
                                    });
                                break;
                            case Entity.AVATAR:
                                UUID agentUUID = UUID.Zero;
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out agentUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                                    ref agentUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                                }
                                Avatar avatar = GetAvatars(range, Configuration.SERVICES_TIMEOUT,
                                    Configuration.DATA_TIMEOUT).AsParallel().FirstOrDefault(o => o.ID.Equals(agentUUID));
                                if (avatar == null)
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AVATAR_NOT_IN_RANGE));
                                avatars.Add(avatar);
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                        }

                        // allow partial results
                        UpdateAvatars(ref avatars, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT);

                        List<string> data = new List<string>();

                        Parallel.ForEach(avatars, o =>
                        {
                            lock (LockObject)
                            {
                                data.AddRange(GetStructuredData(o,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)))
                                    );
                            }
                        });
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVESDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        HashSet<Primitive> updatePrimitives = new HashSet<Primitive>();
                        object LockObject = new object();
                        switch (wasGetEnumValueFromDescription<Entity>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)), message))
                                .ToLowerInvariant()))
                        {
                            case Entity.RANGE:
                                Parallel.ForEach(
                                    GetPrimitives(range, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT)
                                        .AsParallel()
                                        .Where(o => Vector3.Distance(o.Position, Client.Self.SimPosition) <= range),
                                    o =>
                                    {
                                        lock (LockObject)
                                        {
                                            updatePrimitives.Add(o);
                                        }
                                    });
                                break;
                            case Entity.PARCEL:
                                Vector3 position;
                                if (
                                    !Vector3.TryParse(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                                message)),
                                        out position))
                                {
                                    position = Client.Self.SimPosition;
                                }
                                Parcel parcel = null;
                                if (
                                    !GetParcelAtPosition(Client.Network.CurrentSim, position, ref parcel))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_FIND_PARCEL));
                                }
                                Parallel.ForEach(GetPrimitives(new[]
                                {
                                    Vector3.Distance(Client.Self.SimPosition, parcel.AABBMin),
                                    Vector3.Distance(Client.Self.SimPosition, parcel.AABBMax),
                                    Vector3.Distance(Client.Self.SimPosition,
                                        new Vector3(parcel.AABBMin.X, parcel.AABBMax.Y, 0)),
                                    Vector3.Distance(Client.Self.SimPosition,
                                        new Vector3(parcel.AABBMax.X, parcel.AABBMin.Y, 0))
                                }.Max(), Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT), o =>
                                {
                                    lock (LockObject)
                                    {
                                        updatePrimitives.Add(o);
                                    }
                                });
                                break;
                            case Entity.REGION:
                                // Get all sim parcels
                                ManualResetEvent SimParcelsDownloadedEvent = new ManualResetEvent(false);
                                EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedEventHandler =
                                    (sender, args) => SimParcelsDownloadedEvent.Set();
                                lock (ClientInstanceParcelsLock)
                                {
                                    Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedEventHandler;
                                    Client.Parcels.RequestAllSimParcels(Client.Network.CurrentSim);
                                    if (Client.Network.CurrentSim.IsParcelMapFull())
                                    {
                                        SimParcelsDownloadedEvent.Set();
                                    }
                                    if (!SimParcelsDownloadedEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                    {
                                        Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_GETTING_PARCELS));
                                    }
                                    Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                }
                                Parallel.ForEach(
                                    GetPrimitives(
                                        Client.Network.CurrentSim.Parcels.Copy().Values.AsParallel().Select(o => new[]
                                        {
                                            Vector3.Distance(Client.Self.SimPosition, o.AABBMin),
                                            Vector3.Distance(Client.Self.SimPosition, o.AABBMax),
                                            Vector3.Distance(Client.Self.SimPosition,
                                                new Vector3(o.AABBMin.X, o.AABBMax.Y, 0)),
                                            Vector3.Distance(Client.Self.SimPosition,
                                                new Vector3(o.AABBMax.X, o.AABBMin.Y, 0))
                                        }.Max()).Max(), Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT),
                                    o =>
                                    {
                                        lock (LockObject)
                                        {
                                            updatePrimitives.Add(o);
                                        }
                                    });
                                break;
                            case Entity.AVATAR:
                                UUID agentUUID = UUID.Zero;
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out agentUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT,
                                                    ref agentUUID))
                                {
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AGENT_NOT_FOUND));
                                }
                                Avatar avatar = GetAvatars(range, Configuration.SERVICES_TIMEOUT,
                                    Configuration.DATA_TIMEOUT).AsParallel().FirstOrDefault(o => o.ID.Equals(agentUUID));
                                if (avatar == null)
                                    throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.AVATAR_NOT_IN_RANGE));
                                HashSet<Primitive> objectsPrimitives =
                                    new HashSet<Primitive>(GetPrimitives(range, Configuration.SERVICES_TIMEOUT,
                                        Configuration.DATA_TIMEOUT));
                                Parallel.ForEach(objectsPrimitives,
                                    o =>
                                    {
                                        switch (!o.ParentID.Equals(avatar.LocalID))
                                        {
                                            case true:
                                                Primitive primitiveParent =
                                                    objectsPrimitives.AsParallel()
                                                        .FirstOrDefault(p => p.LocalID.Equals(o.ParentID));
                                                if (primitiveParent != null &&
                                                    primitiveParent.ParentID.Equals(avatar.LocalID))
                                                {
                                                    lock (LockObject)
                                                    {
                                                        updatePrimitives.Add(o);
                                                    }
                                                }
                                                break;
                                            default:
                                                lock (LockObject)
                                                {
                                                    updatePrimitives.Add(o);
                                                }
                                                break;
                                        }
                                    });
                                break;
                            default:
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_ENTITY));
                        }

                        // allow partial results
                        UpdatePrimitives(ref updatePrimitives, Configuration.DATA_TIMEOUT);

                        List<string> data = new List<string>();
                        Parallel.ForEach(updatePrimitives, o =>
                        {
                            lock (LockObject)
                            {
                                data.AddRange(GetStructuredData(o,
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)))
                                    );
                            }
                        });
                        if (!data.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.EXPORTXML:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }

                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then do not export it.
                        if (!primitive.ParentID.Equals(0) && !GetAvatars(range, Configuration.SERVICES_TIMEOUT,
                            Configuration.DATA_TIMEOUT)
                            .AsParallel()
                            .Any(o => o.LocalID.Equals(primitive.ParentID)))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_AN_OBJECT));
                        }

                        HashSet<Primitive> exportPrimitivesSet = new HashSet<Primitive>();
                        Primitive root = new Primitive(primitive) {Position = Vector3.Zero};
                        exportPrimitivesSet.Add(root);

                        object LockObject = new object();

                        // find all the children that have the object as parent.
                        Parallel.ForEach(GetPrimitives(range, Configuration.SERVICES_TIMEOUT,
                            Configuration.DATA_TIMEOUT), o =>
                            {
                                if (!o.ParentID.Equals(root.LocalID))
                                    return;
                                Primitive child = new Primitive(o);
                                child.Position = root.Position + child.Position*root.Rotation;
                                child.Rotation = root.Rotation*child.Rotation;
                                lock (LockObject)
                                {
                                    exportPrimitivesSet.Add(child);
                                }
                            });

                        // add all the textures to export
                        HashSet<UUID> exportTexturesSet = new HashSet<UUID>();
                        Parallel.ForEach(exportPrimitivesSet, o =>
                        {
                            lock (LockObject)
                            {
                                if (!o.Textures.DefaultTexture.TextureID.Equals(Primitive.TextureEntry.WHITE_TEXTURE) &&
                                    !exportTexturesSet.Contains(o.Textures.DefaultTexture.TextureID))
                                    exportTexturesSet.Add(new UUID(o.Textures.DefaultTexture.TextureID));
                            }
                            Parallel.ForEach(o.Textures.FaceTextures, p =>
                            {
                                lock (LockObject)
                                {
                                    if (p != null &&
                                        !p.TextureID.Equals(Primitive.TextureEntry.WHITE_TEXTURE) &&
                                        !exportTexturesSet.Contains(p.TextureID))
                                        exportTexturesSet.Add(new UUID(p.TextureID));
                                }
                            });

                            lock (LockObject)
                            {
                                if (o.Sculpt != null && !o.Sculpt.SculptTexture.Equals(UUID.Zero) &&
                                    !exportTexturesSet.Contains(o.Sculpt.SculptTexture))
                                    exportTexturesSet.Add(new UUID(o.Sculpt.SculptTexture));
                            }
                        });

                        // Get the destination format to convert the downloaded textures to.
                        string format =
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FORMAT)),
                                message));
                        PropertyInfo formatProperty = null;
                        if (!string.IsNullOrEmpty(format))
                        {
                            formatProperty = typeof (ImageFormat).GetProperties(
                                BindingFlags.Public |
                                BindingFlags.Static)
                                .AsParallel().FirstOrDefault(
                                    o =>
                                        string.Equals(o.Name, format, StringComparison.Ordinal));
                            if (formatProperty == null)
                            {
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_IMAGE_FORMAT_REQUESTED));
                            }
                        }

                        // download all the textures.
                        Dictionary<string, byte[]> exportTextureSetFiles = new Dictionary<string, byte[]>();
                        Parallel.ForEach(exportTexturesSet, o =>
                        {
                            byte[] assetData = null;
                            switch (!Client.Assets.Cache.HasAsset(o))
                            {
                                case true:
                                    lock (ClientInstanceAssetsLock)
                                    {
                                        ManualResetEvent RequestAssetEvent = new ManualResetEvent(false);
                                        Client.Assets.RequestImage(o, ImageType.Normal,
                                            delegate(TextureRequestState state, AssetTexture asset)
                                            {
                                                if (!asset.AssetID.Equals(o)) return;
                                                if (!state.Equals(TextureRequestState.Finished)) return;
                                                assetData = asset.AssetData;
                                                RequestAssetEvent.Set();
                                            });
                                        if (!RequestAssetEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_TRANSFERRING_ASSET));
                                        }
                                    }
                                    Client.Assets.Cache.SaveAssetToCache(o, assetData);
                                    break;
                                default:
                                    assetData = Client.Assets.Cache.GetCachedAssetBytes(o);
                                    break;
                            }
                            switch (formatProperty != null)
                            {
                                case true:
                                    ManagedImage managedImage;
                                    if (!OpenJPEG.DecodeToImage(assetData, out managedImage))
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(
                                                ScriptError.UNABLE_TO_DECODE_ASSET_DATA));
                                    }
                                    using (MemoryStream imageStream = new MemoryStream())
                                    {
                                        try
                                        {
                                            using (Bitmap bitmapImage = managedImage.ExportBitmap())
                                            {
                                                EncoderParameters encoderParameters =
                                                    new EncoderParameters(1);
                                                encoderParameters.Param[0] =
                                                    new EncoderParameter(Encoder.Quality, 100L);
                                                bitmapImage.Save(imageStream,
                                                    ImageCodecInfo.GetImageDecoders()
                                                        .AsParallel()
                                                        .FirstOrDefault(
                                                            p =>
                                                                p.FormatID.Equals(
                                                                    ((ImageFormat)
                                                                        formatProperty.GetValue(
                                                                            new ImageFormat(Guid.Empty)))
                                                                        .Guid)),
                                                    encoderParameters);
                                            }
                                        }
                                        catch (Exception)
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(
                                                    ScriptError.UNABLE_TO_CONVERT_TO_REQUESTED_FORMAT));
                                        }
                                        lock (LockObject)
                                        {
                                            exportTextureSetFiles.Add(
                                                o + "." + format.ToLower(),
                                                imageStream.ToArray());
                                        }
                                    }
                                    break;
                                default:
                                    format = "j2c";
                                    lock (LockObject)
                                    {
                                        exportTextureSetFiles.Add(o + "." + "j2c",
                                            assetData);
                                    }
                                    break;
                            }
                        });

                        HashSet<char> invalidPathCharacters = new HashSet<char>(Path.GetInvalidPathChars());

                        using (MemoryStream zipMemoryStream = new MemoryStream())
                        {
                            using (
                                ZipArchive zipOutputStream = new ZipArchive(zipMemoryStream, ZipArchiveMode.Create, true)
                                )
                            {
                                ZipArchive zipOutputStreamClosure = zipOutputStream;
                                // add all the textures to the zip file
                                Parallel.ForEach(exportTextureSetFiles, o =>
                                {
                                    lock (LockObject)
                                    {
                                        ZipArchiveEntry textureEntry =
                                            zipOutputStreamClosure.CreateEntry(
                                                new string(
                                                    o.Key.Where(p => !invalidPathCharacters.Contains(p)).ToArray()));
                                        using (Stream textureEntryDataStream = textureEntry.Open())
                                        {
                                            using (
                                                BinaryWriter textureEntryDataStreamWriter =
                                                    new BinaryWriter(textureEntryDataStream))
                                            {
                                                textureEntryDataStreamWriter.Write(o.Value);
                                                textureEntryDataStream.Flush();
                                            }
                                        }
                                    }
                                });

                                // add the primitives XML data to the zip file
                                ZipArchiveEntry primitiveEntry =
                                    zipOutputStreamClosure.CreateEntry(
                                        new string(
                                            (primitive.Properties.Name + ".xml").Where(
                                                p => !invalidPathCharacters.Contains(p))
                                                .ToArray()));
                                using (Stream primitiveEntryDataStream = primitiveEntry.Open())
                                {
                                    using (
                                        StreamWriter primitiveEntryDataStreamWriter =
                                            new StreamWriter(primitiveEntryDataStream))
                                    {
                                        primitiveEntryDataStreamWriter.Write(
                                            OSDParser.SerializeLLSDXmlString(
                                                Helpers.PrimListToOSD(exportPrimitivesSet.ToList())));
                                        primitiveEntryDataStreamWriter.Flush();
                                    }
                                }
                            }

                            // Base64-encode the zip stream and send it.
                            zipMemoryStream.Seek(0, SeekOrigin.Begin);

                            // If no path was specificed, then send the data.
                            string path =
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATH)),
                                    message));
                            if (string.IsNullOrEmpty(path))
                            {
                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                    Convert.ToBase64String(zipMemoryStream.ToArray()));
                                return;
                            }
                            if (
                                !HasCorradePermission(group, (int) Permissions.PERMISSION_SYSTEM))
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                            }
                            // Otherwise, save it to the specified file.
                            using (FileStream fs = File.Open(path, FileMode.Create))
                            {
                                zipMemoryStream.WriteTo(fs);
                                zipMemoryStream.Flush();
                            }
                        }
                    };
                    break;
                case ScriptKeys.EXPORTDAE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(group,
                                (int) Permissions.PERMISSION_INTERACT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = Configuration.RANGE;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, Configuration.SERVICES_TIMEOUT, Configuration.DATA_TIMEOUT))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.PRIMITIVE_NOT_FOUND));
                        }

                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then do not export it.
                        if (!primitive.ParentID.Equals(0) && !GetAvatars(range, Configuration.SERVICES_TIMEOUT,
                            Configuration.DATA_TIMEOUT)
                            .AsParallel()
                            .Any(o => o.LocalID.Equals(primitive.ParentID)))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.ITEM_IS_NOT_AN_OBJECT));
                        }

                        HashSet<Primitive> exportPrimitivesSet = new HashSet<Primitive>();
                        Primitive root = new Primitive(primitive) {Position = Vector3.Zero};
                        exportPrimitivesSet.Add(root);

                        object LockObject = new object();

                        // find all the children that have the object as parent.
                        Parallel.ForEach(GetPrimitives(range, Configuration.SERVICES_TIMEOUT,
                            Configuration.DATA_TIMEOUT), o =>
                            {
                                if (!o.ParentID.Equals(root.LocalID))
                                    return;
                                Primitive child = new Primitive(o);
                                child.Position = root.Position + child.Position*root.Rotation;
                                child.Rotation = root.Rotation*child.Rotation;
                                lock (LockObject)
                                {
                                    exportPrimitivesSet.Add(child);
                                }
                            });

                        // update the primitives in the link set
                        if (!UpdatePrimitives(ref exportPrimitivesSet, Configuration.DATA_TIMEOUT))
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_GET_PRIMITIVE_PROPERTIES));

                        // add all the textures to export
                        HashSet<UUID> exportTexturesSet = new HashSet<UUID>();
                        Parallel.ForEach(exportPrimitivesSet, o =>
                        {
                            Primitive.TextureEntryFace defaultTexture = o.Textures.DefaultTexture;
                            lock (LockObject)
                            {
                                if (defaultTexture != null && !exportTexturesSet.Contains(defaultTexture.TextureID))
                                    exportTexturesSet.Add(defaultTexture.TextureID);
                            }
                            Parallel.ForEach(o.Textures.FaceTextures, p =>
                            {
                                if (p != null)
                                {
                                    lock (LockObject)
                                    {
                                        if (!exportTexturesSet.Contains(p.TextureID))
                                        {
                                            exportTexturesSet.Add(p.TextureID);
                                        }
                                    }
                                }
                            });
                        });

                        // Get the destination format to convert the downloaded textures to.
                        string format =
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FORMAT)),
                                message));
                        PropertyInfo formatProperty = null;
                        if (!string.IsNullOrEmpty(format))
                        {
                            formatProperty = typeof (ImageFormat).GetProperties(
                                BindingFlags.Public |
                                BindingFlags.Static)
                                .AsParallel().FirstOrDefault(
                                    o =>
                                        string.Equals(o.Name, format, StringComparison.Ordinal));
                            if (formatProperty == null)
                            {
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_IMAGE_FORMAT_REQUESTED));
                            }
                        }

                        // download all the textures.
                        Dictionary<string, byte[]> exportTextureSetFiles = new Dictionary<string, byte[]>();
                        Dictionary<UUID, string> exportMeshTextures = new Dictionary<UUID, string>();
                        Parallel.ForEach(exportTexturesSet, o =>
                        {
                            byte[] assetData = null;
                            switch (!Client.Assets.Cache.HasAsset(o))
                            {
                                case true:
                                    lock (ClientInstanceAssetsLock)
                                    {
                                        ManualResetEvent RequestAssetEvent = new ManualResetEvent(false);
                                        Client.Assets.RequestImage(o, ImageType.Normal,
                                            delegate(TextureRequestState state, AssetTexture asset)
                                            {
                                                if (!asset.AssetID.Equals(o)) return;
                                                if (!state.Equals(TextureRequestState.Finished)) return;
                                                assetData = asset.AssetData;
                                                RequestAssetEvent.Set();
                                            });
                                        if (!RequestAssetEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false))
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(ScriptError.TIMEOUT_TRANSFERRING_ASSET));
                                        }
                                    }
                                    Client.Assets.Cache.SaveAssetToCache(o, assetData);
                                    break;
                                default:
                                    assetData = Client.Assets.Cache.GetCachedAssetBytes(o);
                                    break;
                            }
                            switch (formatProperty != null)
                            {
                                case true:
                                    ManagedImage managedImage;
                                    if (!OpenJPEG.DecodeToImage(assetData, out managedImage))
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(
                                                ScriptError.UNABLE_TO_DECODE_ASSET_DATA));
                                    }
                                    using (MemoryStream imageStream = new MemoryStream())
                                    {
                                        try
                                        {
                                            using (Bitmap bitmapImage = managedImage.ExportBitmap())
                                            {
                                                EncoderParameters encoderParameters =
                                                    new EncoderParameters(1);
                                                encoderParameters.Param[0] =
                                                    new EncoderParameter(Encoder.Quality, 100L);
                                                bitmapImage.Save(imageStream,
                                                    ImageCodecInfo.GetImageDecoders()
                                                        .AsParallel()
                                                        .FirstOrDefault(
                                                            p =>
                                                                p.FormatID.Equals(
                                                                    ((ImageFormat)
                                                                        formatProperty.GetValue(
                                                                            new ImageFormat(Guid.Empty)))
                                                                        .Guid)),
                                                    encoderParameters);
                                            }
                                        }
                                        catch (Exception)
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(
                                                    ScriptError.UNABLE_TO_CONVERT_TO_REQUESTED_FORMAT));
                                        }
                                        lock (LockObject)
                                        {
                                            exportTextureSetFiles.Add(
                                                o + "." + format.ToLower(),
                                                imageStream.ToArray());
                                            exportMeshTextures.Add(o,
                                                o.ToString());
                                        }
                                    }
                                    break;
                                default:
                                    format = "j2c";
                                    lock (LockObject)
                                    {
                                        exportTextureSetFiles.Add(o + "." + "j2c",
                                            assetData);
                                        exportMeshTextures.Add(o,
                                            o.ToString());
                                    }
                                    break;
                            }
                        });

                        // meshmerize all the primitives
                        HashSet<FacetedMesh> exportMeshSet = new HashSet<FacetedMesh>();
                        MeshmerizerR mesher = new MeshmerizerR();
                        Parallel.ForEach(exportPrimitivesSet, o =>
                        {
                            FacetedMesh mesh = null;
                            if (!MakeFacetedMesh(o, mesher, ref mesh, Configuration.SERVICES_TIMEOUT))
                            {
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.COULD_NOT_MESHMERIZE_OBJECT));
                            }
                            if (mesh == null) return;
                            Parallel.ForEach(mesh.Faces, p =>
                            {
                                Primitive.TextureEntryFace textureEntryFace = p.TextureFace;
                                if (textureEntryFace == null) return;

                                // Sculpt UV vertically flipped compared to prims. Flip back
                                if (o.Sculpt != null && !o.Sculpt.SculptTexture.Equals(UUID.Zero) &&
                                    !o.Sculpt.Type.Equals(SculptType.Mesh))
                                {
                                    textureEntryFace = (Primitive.TextureEntryFace) textureEntryFace.Clone();
                                    textureEntryFace.RepeatV *= -1;
                                }
                                // Texture transform for this face
                                mesher.TransformTexCoords(p.Vertices, p.Center, textureEntryFace, o.Scale);
                            });
                            lock (LockObject)
                            {
                                exportMeshSet.Add(mesh);
                            }
                        });

                        HashSet<char> invalidPathCharacters = new HashSet<char>(Path.GetInvalidPathChars());

                        using (MemoryStream zipMemoryStream = new MemoryStream())
                        {
                            using (
                                ZipArchive zipOutputStream = new ZipArchive(zipMemoryStream, ZipArchiveMode.Create, true)
                                )
                            {
                                ZipArchive zipOutputStreamClosure = zipOutputStream;
                                // add all the textures to the zip file
                                Parallel.ForEach(exportTextureSetFiles, o =>
                                {
                                    lock (LockObject)
                                    {
                                        ZipArchiveEntry textureEntry =
                                            zipOutputStreamClosure.CreateEntry(
                                                new string(
                                                    o.Key.Where(
                                                        p => !invalidPathCharacters.Contains(p)).ToArray()));
                                        using (Stream textureEntryDataStream = textureEntry.Open())
                                        {
                                            using (
                                                BinaryWriter textureEntryDataStreamWriter =
                                                    new BinaryWriter(textureEntryDataStream))
                                            {
                                                textureEntryDataStreamWriter.Write(o.Value);
                                                textureEntryDataStream.Flush();
                                            }
                                        }
                                    }
                                });

                                // add the primitives XML data to the zip file
                                ZipArchiveEntry primitiveEntry =
                                    zipOutputStreamClosure.CreateEntry(
                                        new string(
                                            (primitive.Properties.Name + ".dae").Where(
                                                p => !invalidPathCharacters.Contains(p))
                                                .ToArray()));
                                using (Stream primitiveEntryDataStream = primitiveEntry.Open())
                                {
                                    using (
                                        XmlTextWriter XMLTextWriter = new XmlTextWriter(primitiveEntryDataStream,
                                            Encoding.UTF8))
                                    {
                                        XMLTextWriter.Formatting = Formatting.Indented;
                                        XMLTextWriter.WriteProcessingInstruction("xml",
                                            "version=\"1.0\" encoding=\"utf-8\"");
                                        GenerateCollada(exportMeshSet, exportMeshTextures, format)
                                            .WriteContentTo(XMLTextWriter);
                                        XMLTextWriter.Flush();
                                    }
                                }
                            }

                            // Base64-encode the zip stream and send it.
                            zipMemoryStream.Seek(0, SeekOrigin.Begin);

                            // If no path was specificed, then send the data.
                            string path =
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATH)),
                                    message));
                            if (string.IsNullOrEmpty(path))
                            {
                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                    Convert.ToBase64String(zipMemoryStream.ToArray()));
                                return;
                            }
                            if (
                                !HasCorradePermission(group, (int) Permissions.PERMISSION_SYSTEM))
                            {
                                throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                            }
                            // Otherwise, save it to the specified file.
                            using (FileStream fs = File.Open(path, FileMode.Create))
                            {
                                zipMemoryStream.WriteTo(fs);
                                zipMemoryStream.Flush();
                            }
                        }
                    };
                    break;
                case ScriptKeys.VERSION:
                    execute =
                        () =>
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                CORRADE_CONSTANTS.CORRADE_VERSION);
                    break;
                case ScriptKeys.DIRECTORYSEARCH:
                    execute = () =>
                    {
                        if (!HasCorradePermission(group, (int) Permissions.PERMISSION_DIRECTORY))
                        {
                            throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.NO_CORRADE_PERMISSIONS));
                        }
                        wasAdaptiveAlarm DirectorySearchResultsAlarm =
                            new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        string fields =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message));
                        object LockObject = new object();
                        List<string> csv = new List<string>();
                        int handledEvents = 0;
                        int counter = 1;
                        switch (
                            wasGetEnumValueFromDescription<Type>(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)), message))
                                    .ToLowerInvariant()))
                        {
                            case Type.CLASSIFIED:
                                DirectoryManager.Classified searchClassified = new DirectoryManager.Classified();
                                wasCSVToStructure(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)),
                                    ref searchClassified);
                                Dictionary<DirectoryManager.Classified, int> classifieds =
                                    new Dictionary<DirectoryManager.Classified, int>();
                                EventHandler<DirClassifiedsReplyEventArgs> DirClassifiedsEventHandler =
                                    (sender, args) => Parallel.ForEach(args.Classifieds, o =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                        int score = !string.IsNullOrEmpty(fields)
                                            ? wasGetFields(searchClassified, searchClassified.GetType().Name)
                                                .Sum(
                                                    p =>
                                                        (from q in
                                                            wasGetFields(o,
                                                                o.GetType().Name)
                                                            let r = wasGetInfoValue(p.Key, p.Value)
                                                            where r != null
                                                            let s = wasGetInfoValue(q.Key, q.Value)
                                                            where s != null
                                                            where r.Equals(s)
                                                            select r).Count())
                                            : 0;
                                        lock (LockObject)
                                        {
                                            if (!classifieds.ContainsKey(o))
                                            {
                                                classifieds.Add(o, score);
                                            }
                                        }
                                    });
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.DirClassifiedsReply += DirClassifiedsEventHandler;
                                    Client.Directory.StartClassifiedSearch(name);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false);
                                    Client.Directory.DirClassifiedsReply -= DirClassifiedsEventHandler;
                                }
                                Dictionary<DirectoryManager.Classified, int> safeClassifieds;
                                lock (LockObject)
                                {
                                    safeClassifieds =
                                        classifieds.OrderByDescending(o => o.Value)
                                            .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safeClassifieds,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            case Type.EVENT:
                                DirectoryManager.EventsSearchData searchEvent = new DirectoryManager.EventsSearchData();
                                wasCSVToStructure(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)),
                                    ref searchEvent);
                                Dictionary<DirectoryManager.EventsSearchData, int> events =
                                    new Dictionary<DirectoryManager.EventsSearchData, int>();
                                EventHandler<DirEventsReplyEventArgs> DirEventsEventHandler =
                                    (sender, args) =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                        handledEvents += args.MatchedEvents.Count;
                                        Parallel.ForEach(args.MatchedEvents, o =>
                                        {
                                            int score = !string.IsNullOrEmpty(fields)
                                                ? wasGetFields(searchEvent, searchEvent.GetType().Name)
                                                    .Sum(
                                                        p =>
                                                            (from q in
                                                                wasGetFields(o, o.GetType().Name)
                                                                let r = wasGetInfoValue(p.Key, p.Value)
                                                                where r != null
                                                                let s = wasGetInfoValue(q.Key, q.Value)
                                                                where s != null
                                                                where r.Equals(s)
                                                                select r).Count())
                                                : 0;
                                            lock (LockObject)
                                            {
                                                if (!events.ContainsKey(o))
                                                {
                                                    events.Add(o, score);
                                                }
                                            }
                                        });
                                        if (handledEvents > LINDEN_CONSTANTS.DIRECTORY.EVENT.SEARCH_RESULTS_COUNT &&
                                            ((handledEvents - counter)%
                                             LINDEN_CONSTANTS.DIRECTORY.EVENT.SEARCH_RESULTS_COUNT).Equals(0))
                                        {
                                            ++counter;
                                            Client.Directory.StartEventsSearch(name, (uint) handledEvents);
                                        }
                                    };
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.DirEventsReply += DirEventsEventHandler;
                                    Client.Directory.StartEventsSearch(name,
                                        (uint) handledEvents);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false);
                                    Client.Directory.DirEventsReply -= DirEventsEventHandler;
                                }
                                Dictionary<DirectoryManager.EventsSearchData, int> safeEvents;
                                lock (LockObject)
                                {
                                    safeEvents = events.OrderByDescending(o => o.Value)
                                        .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safeEvents,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            case Type.GROUP:
                                if (string.IsNullOrEmpty(name))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_SEARCH_TEXT_PROVIDED));
                                }
                                DirectoryManager.GroupSearchData searchGroup = new DirectoryManager.GroupSearchData();
                                wasCSVToStructure(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)),
                                    ref searchGroup);
                                Dictionary<DirectoryManager.GroupSearchData, int> groups =
                                    new Dictionary<DirectoryManager.GroupSearchData, int>();
                                EventHandler<DirGroupsReplyEventArgs> DirGroupsEventHandler =
                                    (sender, args) =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                        handledEvents += args.MatchedGroups.Count;
                                        Parallel.ForEach(args.MatchedGroups, o =>
                                        {
                                            int score = !string.IsNullOrEmpty(fields)
                                                ? wasGetFields(searchGroup, searchGroup.GetType().Name)
                                                    .Sum(
                                                        p =>
                                                            (from q in
                                                                wasGetFields(o, o.GetType().Name)
                                                                let r = wasGetInfoValue(p.Key, p.Value)
                                                                where r != null
                                                                let s = wasGetInfoValue(q.Key, q.Value)
                                                                where s != null
                                                                where r.Equals(s)
                                                                select r).Count())
                                                : 0;
                                            lock (LockObject)
                                            {
                                                if (!groups.ContainsKey(o))
                                                {
                                                    groups.Add(o, score);
                                                }
                                            }
                                        });
                                        if (handledEvents > LINDEN_CONSTANTS.DIRECTORY.GROUP.SEARCH_RESULTS_COUNT &&
                                            ((handledEvents - counter)%
                                             LINDEN_CONSTANTS.DIRECTORY.GROUP.SEARCH_RESULTS_COUNT).Equals(0))
                                        {
                                            ++counter;
                                            Client.Directory.StartGroupSearch(name, handledEvents);
                                        }
                                    };
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.DirGroupsReply += DirGroupsEventHandler;
                                    Client.Directory.StartGroupSearch(name, handledEvents);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false);
                                    Client.Directory.DirGroupsReply -= DirGroupsEventHandler;
                                }
                                Dictionary<DirectoryManager.GroupSearchData, int> safeGroups;
                                lock (LockObject)
                                {
                                    safeGroups = groups.OrderByDescending(o => o.Value)
                                        .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safeGroups,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            case Type.LAND:
                                DirectoryManager.DirectoryParcel searchLand = new DirectoryManager.DirectoryParcel();
                                wasCSVToStructure(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)),
                                    ref searchLand);
                                Dictionary<DirectoryManager.DirectoryParcel, int> lands =
                                    new Dictionary<DirectoryManager.DirectoryParcel, int>();
                                EventHandler<DirLandReplyEventArgs> DirLandReplyEventArgs =
                                    (sender, args) =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                        handledEvents += args.DirParcels.Count;
                                        Parallel.ForEach(args.DirParcels, o =>
                                        {
                                            int score = !string.IsNullOrEmpty(fields)
                                                ? wasGetFields(searchLand, searchLand.GetType().Name)
                                                    .Sum(
                                                        p =>
                                                            (from q in
                                                                wasGetFields(o, o.GetType().Name)
                                                                let r = wasGetInfoValue(p.Key, p.Value)
                                                                where r != null
                                                                let s = wasGetInfoValue(q.Key, q.Value)
                                                                where s != null
                                                                where r.Equals(s)
                                                                select r).Count())
                                                : 0;
                                            lock (LockObject)
                                            {
                                                if (!lands.ContainsKey(o))
                                                {
                                                    lands.Add(o, score);
                                                }
                                            }
                                        });
                                        if (handledEvents > LINDEN_CONSTANTS.DIRECTORY.LAND.SEARCH_RESULTS_COUNT &&
                                            ((handledEvents - counter)%
                                             LINDEN_CONSTANTS.DIRECTORY.LAND.SEARCH_RESULTS_COUNT).Equals(0))
                                        {
                                            ++counter;
                                            Client.Directory.StartLandSearch(DirectoryManager.DirFindFlags.SortAsc,
                                                DirectoryManager.SearchTypeFlags.Any, int.MaxValue, int.MaxValue,
                                                handledEvents);
                                        }
                                    };
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.DirLandReply += DirLandReplyEventArgs;
                                    Client.Directory.StartLandSearch(DirectoryManager.DirFindFlags.SortAsc,
                                        DirectoryManager.SearchTypeFlags.Any, int.MaxValue, int.MaxValue, handledEvents);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false);
                                    Client.Directory.DirLandReply -= DirLandReplyEventArgs;
                                }
                                Dictionary<DirectoryManager.DirectoryParcel, int> safeLands;
                                lock (LockObject)
                                {
                                    safeLands = lands.OrderByDescending(o => o.Value)
                                        .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safeLands,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            case Type.PEOPLE:
                                if (string.IsNullOrEmpty(name))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_SEARCH_TEXT_PROVIDED));
                                }
                                DirectoryManager.AgentSearchData searchAgent = new DirectoryManager.AgentSearchData();
                                Dictionary<DirectoryManager.AgentSearchData, int> agents =
                                    new Dictionary<DirectoryManager.AgentSearchData, int>();
                                EventHandler<DirPeopleReplyEventArgs> DirPeopleReplyEventHandler =
                                    (sender, args) =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                        handledEvents += args.MatchedPeople.Count;
                                        Parallel.ForEach(args.MatchedPeople, o =>
                                        {
                                            int score = !string.IsNullOrEmpty(fields)
                                                ? wasGetFields(searchAgent, searchAgent.GetType().Name)
                                                    .Sum(
                                                        p =>
                                                            (from q in
                                                                wasGetFields(o, o.GetType().Name)
                                                                let r = wasGetInfoValue(p.Key, p.Value)
                                                                where r != null
                                                                let s = wasGetInfoValue(q.Key, q.Value)
                                                                where s != null
                                                                where r.Equals(s)
                                                                select r).Count())
                                                : 0;
                                            lock (LockObject)
                                            {
                                                if (!agents.ContainsKey(o))
                                                {
                                                    agents.Add(o, score);
                                                }
                                            }
                                        });
                                        if (handledEvents > LINDEN_CONSTANTS.DIRECTORY.PEOPLE.SEARCH_RESULTS_COUNT &&
                                            ((handledEvents - counter)%
                                             LINDEN_CONSTANTS.DIRECTORY.PEOPLE.SEARCH_RESULTS_COUNT).Equals(0))
                                        {
                                            ++counter;
                                            Client.Directory.StartPeopleSearch(name, handledEvents);
                                        }
                                    };
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.DirPeopleReply += DirPeopleReplyEventHandler;
                                    Client.Directory.StartPeopleSearch(name, handledEvents);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false);
                                    Client.Directory.DirPeopleReply -= DirPeopleReplyEventHandler;
                                }
                                Dictionary<DirectoryManager.AgentSearchData, int> safeAgents;
                                lock (LockObject)
                                {
                                    safeAgents = agents.OrderByDescending(o => o.Value)
                                        .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safeAgents,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            case Type.PLACE:
                                if (string.IsNullOrEmpty(name))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(ScriptError.NO_SEARCH_TEXT_PROVIDED));
                                }
                                DirectoryManager.PlacesSearchData searchPlaces = new DirectoryManager.PlacesSearchData();
                                wasCSVToStructure(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)),
                                    ref searchPlaces);
                                Dictionary<DirectoryManager.PlacesSearchData, int> places =
                                    new Dictionary<DirectoryManager.PlacesSearchData, int>();
                                EventHandler<PlacesReplyEventArgs> DirPlacesReplyEventHandler =
                                    (sender, args) => Parallel.ForEach(args.MatchedPlaces, o =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(Configuration.DATA_TIMEOUT);
                                        int score = !string.IsNullOrEmpty(fields)
                                            ? wasGetFields(searchPlaces, searchPlaces.GetType().Name)
                                                .Sum(
                                                    p =>
                                                        (from q in
                                                            wasGetFields(o, o.GetType().Name)
                                                            let r = wasGetInfoValue(p.Key, p.Value)
                                                            where r != null
                                                            let s = wasGetInfoValue(q.Key, q.Value)
                                                            where s != null
                                                            where r.Equals(s)
                                                            select r).Count())
                                            : 0;
                                        lock (LockObject)
                                        {
                                            if (!places.ContainsKey(o))
                                            {
                                                places.Add(o, score);
                                            }
                                        }
                                    });
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.PlacesReply += DirPlacesReplyEventHandler;
                                    Client.Directory.StartPlacesSearch(name);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(Configuration.SERVICES_TIMEOUT, false);
                                    Client.Directory.PlacesReply -= DirPlacesReplyEventHandler;
                                }
                                Dictionary<DirectoryManager.PlacesSearchData, int> safePlaces;
                                lock (LockObject)
                                {
                                    safePlaces = places.OrderByDescending(o => o.Value)
                                        .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safePlaces,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            default:
                                throw new Exception(
                                    wasGetDescriptionFromEnumValue(ScriptError.UNKNOWN_DIRECTORY_SEARCH_TYPE));
                        }
                        if (!csv.Count.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                default:
                    execute =
                        () => { throw new Exception(wasGetDescriptionFromEnumValue(ScriptError.COMMAND_NOT_FOUND)); };
                    break;
            }

            // sift action
            System.Action sift = () =>
            {
                string pattern =
                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SIFT)), message));
                if (string.IsNullOrEmpty(pattern)) return;
                string data;
                if (!result.TryGetValue(wasGetDescriptionFromEnumValue(ResultKeys.DATA), out data)) return;
                data = wasEnumerableToCSV((((new Regex(pattern, RegexOptions.Compiled)).Matches(data)
                    .Cast<Match>()
                    .Select(m => m.Groups)).SelectMany(
                        matchGroups => Enumerable.Range(0, matchGroups.Count).Skip(1),
                        (matchGroups, i) => new {matchGroups, i})
                    .SelectMany(@t => Enumerable.Range(0, @t.matchGroups[@t.i].Captures.Count),
                        (@t, j) => @t.matchGroups[@t.i].Captures[j].Value)));
                if (string.IsNullOrEmpty(data))
                {
                    result.Remove(wasGetDescriptionFromEnumValue(ResultKeys.DATA));
                    return;
                }
                result[wasGetDescriptionFromEnumValue(ResultKeys.DATA)] = data;
            };

            // execute command, sift data and check for errors
            bool success = false;
            try
            {
                execute.Invoke();
                sift.Invoke();
                success = true;
            }
            catch (Exception ex)
            {
                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.ERROR), ex.Message);
            }

            // add the final success status
            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.SUCCESS),
                success.ToString(CultureInfo.InvariantCulture));

            // build afterburn
            object AfterBurnLock = new object();
            HashSet<string> resultKeys = new HashSet<string>(wasGetEnumDescriptions<ResultKeys>());
            HashSet<string> scriptKeys = new HashSet<string>(wasGetEnumDescriptions<ScriptKeys>());
            Parallel.ForEach(wasKeyValueDecode(message), o =>
            {
                // remove keys that are script keys, result keys or invalid key-value pairs
                if (string.IsNullOrEmpty(o.Key) || resultKeys.Contains(wasInput(o.Key)) ||
                    scriptKeys.Contains(wasInput(o.Key)) ||
                    string.IsNullOrEmpty(o.Value))
                    return;
                lock (AfterBurnLock)
                {
                    result.Add(o.Key, o.Value);
                }
            });

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Gets the values from structures as strings.
        /// </summary>
        /// <typeparam name="T">the type of the structure</typeparam>
        /// <param name="structure">the structure</param>
        /// <param name="query">a CSV list of fields or properties to get</param>
        /// <returns>value strings</returns>
        private static IEnumerable<string> GetStructuredData<T>(T structure, string query)
        {
            HashSet<string[]> result = new HashSet<string[]>();
            if (structure.Equals(default(T)))
                return result.SelectMany(o => o);
            object LockObject = new object();
            Parallel.ForEach(wasCSVToEnumerable(query), name =>
            {
                KeyValuePair<FieldInfo, object> fi = wasGetFields(structure, structure.GetType().Name)
                    .AsParallel().FirstOrDefault(o => o.Key.Name.Equals(name, StringComparison.Ordinal));

                lock (LockObject)
                {
                    List<string> data = new List<string> {name};
                    data.AddRange(wasGetInfo(fi.Key, fi.Value));
                    if (data.Count >= 2)
                    {
                        result.Add(data.ToArray());
                    }
                }

                KeyValuePair<PropertyInfo, object> pi =
                    wasGetProperties(structure, structure.GetType().Name)
                        .AsParallel().FirstOrDefault(
                            o => o.Key.Name.Equals(name, StringComparison.Ordinal));
                lock (LockObject)
                {
                    List<string> data = new List<string> {name};
                    data.AddRange(wasGetInfo(pi.Key, pi.Value));
                    if (data.Count >= 2)
                    {
                        result.Add(data.ToArray());
                    }
                }
            });
            return result.SelectMany(o => o);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Takes as input a CSV data values and sets the corresponding
        ///     structure's fields or properties from the CSV data.
        /// </summary>
        /// <typeparam name="T">the type of the structure</typeparam>
        /// <param name="data">a CSV string</param>
        /// <param name="structure">the structure to set the fields and properties for</param>
        private static void wasCSVToStructure<T>(string data, ref T structure)
        {
            foreach (
                KeyValuePair<string, string> match in
                    wasCSVToEnumerable(data).AsParallel().Select((o, p) => new {o, p})
                        .GroupBy(q => q.p/2, q => q.o)
                        .Select(o => o.ToList())
                        .TakeWhile(o => o.Count%2 == 0)
                        .ToDictionary(o => o.First(), p => p.Last()))
            {
                KeyValuePair<string, string> localMatch = match;
                KeyValuePair<FieldInfo, object> fi =
                    wasGetFields(structure, structure.GetType().Name)
                        .AsParallel().FirstOrDefault(
                            o =>
                                o.Key.Name.Equals(localMatch.Key,
                                    StringComparison.Ordinal));

                wasSetInfo(fi.Key, fi.Value, match.Value, ref structure);

                KeyValuePair<PropertyInfo, object> pi =
                    wasGetProperties(structure, structure.GetType().Name)
                        .AsParallel().FirstOrDefault(
                            o =>
                                o.Key.Name.Equals(localMatch.Key,
                                    StringComparison.Ordinal));

                wasSetInfo(pi.Key, pi.Value, match.Value, ref structure);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Sends a post request to an URL with set key-value pairs.
        /// </summary>
        /// <param name="URL">the url to send the message to</param>
        /// <param name="message">key-value pairs to send</param>
        /// <param name="millisecondsTimeout">the time in milliseconds for the request to timeout</param>
        private static void wasPOST(string URL, Dictionary<string, string> message, int millisecondsTimeout)
        {
            HttpWebRequest request = (HttpWebRequest) WebRequest.Create(URL);
            request.Timeout = millisecondsTimeout;
            request.AllowAutoRedirect = true;
            request.AllowWriteStreamBuffering = true;
            request.Pipelined = true;
            request.KeepAlive = true;
            request.ProtocolVersion = HttpVersion.Version11;
            request.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;
            request.Method = WebRequestMethods.Http.Post;
            // set the content type based on chosen output filers
            switch (Configuration.OUTPUT_FILTERS.Last())
            {
                case Filter.RFC1738:
                    request.ContentType = CORRADE_CONSTANTS.CONTENT_TYPE.WWW_FORM_URLENCODED;
                    break;
                default:
                    request.ContentType = CORRADE_CONSTANTS.CONTENT_TYPE.TEXT_PLAIN;
                    break;
            }
            request.UserAgent = string.Format("{0}/{1} ({2})", CORRADE_CONSTANTS.CORRADE,
                CORRADE_CONSTANTS.CORRADE_VERSION,
                CORRADE_CONSTANTS.WIZARDRY_AND_STEAMWORKS_WEBSITE);
            byte[] byteArray =
                Encoding.UTF8.GetBytes(wasKeyValueEncode(message));
            request.ContentLength = byteArray.Length;
            using (Stream dataStream = request.GetRequestStream())
            {
                dataStream.Write(byteArray, 0, byteArray.Length);
                dataStream.Flush();
            }
        }

        private static void HandleTerseObjectUpdate(object sender, TerseObjectUpdateEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_TERSE_UPDATES, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleRadarObjects(object sender, SimChangedEventArgs e)
        {
            lock (RadarObjectsLock)
            {
                if (!RadarObjects.Count.Equals(0))
                {
                    RadarObjects.Clear();
                }
            }
        }

        private static void HandleSimChanged(object sender, SimChangedEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_REGION_CROSSED, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleMoneyBalance(object sender, BalanceEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_BALANCE, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        private static void HandleMoneyBalance(object sender, MoneyBalanceReplyEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.NOTIFICATION_ECONOMY, e),
                Configuration.MAXIMUM_NOTIFICATION_THREADS);
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>URI unescapes an RFC3986 URI escaped string</summary>
        /// <param name="data">a string to unescape</param>
        /// <returns>the resulting string</returns>
        private static string wasURIUnescapeDataString(string data)
        {
            // Uri.UnescapeDataString can only handle 32766 characters at a time
            return string.Join("", Enumerable.Range(0, (data.Length + 32765)/32766)
                .Select(o => Uri.UnescapeDataString(data.Substring(o*32766, Math.Min(32766, data.Length - (o*32766)))))
                .ToArray());
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>RFC3986 URI Escapes a string</summary>
        /// <param name="data">a string to escape</param>
        /// <returns>an RFC3986 escaped string</returns>
        private static string wasURIEscapeDataString(string data)
        {
            // Uri.EscapeDataString can only handle 32766 characters at a time
            return string.Join("", Enumerable.Range(0, (data.Length + 32765)/32766)
                .Select(o => Uri.EscapeDataString(data.Substring(o*32766, Math.Min(32766, data.Length - (o*32766)))))
                .ToArray());
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2015 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>RFC1738 URL Escapes a string</summary>
        /// <param name="data">a string to escape</param>
        /// <returns>an RFC1738 escaped string</returns>
        private static string wasURLEscapeDataString(string data)
        {
            return HttpUtility.UrlEncode(data);
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2015 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>RFC1738 URL Unescape a string</summary>
        /// <param name="data">a string to unescape</param>
        /// <returns>an RFC1738 unescaped string</returns>
        private static string wasURLUnescapeDataString(string data)
        {
            return HttpUtility.UrlDecode(data);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Converts a list of string to a comma-separated values string.
        /// </summary>
        /// <param name="l">a list of strings</param>
        /// <returns>a commma-separated list of values</returns>
        /// <remarks>compliant with RFC 4180</remarks>
        public static string wasEnumerableToCSV(IEnumerable<string> l)
        {
            List<string> csv = new List<string>();
            foreach (string s in l)
            {
                List<char> cell = new List<char>();
                foreach (char i in s)
                {
                    cell.Add(i);
                    switch (!i.Equals('"'))
                    {
                        case false:
                            cell.Add(i);
                            break;
                    }
                }
                switch (!cell.Contains('"') && !cell.Contains(' ') && !cell.Contains(',') && !cell.Contains('\r') &&
                        !cell.Contains('\n'))
                {
                    case false:
                        cell.Insert(0, '"');
                        cell.Add('"');
                        break;
                }
                csv.Add(new string(cell.ToArray()));
            }
            return string.Join(",", csv.ToArray());
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Converts a comma-separated list of values to a list of strings.
        /// </summary>
        /// <param name="csv">a comma-separated list of values</param>
        /// <returns>a list of strings</returns>
        /// <remarks>compliant with RFC 4180</remarks>
        public static IEnumerable<string> wasCSVToEnumerable(string csv)
        {
            Stack<char> s = new Stack<char>();
            StringBuilder m = new StringBuilder();
            for (int i = 0; i < csv.Length; ++i)
            {
                switch (csv[i])
                {
                    case ',':
                        if (s.Count.Equals(0) || !s.Peek().Equals('"'))
                        {
                            yield return m.ToString();
                            m = new StringBuilder();
                            continue;
                        }
                        m.Append(csv[i]);
                        continue;
                    case '"':
                        if (i + 1 < csv.Length && csv[i] == csv[i + 1])
                        {
                            m.Append(csv[i]);
                            ++i;
                            continue;
                        }
                        if (s.Count.Equals(0) || !s.Peek().Equals(csv[i]))
                        {
                            s.Push(csv[i]);
                            continue;
                        }
                        s.Pop();
                        continue;
                }
                m.Append(csv[i]);
            }

            yield return m.ToString();
        }

        /// <summary>
        ///     Material information for Collada DAE Export.
        /// </summary>
        /// <remarks>This class is taken from the Radegast Viewer with changes by Wizardry and Steamworks.</remarks>
        private class MaterialInfo
        {
            public Color4 Color;
            public string Name;
            public UUID TextureID;

            public bool Matches(Primitive.TextureEntryFace TextureEntry)
            {
                return TextureID.Equals(TextureEntry.TextureID) && Color.Equals(TextureEntry.RGBA);
            }
        }

        /// <summary>
        ///     Constants for Corrade's integrated chat bot.
        /// </summary>
        private struct AIML_BOT_CONSTANTS
        {
            public const string DIRECTORY = @"AIMLBot";
            public const string BRAIN_FILE = @"AIMLBot.brain";
            public const string BRAIN_SESSION_FILE = @"AIMLbot.session";

            public struct AIML
            {
                public const string DIRECTORY = @"AIML";
            }

            public struct BRAIN
            {
                public const string DIRECTORY = @"brain";
            }

            public struct CONFIG
            {
                public const string DIRECTORY = @"config";
                public const string SETTINGS_FILE = @"Settings.xml";
                public const string NAME = @"NAME";
                public const string AIMLDIRECTORY = @"AIMLDIRECTORY";
                public const string CONFIGDIRECTORY = @"CONFIGDIRECTORY";
                public const string LOGDIRECTORY = @"LOGDIRECTORY";
            }

            public struct LOG
            {
                public const string DIRECTORY = @"logs";
            }
        }

        /// <summary>
        ///     Possible actions.
        /// </summary>
        private enum Action : uint
        {
            [Description("none")] NONE = 0,
            [Description("get")] GET,
            [Description("set")] SET,
            [Description("add")] ADD,
            [Description("remove")] REMOVE,
            [Description("start")] START,
            [Description("stop")] STOP,
            [Description("mute")] MUTE,
            [Description("unmute")] UNMUTE,
            [Description("restart")] RESTART,
            [Description("cancel")] CANCEL,
            [Description("accept")] ACCEPT,
            [Description("decline")] DECLINE,
            [Description("online")] ONLINE,
            [Description("offline")] OFFLINE,
            [Description("request")] REQUEST,
            [Description("response")] RESPONSE,
            [Description("delete")] DELETE,
            [Description("take")] TAKE,
            [Description("read")] READ,
            [Description("wrtie")] WRITE,
            [Description("purge")] PURGE,
            [Description("crossed")] CROSSED,
            [Description("changed")] CHANGED,
            [Description("reply")] REPLY,
            [Description("offer")] OFFER,
            [Description("generic")] GENERIC,
            [Description("point")] POINT,
            [Description("look")] LOOK,
            [Description("update")] UPDATE,
            [Description("received")] RECEIVED,
            [Description("joined")] JOINED,
            [Description("parted")] PARTED,
            [Description("save")] SAVE,
            [Description("load")] LOAD,
            [Description("enable")] ENABLE,
            [Description("disable")] DISABLE,
            [Description("process")] PROCESS,
            [Description("rebuild")] REBUILD,
            [Description("clear")] CLEAR,
            [Description("ls")] LS,
            [Description("cwd")] CWD,
            [Description("cd")] CD,
            [Description("mkdir")] MKDIR,
            [Description("chmod")] CHMOD,
            [Description("rm")] RM,
            [Description("ln")] LN,
            [Description("mv")] MV,
            [Description("cp")] CP,
            [Description("appear")] APPEAR,
            [Description("vanish")] VANISH,
            [Description("list")] LIST
        }

        /// <summary>
        ///     Agent structure.
        /// </summary>
        private struct Agent
        {
            [Description("firstname")] public string FirstName;
            [Description("lastname")] public string LastName;
            [Description("uuid")] public UUID UUID;
        }

        /// <summary>
        ///     A structure to track Beam effects.
        /// </summary>
        private struct BeamEffect
        {
            [Description("alpha")] public float Alpha;
            [Description("color")] public Vector3 Color;
            [Description("duration")] public float Duration;
            [Description("effect")] public UUID Effect;
            [Description("offset")] public Vector3d Offset;
            [Description("source")] public UUID Source;
            [Description("target")] public UUID Target;
            [Description("termination")] public DateTime Termination;
        }

        /// <summary>
        ///     Constants used by Corrade.
        /// </summary>
        private struct CORRADE_CONSTANTS
        {
            /// <summary>
            ///     Copyright.
            /// </summary>
            public const string COPYRIGHT = @"(c) Copyright 2013 Wizardry and Steamworks";

            public const string WIZARDRY_AND_STEAMWORKS = @"Wizardry and Steamworks";
            public const string CORRADE = @"Corrade";
            public const string WIZARDRY_AND_STEAMWORKS_WEBSITE = @"http://was.fm";

            /// <summary>
            ///     Censor characters for passwords.
            /// </summary>
            public const string PASSWORD_CENSOR = "***";

            /// <summary>
            ///     Corrade channel sent to the simulator.
            /// </summary>
            public const string CLIENT_CHANNEL = @"[Wizardry and Steamworks]:Corrade";

            public const string CURRENT_OUTFIT_FOLDER_NAME = @"Current Outfit";
            public const string DEFAULT_SERVICE_NAME = @"Corrade";
            public const string LOG_FACILITY = @"Application";
            public const string WEB_REQUEST = @"Web Request";
            public const string CONFIGURATION_FILE = @"Corrade.ini";
            public const string DATE_TIME_STAMP = @"dd-MM-yyyy HH:mm";
            public const string INVENTORY_CACHE_FILE = @"Inventory.cache";
            public const string AGENT_CACHE_FILE = @"Agent.cache";
            public const string GROUP_CACHE_FILE = @"Group.cache";
            public const string PATH_SEPARATOR = @"/";
            public const string ERROR_SEPARATOR = @" : ";
            public const string CACHE_DIRECTORY = @"cache";
            public const string LOG_FILE_EXTENSION = @"log";
            public const string STATE_DIRECTORY = @"state";
            public const string NOTIFICATIONS_STATE_FILE = @"Notifications.state";
            public const string INVENTORY_OFFERS_STATE_FILE = @"InventoryOffers.state";

            public static readonly Regex AvatarFullNameRegex = new Regex(@"^(?<first>.*?)([\s\.]|$)(?<last>.*?)$",
                RegexOptions.Compiled);

            public static readonly Regex OneOrMoRegex = new Regex(@".+?", RegexOptions.Compiled);

            public static readonly Regex InventoryOfferObjectNameRegEx = new Regex(@"^[']{0,1}(.+?)(('\s)|$)",
                RegexOptions.Compiled);

            public static readonly Regex EjectedFromGroupRegEx =
                new Regex(@"You have been ejected from '(.+?)' by .+?\.$", RegexOptions.Compiled);

            /// <summary>
            ///     Conten-types that Corrade can send and receive.
            /// </summary>
            public struct CONTENT_TYPE
            {
                public const string TEXT_PLAIN = @"text/plain";
                public const string WWW_FORM_URLENCODED = @"application/x-www-form-urlencoded";
            }

            public struct PERMISSIONS
            {
                public const string NONE = @"------------------------------";
            }

            /// <summary>
            ///     Corrade version.
            /// </summary>
            public static readonly string CORRADE_VERSION = Assembly.GetEntryAssembly().GetName().Version.ToString();

            /// <summary>
            ///     Corrade compile date.
            /// </summary>
            public static readonly string CORRADE_COMPILE_DATE = new DateTime(2000, 1, 1).Add(new TimeSpan(
                TimeSpan.TicksPerDay*Assembly.GetEntryAssembly().GetName().Version.Build + // days since 1 January 2000
                TimeSpan.TicksPerSecond*2*Assembly.GetEntryAssembly().GetName().Version.Revision)).ToLongDateString();

            /// <summary>
            ///     Corrade Logo.
            /// </summary>
            public static readonly List<string> LOGO = new List<string>
            {
                @"",
                @"       _..--=--..._  ",
                @"    .-'            '-.  .-.  ",
                @"   /.'              '.\/  /  ",
                @"  |=-     Corrade    -=| (  ",
                @"   \'.              .'/\  \  ",
                @"    '-.,_____ _____.-'  '-'  ",
                @"          [_____]=8  ",
                @"               \  ",
                @"                 Good day!  ",
                @"",
                string.Format(CultureInfo.InvariantCulture, "Version: {0}, Compiled: {1}", CORRADE_VERSION,
                    CORRADE_COMPILE_DATE),
                string.Format(CultureInfo.InvariantCulture, "Copyright: {0}", COPYRIGHT)
            };
        }

        /// <summary>
        ///     Corrade's caches.
        /// </summary>
        public struct Cache
        {
            public static HashSet<Agents> AgentCache = new HashSet<Agents>();
            public static HashSet<Groups> GroupCache = new HashSet<Groups>();
            public static HashSet<UUID> CurrentGroupsCache = new HashSet<UUID>();

            internal static void Purge()
            {
                lock (Locks.AgentCacheLock)
                {
                    AgentCache.Clear();
                }
                lock (Locks.GroupCacheLock)
                {
                    GroupCache.Clear();
                }
                lock (Locks.CurrentGroupsCacheLock)
                {
                    CurrentGroupsCache.Clear();
                }
            }

            /// <summary>
            ///     Serializes to a file.
            /// </summary>
            /// <param name="FileName">File path of the new xml file</param>
            /// <param name="o">the object to save</param>
            public static void Save<T>(string FileName, T o)
            {
                try
                {
                    using (StreamWriter writer = new StreamWriter(FileName))
                    {
                        XmlSerializer serializer = new XmlSerializer(typeof (T));
                        serializer.Serialize(writer, o);
                        writer.Flush();
                    }
                }
                catch (Exception e)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_CACHE), e.Message);
                }
            }

            /// <summary>
            ///     Load an object from an xml file
            /// </summary>
            /// <param name="FileName">Xml file name</param>
            /// <param name="o">the object to load to</param>
            /// <returns>The object created from the xml file</returns>
            public static T Load<T>(string FileName, T o)
            {
                if (!File.Exists(FileName)) return o;
                try
                {
                    using (FileStream stream = File.OpenRead(FileName))
                    {
                        XmlSerializer serializer = new XmlSerializer(typeof (T));
                        return (T) serializer.Deserialize(stream);
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_CORRADE_CACHE), ex.Message);
                }
                return o;
            }

            public struct Agents
            {
                public string FirstName;
                public string LastName;
                public UUID UUID;
            }

            public struct Groups
            {
                public string Name;
                public UUID UUID;
            }

            public struct Locks
            {
                public static readonly object AgentCacheLock = new object();
                public static readonly object GroupCacheLock = new object();
                public static readonly object CurrentGroupsCacheLock = new object();
            }
        }

        /// <summary>
        ///     An element from the callback queue waiting to be dispatched.
        /// </summary>
        private struct CallbackQueueElement
        {
            public Dictionary<string, string> message;
            public string URL;
        }

        private struct Configuration
        {
            private static string _firstName;
            private static string _lastName;
            private static string _password;
            private static string _loginURL;
            private static string _instantMessageLogDirectory;
            private static bool _instantMessageLogEnabled;
            private static string _localMessageLogDirectory;
            private static bool _localMessageLogEnabled;
            private static string _regionMessageLogDirectory;
            private static bool _regionMessageLogEnabled;
            private static bool _enableHTTPServer;
            private static string _HTTPServerPrefix;
            private static int _HTTPServerTimeout;
            private static HTTPCompressionMethod _HTTPServerCompression;
            private static int _callbackTimeout;
            private static int _callbackThrottle;
            private static int _callbackQueueLength;
            private static int _notificationTimeout;
            private static int _notificationThrottle;
            private static int _notificationQueueLength;
            private static int _connectionLimit;
            private static int _connectionIdleTime;
            private static float _range;
            private static int _maximumNotificationThreads;
            private static int _maximumCommandThreads;
            private static int _maximumRLVThreads;
            private static int _maximumInstantMessageThreads;
            private static bool _useNaggle;
            private static bool _useExpect100Continue;
            private static int _servicesTimeout;
            private static int _dataTimeout;
            private static wasAdaptiveAlarm.DECAY_TYPE _dataDecayType;
            private static int _rebakeDelay;
            private static int _membershipSweepInterval;
            private static bool _TOSAccepted;
            private static string _startLocation;
            private static string _bindIPAddress;
            private static string _networkCardMAC;
            private static string _driveIdentifierHash;
            private static string _clientLogFile;
            private static bool _clientLogEnabled;
            private static bool _autoActivateGroup;
            private static int _activateDelay;
            private static int _groupCreateFee;
            private static int _exitCodeExpected;
            private static int _exitCodeAbnormal;
            private static HashSet<Group> _groups;
            private static HashSet<Master> _masters;
            private static List<Filter> _inputFilters;
            private static List<Filter> _outputFilters;
            private static string _vigenereSecret;
            private static ENIGMA _enigma;
            private static int _logoutGrace;

            public static string FIRST_NAME
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _firstName;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _firstName = value;
                    }
                }
            }

            public static string LAST_NAME
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _lastName;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _lastName = value;
                    }
                }
            }

            public static string PASSWORD
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _password;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _password = value;
                    }
                }
            }

            public static string LOGIN_URL
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _loginURL;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _loginURL = value;
                    }
                }
            }

            public static string INSTANT_MESSAGE_LOG_DIRECTORY
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _instantMessageLogDirectory;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _instantMessageLogDirectory = value;
                    }
                }
            }

            public static bool INSTANT_MESSAGE_LOG_ENABLED
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _instantMessageLogEnabled;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _instantMessageLogEnabled = value;
                    }
                }
            }

            public static string LOCAL_MESSAGE_LOG_DIRECTORY
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _localMessageLogDirectory;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _localMessageLogDirectory = value;
                    }
                }
            }

            public static bool LOCAL_MESSAGE_LOG_ENABLED
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _localMessageLogEnabled;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _localMessageLogEnabled = value;
                    }
                }
            }

            public static string REGION_MESSAGE_LOG_DIRECTORY
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _regionMessageLogDirectory;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _regionMessageLogDirectory = value;
                    }
                }
            }

            public static bool REGION_MESSAGE_LOG_ENABLED
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _regionMessageLogEnabled;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _regionMessageLogEnabled = value;
                    }
                }
            }

            public static bool ENABLE_HTTP_SERVER
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _enableHTTPServer;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _enableHTTPServer = value;
                    }
                }
            }

            public static string HTTP_SERVER_PREFIX
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerPrefix;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerPrefix = value;
                    }
                }
            }

            public static int HTTP_SERVER_TIMEOUT
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerTimeout;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerTimeout = value;
                    }
                }
            }

            public static HTTPCompressionMethod HTTP_SERVER_COMPRESSION
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerCompression;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerCompression = value;
                    }
                }
            }

            public static int CALLBACK_TIMEOUT
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _callbackTimeout;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _callbackTimeout = value;
                    }
                }
            }

            public static int CALLBACK_THROTTLE
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _callbackThrottle;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _callbackThrottle = value;
                    }
                }
            }

            public static int CALLBACK_QUEUE_LENGTH
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _callbackQueueLength;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _callbackQueueLength = value;
                    }
                }
            }

            public static int NOTIFICATION_TIMEOUT
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _notificationTimeout;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _notificationTimeout = value;
                    }
                }
            }

            public static int NOTIFICATION_THROTTLE
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _notificationThrottle;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _notificationThrottle = value;
                    }
                }
            }

            public static int NOTIFICATION_QUEUE_LENGTH
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _notificationQueueLength;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _notificationQueueLength = value;
                    }
                }
            }

            public static int CONNECTION_LIMIT
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _connectionLimit;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _connectionLimit = value;
                    }
                }
            }

            public static int CONNECTION_IDLE_TIME
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _connectionIdleTime;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _connectionIdleTime = value;
                    }
                }
            }

            public static float RANGE
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _range;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _range = value;
                    }
                }
            }

            public static int MAXIMUM_NOTIFICATION_THREADS
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _maximumNotificationThreads;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _maximumNotificationThreads = value;
                    }
                }
            }

            public static int MAXIMUM_COMMAND_THREADS
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _maximumCommandThreads;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _maximumCommandThreads = value;
                    }
                }
            }

            public static int MAXIMUM_RLV_THREADS
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _maximumRLVThreads;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _maximumRLVThreads = value;
                    }
                }
            }

            public static int MAXIMUM_INSTANT_MESSAGE_THREADS
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _maximumInstantMessageThreads;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _maximumInstantMessageThreads = value;
                    }
                }
            }

            public static bool USE_NAGGLE
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _useNaggle;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _useNaggle = value;
                    }
                }
            }

            public static bool USE_EXPECT100CONTINUE
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _useExpect100Continue;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _useExpect100Continue = value;
                    }
                }
            }

            public static int SERVICES_TIMEOUT
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _servicesTimeout;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _servicesTimeout = value;
                    }
                }
            }

            public static int DATA_TIMEOUT
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _dataTimeout;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _dataTimeout = value;
                    }
                }
            }

            public static wasAdaptiveAlarm.DECAY_TYPE DATA_DECAY_TYPE
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _dataDecayType;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _dataDecayType = value;
                    }
                }
            }

            public static int REBAKE_DELAY
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _rebakeDelay;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _rebakeDelay = value;
                    }
                }
            }

            public static int MEMBERSHIP_SWEEP_INTERVAL
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _membershipSweepInterval;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _membershipSweepInterval = value;
                    }
                }
            }

            public static bool TOS_ACCEPTED
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _TOSAccepted;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _TOSAccepted = value;
                    }
                }
            }

            public static string START_LOCATION
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _startLocation;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _startLocation = value;
                    }
                }
            }

            public static string BIND_IP_ADDRESS
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _bindIPAddress;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _bindIPAddress = value;
                    }
                }
            }

            public static string NETWORK_CARD_MAC
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _networkCardMAC;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _networkCardMAC = value;
                    }
                }
            }

            public static string DRIVE_IDENTIFIER_HASH
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _driveIdentifierHash;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _driveIdentifierHash = value;
                    }
                }
            }

            public static string CLIENT_LOG_FILE
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _clientLogFile;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _clientLogFile = value;
                    }
                }
            }

            public static bool CLIENT_LOG_ENABLED
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _clientLogEnabled;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _clientLogEnabled = value;
                    }
                }
            }

            public static bool AUTO_ACTIVATE_GROUP
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _autoActivateGroup;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _autoActivateGroup = value;
                    }
                }
            }

            public static int ACTIVATE_DELAY
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _activateDelay;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _activateDelay = value;
                    }
                }
            }

            public static int GROUP_CREATE_FEE
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _groupCreateFee;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _groupCreateFee = value;
                    }
                }
            }

            public static int EXIT_CODE_EXPECTED
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _exitCodeExpected;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _exitCodeExpected = value;
                    }
                }
            }

            public static int EXIT_CODE_ABNORMAL
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _exitCodeAbnormal;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _exitCodeAbnormal = value;
                    }
                }
            }

            public static HashSet<Group> GROUPS
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _groups;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _groups = value;
                    }
                }
            }

            public static HashSet<Master> MASTERS
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _masters;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _masters = value;
                    }
                }
            }

            public static List<Filter> INPUT_FILTERS
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _inputFilters;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _inputFilters = value;
                    }
                }
            }

            public static List<Filter> OUTPUT_FILTERS
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _outputFilters;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _outputFilters = value;
                    }
                }
            }

            public static string VIGENERE_SECRET
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _vigenereSecret;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _vigenereSecret = value;
                    }
                }
            }

            public static ENIGMA ENIGMA
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _enigma;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _enigma = value;
                    }
                }
            }

            public static int LOGOUT_GRACE
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _logoutGrace;
                    }
                }
                private set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _logoutGrace = value;
                    }
                }
            }

            public static string Read(string file)
            {
                lock (ConfigurationFileLock)
                {
                    return File.ReadAllText(file);
                }
            }

            public static void Write(string file, string data)
            {
                lock (ConfigurationFileLock)
                {
                    File.WriteAllText(file, data);
                }
            }

            public static void Write(string file, XmlDocument document)
            {
                lock (ConfigurationFileLock)
                {
                    document.Save(file);
                }
            }

            public static void Load(string file)
            {
                FIRST_NAME = string.Empty;
                LAST_NAME = string.Empty;
                PASSWORD = string.Empty;
                LOGIN_URL = @"https://login.agni.lindenlab.com/cgi-bin/login.cgi";
                CLIENT_LOG_FILE = "logs/Corrade.log";
                CLIENT_LOG_ENABLED = true;
                INSTANT_MESSAGE_LOG_DIRECTORY = @"logs/im";
                INSTANT_MESSAGE_LOG_ENABLED = false;
                LOCAL_MESSAGE_LOG_DIRECTORY = @"logs/local";
                LOCAL_MESSAGE_LOG_ENABLED = false;
                REGION_MESSAGE_LOG_DIRECTORY = @"logs/region";
                REGION_MESSAGE_LOG_ENABLED = false;
                ENABLE_HTTP_SERVER = false;
                HTTP_SERVER_PREFIX = @"http://+:8080/";
                HTTP_SERVER_TIMEOUT = 5000;
                HTTP_SERVER_COMPRESSION = HTTPCompressionMethod.NONE;
                CALLBACK_TIMEOUT = 5000;
                CALLBACK_THROTTLE = 1000;
                CALLBACK_QUEUE_LENGTH = 100;
                NOTIFICATION_TIMEOUT = 5000;
                NOTIFICATION_THROTTLE = 1000;
                NOTIFICATION_QUEUE_LENGTH = 100;
                CONNECTION_LIMIT = 100;
                CONNECTION_IDLE_TIME = 900000;
                RANGE = 64;
                MAXIMUM_NOTIFICATION_THREADS = 10;
                MAXIMUM_COMMAND_THREADS = 10;
                MAXIMUM_RLV_THREADS = 10;
                MAXIMUM_INSTANT_MESSAGE_THREADS = 10;
                USE_NAGGLE = false;
                SERVICES_TIMEOUT = 60000;
                DATA_TIMEOUT = 2500;
                DATA_DECAY_TYPE = wasAdaptiveAlarm.DECAY_TYPE.ARITHMETIC;
                REBAKE_DELAY = 1000;
                ACTIVATE_DELAY = 5000;
                MEMBERSHIP_SWEEP_INTERVAL = 1000;
                TOS_ACCEPTED = false;
                START_LOCATION = "last";
                BIND_IP_ADDRESS = string.Empty;
                NETWORK_CARD_MAC = string.Empty;
                DRIVE_IDENTIFIER_HASH = string.Empty;
                AUTO_ACTIVATE_GROUP = false;
                GROUP_CREATE_FEE = 100;
                EXIT_CODE_EXPECTED = -1;
                EXIT_CODE_ABNORMAL = -2;
                GROUPS = new HashSet<Group>();
                MASTERS = new HashSet<Master>();
                INPUT_FILTERS = new List<Filter> {Filter.RFC1738};
                OUTPUT_FILTERS = new List<Filter> {Filter.RFC1738};
                ENIGMA = new ENIGMA
                {
                    rotors = new[] {'3', 'g', '1'},
                    plugs = new[] {'z', 'p', 'q'},
                    reflector = 'b'
                };
                VIGENERE_SECRET = string.Empty;

                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.READING_CORRADE_CONFIGURATION));

                try
                {
                    lock (ConfigurationFileLock)
                    {
                        file = File.ReadAllText(file);
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                    Environment.Exit(EXIT_CODE_ABNORMAL);
                }

                XmlDocument conf = new XmlDocument();
                try
                {
                    conf.LoadXml(file);
                }
                catch (XmlException ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                    Environment.Exit(EXIT_CODE_ABNORMAL);
                }

                XmlNode root = conf.DocumentElement;
                if (root == null)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE));
                    Environment.Exit(EXIT_CODE_ABNORMAL);
                }

                // Process client.
                try
                {
                    foreach (XmlNode client in root.SelectNodes("/config/client/*"))
                        switch (client.Name.ToLowerInvariant())
                        {
                            case ConfigurationKeys.FIRST_NAME:
                                if (string.IsNullOrEmpty(client.InnerText))
                                {
                                    throw new Exception("error in client section");
                                }
                                FIRST_NAME = client.InnerText;
                                break;
                            case ConfigurationKeys.LAST_NAME:
                                if (string.IsNullOrEmpty(client.InnerText))
                                {
                                    throw new Exception("error in client section");
                                }
                                LAST_NAME = client.InnerText;
                                break;
                            case ConfigurationKeys.PASSWORD:
                                if (string.IsNullOrEmpty(client.InnerText))
                                {
                                    throw new Exception("error in client section");
                                }
                                PASSWORD = client.InnerText;
                                break;
                            case ConfigurationKeys.LOGIN_URL:
                                if (string.IsNullOrEmpty(client.InnerText))
                                {
                                    throw new Exception("error in client section");
                                }
                                LOGIN_URL = client.InnerText;
                                break;
                            case ConfigurationKeys.TOS_ACCEPTED:
                                bool accepted;
                                if (!bool.TryParse(client.InnerText, out accepted))
                                {
                                    throw new Exception("error in client section");
                                }
                                TOS_ACCEPTED = accepted;
                                break;
                            case ConfigurationKeys.GROUP_CREATE_FEE:
                                int groupCreateFee;
                                if (!int.TryParse(client.InnerText, out groupCreateFee))
                                {
                                    throw new Exception("error in client section");
                                }
                                GROUP_CREATE_FEE = groupCreateFee;
                                break;
                            case ConfigurationKeys.EXIT_CODE:
                                XmlNodeList exitCodeNodeList = client.SelectNodes("*");
                                if (exitCodeNodeList == null)
                                {
                                    throw new Exception("error in client section");
                                }
                                foreach (XmlNode exitCodeNode in exitCodeNodeList)
                                {
                                    switch (exitCodeNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.EXPECTED:
                                            int exitCodeExpected;
                                            if (!int.TryParse(exitCodeNode.InnerText, out exitCodeExpected))
                                            {
                                                throw new Exception("error in client section");
                                            }
                                            EXIT_CODE_EXPECTED = exitCodeExpected;
                                            break;
                                        case ConfigurationKeys.ABNORMAL:
                                            int exitCodeAbnormal;
                                            if (!int.TryParse(exitCodeNode.InnerText, out exitCodeAbnormal))
                                            {
                                                throw new Exception("error in client section");
                                            }
                                            EXIT_CODE_ABNORMAL = exitCodeAbnormal;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.AUTO_ACTIVATE_GROUP:
                                bool autoActivateGroup;
                                if (!bool.TryParse(client.InnerText, out autoActivateGroup))
                                {
                                    throw new Exception("error in client section");
                                }
                                AUTO_ACTIVATE_GROUP = autoActivateGroup;
                                break;
                            case ConfigurationKeys.START_LOCATION:
                                if (string.IsNullOrEmpty(client.InnerText))
                                {
                                    throw new Exception("error in client section");
                                }
                                START_LOCATION = client.InnerText;
                                break;
                        }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                }

                // Process logs.
                try
                {
                    foreach (XmlNode LogNode in root.SelectNodes("/config/logs/*"))
                    {
                        switch (LogNode.Name.ToLowerInvariant())
                        {
                            case ConfigurationKeys.IM:
                                XmlNodeList imLogNodeList = LogNode.SelectNodes("*");
                                if (imLogNodeList == null)
                                {
                                    throw new Exception("error in logs section");
                                }
                                foreach (XmlNode imLogNode in imLogNodeList)
                                {
                                    switch (imLogNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.ENABLE:
                                            bool enable;
                                            if (!bool.TryParse(imLogNode.InnerText, out enable))
                                            {
                                                throw new Exception("error in im logs section");
                                            }
                                            INSTANT_MESSAGE_LOG_ENABLED = enable;
                                            break;
                                        case ConfigurationKeys.DIRECTORY:
                                            if (string.IsNullOrEmpty(imLogNode.InnerText))
                                            {
                                                throw new Exception("error in im logs section");
                                            }
                                            INSTANT_MESSAGE_LOG_DIRECTORY = imLogNode.InnerText;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.CLIENT:
                                XmlNodeList clientLogNodeList = LogNode.SelectNodes("*");
                                if (clientLogNodeList == null)
                                {
                                    throw new Exception("error in logs section");
                                }
                                foreach (XmlNode clientLogNode in clientLogNodeList)
                                {
                                    switch (clientLogNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.ENABLE:
                                            bool enable;
                                            if (!bool.TryParse(clientLogNode.InnerText, out enable))
                                            {
                                                throw new Exception("error in client logs section");
                                            }
                                            CLIENT_LOG_ENABLED = enable;
                                            break;
                                        case ConfigurationKeys.FILE:
                                            if (string.IsNullOrEmpty(clientLogNode.InnerText))
                                            {
                                                throw new Exception("error in client logs section");
                                            }
                                            CLIENT_LOG_FILE = clientLogNode.InnerText;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.LOCAL:
                                XmlNodeList localLogNodeList = LogNode.SelectNodes("*");
                                if (localLogNodeList == null)
                                {
                                    throw new Exception("error in logs section");
                                }
                                foreach (XmlNode localLogNode in localLogNodeList)
                                {
                                    switch (localLogNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.ENABLE:
                                            bool enable;
                                            if (!bool.TryParse(localLogNode.InnerText, out enable))
                                            {
                                                throw new Exception("error in local logs section");
                                            }
                                            LOCAL_MESSAGE_LOG_ENABLED = enable;
                                            break;
                                        case ConfigurationKeys.DIRECTORY:
                                            if (string.IsNullOrEmpty(localLogNode.InnerText))
                                            {
                                                throw new Exception("error in local logs section");
                                            }
                                            LOCAL_MESSAGE_LOG_DIRECTORY = localLogNode.InnerText;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.REGION:
                                XmlNodeList regionLogNodeList = LogNode.SelectNodes("*");
                                if (regionLogNodeList == null)
                                {
                                    throw new Exception("error in logs section");
                                }
                                foreach (XmlNode regionLogNode in regionLogNodeList)
                                {
                                    switch (regionLogNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.ENABLE:
                                            bool enable;
                                            if (!bool.TryParse(regionLogNode.InnerText, out enable))
                                            {
                                                throw new Exception("error in local logs section");
                                            }
                                            REGION_MESSAGE_LOG_ENABLED = enable;
                                            break;
                                        case ConfigurationKeys.DIRECTORY:
                                            if (string.IsNullOrEmpty(regionLogNode.InnerText))
                                            {
                                                throw new Exception("error in local logs section");
                                            }
                                            REGION_MESSAGE_LOG_DIRECTORY = regionLogNode.InnerText;
                                            break;
                                    }
                                }
                                break;
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                }


                // Process filters.
                try
                {
                    foreach (XmlNode FilterNode in root.SelectNodes("/config/filters/*"))
                    {
                        switch (FilterNode.Name.ToLowerInvariant())
                        {
                            case ConfigurationKeys.INPUT:
                                XmlNodeList inputFilterNodeList = FilterNode.SelectNodes("*");
                                if (inputFilterNodeList == null)
                                {
                                    throw new Exception("error in filters section");
                                }
                                INPUT_FILTERS = new List<Filter>();
                                foreach (XmlNode inputFilterNode in inputFilterNodeList)
                                {
                                    switch (inputFilterNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.ENCODE:
                                        case ConfigurationKeys.DECODE:
                                        case ConfigurationKeys.ENCRYPT:
                                        case ConfigurationKeys.DECRYPT:
                                            INPUT_FILTERS.Add(wasGetEnumValueFromDescription<Filter>(
                                                inputFilterNode.InnerText));
                                            break;
                                        default:
                                            throw new Exception("error in input filters section");
                                    }
                                }
                                break;
                            case ConfigurationKeys.OUTPUT:
                                XmlNodeList outputFilterNodeList = FilterNode.SelectNodes("*");
                                if (outputFilterNodeList == null)
                                {
                                    throw new Exception("error in filters section");
                                }
                                OUTPUT_FILTERS = new List<Filter>();
                                foreach (XmlNode outputFilterNode in outputFilterNodeList)
                                {
                                    switch (outputFilterNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.ENCODE:
                                        case ConfigurationKeys.DECODE:
                                        case ConfigurationKeys.ENCRYPT:
                                        case ConfigurationKeys.DECRYPT:
                                            OUTPUT_FILTERS.Add(wasGetEnumValueFromDescription<Filter>(
                                                outputFilterNode.InnerText));
                                            break;
                                        default:
                                            throw new Exception("error in output filters section");
                                    }
                                }
                                break;
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                }

                // Process cryptography.
                try
                {
                    foreach (XmlNode FilterNode in root.SelectNodes("/config/cryptography/*"))
                    {
                        switch (FilterNode.Name.ToLowerInvariant())
                        {
                            case ConfigurationKeys.ENIGMA:
                                XmlNodeList ENIGMANodeList = FilterNode.SelectNodes("*");
                                if (ENIGMANodeList == null)
                                {
                                    throw new Exception("error in cryptography section");
                                }
                                ENIGMA enigma = new ENIGMA();
                                foreach (XmlNode ENIGMANode in ENIGMANodeList)
                                {
                                    switch (ENIGMANode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.ROTORS:
                                            enigma.rotors = ENIGMANode.InnerText.ToArray();
                                            break;
                                        case ConfigurationKeys.PLUGS:
                                            enigma.plugs = ENIGMANode.InnerText.ToArray();
                                            break;
                                        case ConfigurationKeys.REFLECTOR:
                                            enigma.reflector = ENIGMANode.InnerText.SingleOrDefault();
                                            break;
                                    }
                                }
                                ENIGMA = enigma;
                                break;
                            case ConfigurationKeys.VIGENERE:
                                XmlNodeList VIGENERENodeList = FilterNode.SelectNodes("*");
                                if (VIGENERENodeList == null)
                                {
                                    throw new Exception("error in cryptography section");
                                }
                                foreach (XmlNode VIGENERENode in VIGENERENodeList)
                                {
                                    switch (VIGENERENode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.SECRET:
                                            VIGENERE_SECRET = VIGENERENode.InnerText;
                                            break;
                                    }
                                }
                                break;
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                }


                // Process AIML.
                try
                {
                    foreach (XmlNode AIMLNode in root.SelectNodes("/config/aiml/*"))
                    {
                        switch (AIMLNode.Name.ToLowerInvariant())
                        {
                            case ConfigurationKeys.ENABLE:
                                bool enable;
                                if (!bool.TryParse(AIMLNode.InnerText, out enable))
                                {
                                    throw new Exception("error in AIML section");
                                }
                                EnableAIML = enable;
                                break;
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                }

                // Process RLV.
                try
                {
                    foreach (XmlNode RLVNode in root.SelectNodes("/config/rlv/*"))
                    {
                        switch (RLVNode.Name.ToLowerInvariant())
                        {
                            case ConfigurationKeys.ENABLE:
                                bool enable;
                                if (!bool.TryParse(RLVNode.InnerText, out enable))
                                {
                                    throw new Exception("error in RLV section");
                                }
                                EnableRLV = enable;
                                break;
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                }

                // Process server.
                try
                {
                    foreach (XmlNode serverNode in root.SelectNodes("/config/server/*"))
                    {
                        switch (serverNode.Name.ToLowerInvariant())
                        {
                            case ConfigurationKeys.HTTP:
                                bool enableHTTPServer;
                                if (!bool.TryParse(serverNode.InnerText, out enableHTTPServer))
                                {
                                    throw new Exception("error in server section");
                                }
                                ENABLE_HTTP_SERVER = enableHTTPServer;
                                break;
                            case ConfigurationKeys.PREFIX:
                                if (string.IsNullOrEmpty(serverNode.InnerText))
                                {
                                    throw new Exception("error in server section");
                                }
                                HTTP_SERVER_PREFIX = serverNode.InnerText;
                                break;
                            case ConfigurationKeys.COMPRESSION:
                                HTTP_SERVER_COMPRESSION = wasGetEnumValueFromDescription<HTTPCompressionMethod>(
                                    serverNode.InnerText);
                                break;
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                }

                // Process network.
                try
                {
                    foreach (XmlNode networkNode in root.SelectNodes("/config/network/*"))
                    {
                        switch (networkNode.Name.ToLowerInvariant())
                        {
                            case ConfigurationKeys.BIND:
                                if (!string.IsNullOrEmpty(networkNode.InnerText))
                                {
                                    BIND_IP_ADDRESS = networkNode.InnerText;
                                }
                                break;
                            case ConfigurationKeys.MAC:
                                if (!string.IsNullOrEmpty(networkNode.InnerText))
                                {
                                    NETWORK_CARD_MAC = networkNode.InnerText;
                                }
                                break;
                            case ConfigurationKeys.ID0:
                                if (!string.IsNullOrEmpty(networkNode.InnerText))
                                {
                                    DRIVE_IDENTIFIER_HASH = networkNode.InnerText;
                                }
                                break;
                            case ConfigurationKeys.NAGGLE:
                                bool useNaggle;
                                if (!bool.TryParse(networkNode.InnerText, out useNaggle))
                                {
                                    throw new Exception("error in network section");
                                }
                                USE_NAGGLE = useNaggle;
                                break;
                            case ConfigurationKeys.EXPECT100CONTINUE:
                                bool useExpect100Continue;
                                if (!bool.TryParse(networkNode.InnerText, out useExpect100Continue))
                                {
                                    throw new Exception("error in network section");
                                }
                                USE_EXPECT100CONTINUE = useExpect100Continue;
                                break;
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                }

                // Process limits.
                try
                {
                    foreach (XmlNode limitsNode in root.SelectNodes("/config/limits/*"))
                    {
                        switch (limitsNode.Name.ToLowerInvariant())
                        {
                            case ConfigurationKeys.RANGE:
                                float range;
                                if (!float.TryParse(limitsNode.InnerText,
                                    out range))
                                {
                                    throw new Exception("error in range limits section");
                                }
                                RANGE = range;
                                break;
                            case ConfigurationKeys.RLV:
                                XmlNodeList rlvLimitNodeList = limitsNode.SelectNodes("*");
                                if (rlvLimitNodeList == null)
                                {
                                    throw new Exception("error in RLV limits section");
                                }
                                foreach (XmlNode rlvLimitNode in rlvLimitNodeList)
                                {
                                    switch (rlvLimitNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.THREADS:
                                            int maximumRLVThreads;
                                            if (
                                                !int.TryParse(rlvLimitNode.InnerText,
                                                    out maximumRLVThreads))
                                            {
                                                throw new Exception("error in RLV limits section");
                                            }
                                            MAXIMUM_RLV_THREADS = maximumRLVThreads;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.COMMANDS:
                                XmlNodeList commandsLimitNodeList = limitsNode.SelectNodes("*");
                                if (commandsLimitNodeList == null)
                                {
                                    throw new Exception("error in commands limits section");
                                }
                                foreach (XmlNode commandsLimitNode in commandsLimitNodeList)
                                {
                                    switch (commandsLimitNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.THREADS:
                                            int maximumCommandThreads;
                                            if (
                                                !int.TryParse(commandsLimitNode.InnerText,
                                                    out maximumCommandThreads))
                                            {
                                                throw new Exception("error in commands limits section");
                                            }
                                            MAXIMUM_COMMAND_THREADS = maximumCommandThreads;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.IM:
                                XmlNodeList instantMessageLimitNodeList = limitsNode.SelectNodes("*");
                                if (instantMessageLimitNodeList == null)
                                {
                                    throw new Exception("error in instant message limits section");
                                }
                                foreach (XmlNode instantMessageLimitNode in instantMessageLimitNodeList)
                                {
                                    switch (instantMessageLimitNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.THREADS:
                                            int maximumInstantMessageThreads;
                                            if (
                                                !int.TryParse(instantMessageLimitNode.InnerText,
                                                    out maximumInstantMessageThreads))
                                            {
                                                throw new Exception("error in instant message limits section");
                                            }
                                            MAXIMUM_INSTANT_MESSAGE_THREADS = maximumInstantMessageThreads;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.CLIENT:
                                XmlNodeList clientLimitNodeList = limitsNode.SelectNodes("*");
                                if (clientLimitNodeList == null)
                                {
                                    throw new Exception("error in client limits section");
                                }
                                foreach (XmlNode clientLimitNode in clientLimitNodeList)
                                {
                                    switch (clientLimitNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.CONNECTIONS:
                                            int connectionLimit;
                                            if (
                                                !int.TryParse(clientLimitNode.InnerText,
                                                    out connectionLimit))
                                            {
                                                throw new Exception("error in client limits section");
                                            }
                                            CONNECTION_LIMIT = connectionLimit;
                                            break;
                                        case ConfigurationKeys.IDLE:
                                            int connectionIdleTime;
                                            if (
                                                !int.TryParse(clientLimitNode.InnerText,
                                                    out connectionIdleTime))
                                            {
                                                throw new Exception("error in client limits section");
                                            }
                                            CONNECTION_IDLE_TIME = connectionIdleTime;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.CALLBACKS:
                                XmlNodeList callbackLimitNodeList = limitsNode.SelectNodes("*");
                                if (callbackLimitNodeList == null)
                                {
                                    throw new Exception("error in callback limits section");
                                }
                                foreach (XmlNode callbackLimitNode in callbackLimitNodeList)
                                {
                                    switch (callbackLimitNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.TIMEOUT:
                                            int callbackTimeout;
                                            if (!int.TryParse(callbackLimitNode.InnerText, out callbackTimeout))
                                            {
                                                throw new Exception("error in callback limits section");
                                            }
                                            CALLBACK_TIMEOUT = callbackTimeout;
                                            break;
                                        case ConfigurationKeys.THROTTLE:
                                            int callbackThrottle;
                                            if (
                                                !int.TryParse(callbackLimitNode.InnerText, out callbackThrottle))
                                            {
                                                throw new Exception("error in callback limits section");
                                            }
                                            CALLBACK_THROTTLE = callbackThrottle;
                                            break;
                                        case ConfigurationKeys.QUEUE_LENGTH:
                                            int callbackQueueLength;
                                            if (
                                                !int.TryParse(callbackLimitNode.InnerText,
                                                    out callbackQueueLength))
                                            {
                                                throw new Exception("error in callback limits section");
                                            }
                                            CALLBACK_QUEUE_LENGTH = callbackQueueLength;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.NOTIFICATIONS:
                                XmlNodeList notificationLimitNodeList = limitsNode.SelectNodes("*");
                                if (notificationLimitNodeList == null)
                                {
                                    throw new Exception("error in notification limits section");
                                }
                                foreach (XmlNode notificationLimitNode in notificationLimitNodeList)
                                {
                                    switch (notificationLimitNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.TIMEOUT:
                                            int notificationTimeout;
                                            if (
                                                !int.TryParse(notificationLimitNode.InnerText,
                                                    out notificationTimeout))
                                            {
                                                throw new Exception("error in notification limits section");
                                            }
                                            NOTIFICATION_TIMEOUT = notificationTimeout;
                                            break;
                                        case ConfigurationKeys.THROTTLE:
                                            int notificationThrottle;
                                            if (
                                                !int.TryParse(notificationLimitNode.InnerText,
                                                    out notificationThrottle))
                                            {
                                                throw new Exception("error in notification limits section");
                                            }
                                            NOTIFICATION_THROTTLE = notificationThrottle;
                                            break;
                                        case ConfigurationKeys.QUEUE_LENGTH:
                                            int notificationQueueLength;
                                            if (
                                                !int.TryParse(notificationLimitNode.InnerText,
                                                    out notificationQueueLength))
                                            {
                                                throw new Exception("error in notification limits section");
                                            }
                                            NOTIFICATION_QUEUE_LENGTH = notificationQueueLength;
                                            break;
                                        case ConfigurationKeys.THREADS:
                                            int maximumNotificationThreads;
                                            if (
                                                !int.TryParse(notificationLimitNode.InnerText,
                                                    out maximumNotificationThreads))
                                            {
                                                throw new Exception("error in notification limits section");
                                            }
                                            MAXIMUM_NOTIFICATION_THREADS = maximumNotificationThreads;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.SERVER:
                                XmlNodeList HTTPServerLimitNodeList = limitsNode.SelectNodes("*");
                                if (HTTPServerLimitNodeList == null)
                                {
                                    throw new Exception("error in server limits section");
                                }
                                foreach (XmlNode HTTPServerLimitNode in HTTPServerLimitNodeList)
                                {
                                    switch (HTTPServerLimitNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.TIMEOUT:
                                            int HTTPServerTimeout;
                                            if (
                                                !int.TryParse(HTTPServerLimitNode.InnerText,
                                                    out HTTPServerTimeout))
                                            {
                                                throw new Exception("error in server limits section");
                                            }
                                            HTTP_SERVER_TIMEOUT = HTTPServerTimeout;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.SERVICES:
                                XmlNodeList servicesLimitNodeList = limitsNode.SelectNodes("*");
                                if (servicesLimitNodeList == null)
                                {
                                    throw new Exception("error in services limits section");
                                }
                                foreach (XmlNode servicesLimitNode in servicesLimitNodeList)
                                {
                                    switch (servicesLimitNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.TIMEOUT:
                                            int servicesTimeout;
                                            if (
                                                !int.TryParse(servicesLimitNode.InnerText,
                                                    out servicesTimeout))
                                            {
                                                throw new Exception("error in services limits section");
                                            }
                                            SERVICES_TIMEOUT = servicesTimeout;
                                            break;
                                        case ConfigurationKeys.REBAKE:
                                            int rebakeDelay;
                                            if (!int.TryParse(servicesLimitNode.InnerText, out rebakeDelay))
                                            {
                                                throw new Exception("error in services limits section");
                                            }
                                            REBAKE_DELAY = rebakeDelay;
                                            break;
                                        case ConfigurationKeys.ACTIVATE:
                                            int activateDelay;
                                            if (
                                                !int.TryParse(servicesLimitNode.InnerText,
                                                    out activateDelay))
                                            {
                                                throw new Exception("error in services limits section");
                                            }
                                            ACTIVATE_DELAY = activateDelay;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.DATA:
                                XmlNodeList dataLimitNodeList = limitsNode.SelectNodes("*");
                                if (dataLimitNodeList == null)
                                {
                                    throw new Exception("error in data limits section");
                                }
                                foreach (XmlNode dataLimitNode in dataLimitNodeList)
                                {
                                    switch (dataLimitNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.TIMEOUT:
                                            int dataTimeout;
                                            if (
                                                !int.TryParse(dataLimitNode.InnerText,
                                                    out dataTimeout))
                                            {
                                                throw new Exception("error in data limits section");
                                            }
                                            DATA_TIMEOUT = dataTimeout;
                                            break;
                                        case ConfigurationKeys.DECAY:
                                            DATA_DECAY_TYPE =
                                                wasGetEnumValueFromDescription<wasAdaptiveAlarm.DECAY_TYPE>(
                                                    dataLimitNode.InnerText);
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.MEMBERSHIP:
                                XmlNodeList membershipLimitNodeList = limitsNode.SelectNodes("*");
                                if (membershipLimitNodeList == null)
                                {
                                    throw new Exception("error in membership limits section");
                                }
                                foreach (XmlNode servicesLimitNode in membershipLimitNodeList)
                                {
                                    switch (servicesLimitNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.SWEEP:
                                            int membershipSweepInterval;
                                            if (
                                                !int.TryParse(servicesLimitNode.InnerText,
                                                    out membershipSweepInterval))
                                            {
                                                throw new Exception("error in membership limits section");
                                            }
                                            MEMBERSHIP_SWEEP_INTERVAL = membershipSweepInterval;
                                            break;
                                    }
                                }
                                break;
                            case ConfigurationKeys.LOGOUT:
                                XmlNodeList logoutLimitNodeList = limitsNode.SelectNodes("*");
                                if (logoutLimitNodeList == null)
                                {
                                    throw new Exception("error in logout limits section");
                                }
                                foreach (XmlNode logoutLimitNode in logoutLimitNodeList)
                                {
                                    switch (logoutLimitNode.Name.ToLowerInvariant())
                                    {
                                        case ConfigurationKeys.TIMEOUT:
                                            int logoutGrace;
                                            if (
                                                !int.TryParse(logoutLimitNode.InnerText,
                                                    out logoutGrace))
                                            {
                                                throw new Exception("error in logout limits section");
                                            }
                                            LOGOUT_GRACE = logoutGrace;
                                            break;
                                    }
                                }
                                break;
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                }


                // Process masters.
                try
                {
                    foreach (XmlNode mastersNode in root.SelectNodes("/config/masters/*"))
                    {
                        Master configMaster = new Master();
                        foreach (XmlNode masterNode in mastersNode.ChildNodes)
                        {
                            switch (masterNode.Name.ToLowerInvariant())
                            {
                                case ConfigurationKeys.FIRST_NAME:
                                    if (string.IsNullOrEmpty(masterNode.InnerText))
                                    {
                                        throw new Exception("error in masters section");
                                    }
                                    configMaster.FirstName = masterNode.InnerText;
                                    break;
                                case ConfigurationKeys.LAST_NAME:
                                    if (string.IsNullOrEmpty(masterNode.InnerText))
                                    {
                                        throw new Exception("error in masters section");
                                    }
                                    configMaster.LastName = masterNode.InnerText;
                                    break;
                            }
                        }
                        MASTERS.Add(configMaster);
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                }

                // Process groups.
                try
                {
                    foreach (XmlNode groupsNode in root.SelectNodes("/config/groups/*"))
                    {
                        Group configGroup = new Group
                        {
                            ChatLog = string.Empty,
                            ChatLogEnabled = false,
                            DatabaseFile = string.Empty,
                            Name = string.Empty,
                            NotificationMask = 0,
                            Password = string.Empty,
                            PermissionMask = 0,
                            UUID = UUID.Zero,
                            Workers = 5
                        };
                        foreach (XmlNode groupNode in groupsNode.ChildNodes)
                        {
                            switch (groupNode.Name.ToLowerInvariant())
                            {
                                case ConfigurationKeys.NAME:
                                    if (string.IsNullOrEmpty(groupNode.InnerText))
                                    {
                                        throw new Exception("error in group section");
                                    }
                                    configGroup.Name = groupNode.InnerText;
                                    break;
                                case ConfigurationKeys.UUID:
                                    if (!UUID.TryParse(groupNode.InnerText, out configGroup.UUID))
                                    {
                                        throw new Exception("error in group section");
                                    }
                                    break;
                                case ConfigurationKeys.PASSWORD:
                                    if (string.IsNullOrEmpty(groupNode.InnerText))
                                    {
                                        throw new Exception("error in group section");
                                    }
                                    configGroup.Password = groupNode.InnerText;
                                    break;
                                case ConfigurationKeys.WORKERS:
                                    if (!uint.TryParse(groupNode.InnerText, out configGroup.Workers))
                                    {
                                        throw new Exception("error in group section");
                                    }
                                    break;
                                case ConfigurationKeys.CHATLOG:
                                    XmlNodeList groupChatLogNodeList = groupNode.SelectNodes("*");
                                    if (groupChatLogNodeList == null)
                                    {
                                        throw new Exception("error in group section");
                                    }
                                    foreach (XmlNode groupChatLogNode in groupChatLogNodeList)
                                    {
                                        switch (groupChatLogNode.Name.ToLowerInvariant())
                                        {
                                            case ConfigurationKeys.ENABLE:
                                                bool enable;
                                                if (!bool.TryParse(groupChatLogNode.InnerText, out enable))
                                                {
                                                    throw new Exception("error in group chat logs section");
                                                }
                                                configGroup.ChatLogEnabled = enable;
                                                break;
                                            case ConfigurationKeys.FILE:
                                                if (string.IsNullOrEmpty(groupChatLogNode.InnerText))
                                                {
                                                    throw new Exception("error in group chat logs section");
                                                }
                                                configGroup.ChatLog = groupChatLogNode.InnerText;
                                                break;
                                        }
                                    }
                                    break;
                                case ConfigurationKeys.DATABASE:
                                    if (string.IsNullOrEmpty(groupNode.InnerText))
                                    {
                                        throw new Exception("error in group section");
                                    }
                                    configGroup.DatabaseFile = groupNode.InnerText;
                                    break;
                                case ConfigurationKeys.PERMISSIONS:
                                    XmlNodeList permissionNodeList = groupNode.SelectNodes("*");
                                    if (permissionNodeList == null)
                                    {
                                        throw new Exception("error in group permission section");
                                    }
                                    uint permissionMask = 0;
                                    foreach (XmlNode permissioNode in permissionNodeList)
                                    {
                                        XmlNode node = permissioNode;
                                        Parallel.ForEach(
                                            wasGetEnumDescriptions<Permissions>()
                                                .AsParallel().Where(name => name.Equals(node.Name,
                                                    StringComparison.Ordinal)), name =>
                                                    {
                                                        bool granted;
                                                        if (!bool.TryParse(node.InnerText, out granted))
                                                        {
                                                            throw new Exception(
                                                                "error in group permission section");
                                                        }
                                                        if (granted)
                                                        {
                                                            permissionMask = permissionMask |
                                                                             (uint)
                                                                                 wasGetEnumValueFromDescription
                                                                                     <Permissions>(name);
                                                        }
                                                    });
                                    }
                                    configGroup.PermissionMask = permissionMask;
                                    break;
                                case ConfigurationKeys.NOTIFICATIONS:
                                    XmlNodeList notificationNodeList = groupNode.SelectNodes("*");
                                    if (notificationNodeList == null)
                                    {
                                        throw new Exception("error in group notification section");
                                    }
                                    uint notificationMask = 0;
                                    foreach (XmlNode notificationNode in notificationNodeList)
                                    {
                                        XmlNode node = notificationNode;
                                        Parallel.ForEach(
                                            wasGetEnumDescriptions<Notifications>()
                                                .AsParallel().Where(name => name.Equals(node.Name,
                                                    StringComparison.Ordinal)), name =>
                                                    {
                                                        bool granted;
                                                        if (!bool.TryParse(node.InnerText, out granted))
                                                        {
                                                            throw new Exception(
                                                                "error in group notification section");
                                                        }
                                                        if (granted)
                                                        {
                                                            notificationMask = notificationMask |
                                                                               (uint)
                                                                                   wasGetEnumValueFromDescription
                                                                                       <Notifications>(name);
                                                        }
                                                    });
                                    }
                                    configGroup.NotificationMask = notificationMask;
                                    break;
                            }
                        }
                        GROUPS.Add(configGroup);
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVALID_CONFIGURATION_FILE), ex.Message);
                }

                // Enable AIML in case it was enabled in the configuration file.
                switch (EnableAIML)
                {
                    case true:
                        switch (!AIMLBotBrainCompiled)
                        {
                            case true:
                                new Thread(
                                    () =>
                                    {
                                        lock (AIMLBotLock)
                                        {
                                            LoadChatBotFiles.Invoke();
                                            AIMLBotConfigurationWatcher.EnableRaisingEvents = true;
                                        }
                                    }) {IsBackground = true, Priority = ThreadPriority.BelowNormal}.Start();
                                break;
                            default:
                                AIMLBotConfigurationWatcher.EnableRaisingEvents = true;
                                AIMLBot.isAcceptingUserInput = true;
                                break;
                        }
                        break;
                    default:
                        AIMLBotConfigurationWatcher.EnableRaisingEvents = false;
                        AIMLBot.isAcceptingUserInput = false;
                        break;
                }

                // Dynamically disable or enable notifications.
                Parallel.ForEach(wasGetEnumDescriptions<Notifications>().AsParallel().Select(
                    wasGetEnumValueFromDescription<Notifications>), o =>
                    {
                        bool enabled = GROUPS.AsParallel().Any(
                            p =>
                                !(p.NotificationMask & (uint) o).Equals(0));
                        switch (o)
                        {
                            case Notifications.NOTIFICATION_GROUP_MEMBERSHIP:
                                switch (enabled)
                                {
                                    case true:
                                        // Start the group membership thread.
                                        StartGroupMembershipSweepThread.Invoke();
                                        break;
                                    default:
                                        // Stop the group sweep thread.
                                        StopGroupMembershipSweepThread.Invoke();
                                        break;
                                }
                                break;
                            case Notifications.NOTIFICATION_FRIENDSHIP:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Friends.FriendshipOffered += HandleFriendshipOffered;
                                        Client.Friends.FriendshipResponse += HandleFriendShipResponse;
                                        Client.Friends.FriendOnline += HandleFriendOnlineStatus;
                                        Client.Friends.FriendOffline += HandleFriendOnlineStatus;
                                        Client.Friends.FriendRightsUpdate += HandleFriendRightsUpdate;
                                        break;
                                    default:
                                        Client.Friends.FriendshipOffered -= HandleFriendshipOffered;
                                        Client.Friends.FriendshipResponse -= HandleFriendShipResponse;
                                        Client.Friends.FriendOnline -= HandleFriendOnlineStatus;
                                        Client.Friends.FriendOffline -= HandleFriendOnlineStatus;
                                        Client.Friends.FriendRightsUpdate -= HandleFriendRightsUpdate;
                                        break;
                                }
                                break;
                            case Notifications.NOTIFICATION_SCRIPT_PERMISSION:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.ScriptQuestion += HandleScriptQuestion;
                                        break;
                                    default:
                                        Client.Self.ScriptQuestion -= HandleScriptQuestion;
                                        break;
                                }
                                break;
                            case Notifications.NOTIFICATION_ALERT_MESSAGE:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.AlertMessage += HandleAlertMessage;
                                        break;
                                    default:
                                        Client.Self.AlertMessage -= HandleAlertMessage;
                                        break;
                                }
                                break;
                            case Notifications.NOTIFICATION_BALANCE:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.MoneyBalance += HandleMoneyBalance;
                                        break;
                                    default:
                                        Client.Self.MoneyBalance -= HandleMoneyBalance;
                                        break;
                                }
                                break;
                            case Notifications.NOTIFICATION_ECONOMY:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.MoneyBalanceReply += HandleMoneyBalance;
                                        break;
                                    default:
                                        Client.Self.MoneyBalanceReply -= HandleMoneyBalance;
                                        break;
                                }
                                break;
                            case Notifications.NOTIFICATION_SCRIPT_DIALOG:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.ScriptDialog += HandleScriptDialog;
                                        break;
                                    default:
                                        Client.Self.ScriptDialog -= HandleScriptDialog;
                                        break;
                                }
                                break;
                            case Notifications.NOTIFICATION_TERSE_UPDATES:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Objects.TerseObjectUpdate += HandleTerseObjectUpdate;
                                        break;
                                    default:
                                        Client.Objects.TerseObjectUpdate -= HandleTerseObjectUpdate;
                                        break;
                                }
                                break;
                            case Notifications.NOTIFICATION_VIEWER_EFFECT:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Avatars.ViewerEffect += HandleViewerEffect;
                                        Client.Avatars.ViewerEffectPointAt += HandleViewerEffect;
                                        Client.Avatars.ViewerEffectLookAt += HandleViewerEffect;
                                        break;
                                    default:
                                        Client.Avatars.ViewerEffect -= HandleViewerEffect;
                                        Client.Avatars.ViewerEffectPointAt -= HandleViewerEffect;
                                        Client.Avatars.ViewerEffectLookAt -= HandleViewerEffect;
                                        break;
                                }
                                break;
                            case Notifications.NOTIFICATION_MEAN_COLLISION:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.MeanCollision += HandleMeanCollision;
                                        break;
                                    default:
                                        Client.Self.MeanCollision -= HandleMeanCollision;
                                        break;
                                }
                                break;
                            case Notifications.NOTIFICATION_REGION_CROSSED:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.RegionCrossed += HandleRegionCrossed;
                                        Client.Network.SimChanged += HandleSimChanged;
                                        break;
                                    default:
                                        Client.Self.RegionCrossed -= HandleRegionCrossed;
                                        Client.Network.SimChanged -= HandleSimChanged;
                                        break;
                                }
                                break;
                            case Notifications.NOTIFICATION_LOAD_URL:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.LoadURL += HandleLoadURL;
                                        break;
                                    default:
                                        Client.Self.LoadURL -= HandleLoadURL;
                                        break;
                                }
                                break;
                        }
                    });
                // If any group has either the avatar radar notification or the primitive radar notification then install the listeners.
                switch (
                    GROUPS.AsParallel().Any(
                        o => !(o.NotificationMask & (uint) Notifications.NOTIFICATION_RADAR_AVATARS).Equals(0)) ||
                    GROUPS.AsParallel().Any(
                        o => !(o.NotificationMask & (uint) Notifications.NOTIFICATION_RADAR_PRIMITIVES).Equals(0)))
                {
                    case true:
                        Client.Network.SimChanged += HandleRadarObjects;
                        Client.Objects.AvatarUpdate += HandleAvatarUpdate;
                        Client.Objects.ObjectUpdate += HandleObjectUpdate;
                        Client.Objects.KillObject += HandleKillObject;
                        break;
                    default:
                        Client.Network.SimChanged -= HandleRadarObjects;
                        Client.Objects.AvatarUpdate -= HandleAvatarUpdate;
                        Client.Objects.ObjectUpdate -= HandleObjectUpdate;
                        Client.Objects.KillObject -= HandleKillObject;
                        break;
                }
                // Apply settings to the instance.
                Client.Self.Movement.Camera.Far = RANGE;
                Client.Settings.LOGIN_TIMEOUT = SERVICES_TIMEOUT;
                Client.Settings.LOGOUT_TIMEOUT = SERVICES_TIMEOUT;
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.READ_CORRADE_CONFIGURATION));
            }
        }

        /// <summary>
        ///     Configuration keys.
        /// </summary>
        private struct ConfigurationKeys
        {
            public const string FIRST_NAME = @"firstname";
            public const string LAST_NAME = @"lastname";
            public const string LOGIN_URL = @"loginurl";
            public const string HTTP = @"http";
            public const string PREFIX = @"prefix";
            public const string TIMEOUT = @"timeout";
            public const string THROTTLE = @"throttle";
            public const string SERVICES = @"services";
            public const string TOS_ACCEPTED = @"tosaccepted";
            public const string AUTO_ACTIVATE_GROUP = @"autoactivategroup";
            public const string GROUP_CREATE_FEE = @"groupcreatefee";
            public const string START_LOCATION = @"startlocation";
            public const string LOG = @"log";
            public const string NAME = @"name";
            public const string UUID = @"uuid";
            public const string PASSWORD = @"password";
            public const string CHATLOG = @"chatlog";
            public const string DATABASE = @"database";
            public const string PERMISSIONS = @"permissions";
            public const string NOTIFICATIONS = @"notifications";
            public const string CALLBACKS = @"callbacks";
            public const string QUEUE_LENGTH = @"queuelength";
            public const string CLIENT = @"client";
            public const string NAGGLE = @"naggle";
            public const string CONNECTIONS = @"connections";
            public const string EXPECT100CONTINUE = @"expect100continue";
            public const string MAC = @"MAC";
            public const string ID0 = @"ID0";
            public const string SERVER = @"server";
            public const string MEMBERSHIP = @"membership";
            public const string SWEEP = @"sweep";
            public const string ENABLE = @"enable";
            public const string REBAKE = @"rebake";
            public const string ACTIVATE = @"activate";
            public const string DATA = @"data";
            public const string THREADS = @"threads";
            public const string COMMANDS = @"commands";
            public const string RLV = @"rlv";
            public const string WORKERS = @"workers";
            public const string ENCODE = @"encode";
            public const string DECODE = @"decode";
            public const string ENCRYPT = @"encrypt";
            public const string DECRYPT = @"decrypt";
            public const string INPUT = @"input";
            public const string OUTPUT = @"output";
            public const string ENIGMA = @"enigma";
            public const string ROTORS = @"rotors";
            public const string PLUGS = @"plugs";
            public const string REFLECTOR = @"reflector";
            public const string SECRET = @"secret";
            public const string VIGENERE = @"vigenere";
            public const string IM = @"im";
            public const string RANGE = @"range";
            public const string DECAY = @"decay";
            public const string LOGOUT = @"logout";
            public const string FILE = @"file";
            public const string DIRECTORY = @"directory";
            public const string LOCAL = @"local";
            public const string REGION = @"region";
            public const string BIND = @"bind";
            public const string IDLE = @"idle";
            public const string COMPRESSION = @"compression";
            public const string EXIT_CODE = @"exitcode";
            public const string EXPECTED = @"expected";
            public const string ABNORMAL = @"abnormal";
        }

        /// <summary>
        ///     Structure containing error messages printed on console for the owner.
        /// </summary>
        private enum ConsoleError
        {
            [Description("none")] NONE = 0,
            [Description("access denied")] ACCESS_DENIED,
            [Description("invalid configuration file")] INVALID_CONFIGURATION_FILE,

            [Description(
                "the Terms of Service (TOS) for the grid you are connecting to have not been accepted, please check your configuration file"
                )] TOS_NOT_ACCEPTED,
            [Description("teleport failed")] TELEPORT_FAILED,
            [Description("teleport succeeded")] TELEPORT_SUCCEEDED,
            [Description("accepted friendship")] ACCEPTED_FRIENDSHIP,
            [Description("login failed")] LOGIN_FAILED,
            [Description("login succeeded")] LOGIN_SUCCEEDED,
            [Description("failed to set appearance")] APPEARANCE_SET_FAILED,
            [Description("appearance set")] APPEARANCE_SET_SUCCEEDED,
            [Description("all simulators disconnected")] ALL_SIMULATORS_DISCONNECTED,
            [Description("simulator connected")] SIMULATOR_CONNECTED,
            [Description("event queue started")] EVENT_QUEUE_STARTED,
            [Description("disconnected")] DISCONNECTED,
            [Description("logging out")] LOGGING_OUT,
            [Description("logging in")] LOGGING_IN,
            [Description("agent not found")] AGENT_NOT_FOUND,
            [Description("reading Corrade configuration")] READING_CORRADE_CONFIGURATION,
            [Description("read Corrade configuration")] READ_CORRADE_CONFIGURATION,
            [Description("configuration file modified")] CONFIGURATION_FILE_MODIFIED,
            [Description("HTTP server error")] HTTP_SERVER_ERROR,
            [Description("HTTP server not supported")] HTTP_SERVER_NOT_SUPPORTED,
            [Description("starting HTTP server")] STARTING_HTTP_SERVER,
            [Description("stopping HTTP server")] STOPPING_HTTP_SERVER,
            [Description("HTTP server processing aborted")] HTTP_SERVER_PROCESSING_ABORTED,
            [Description("timeout logging out")] TIMEOUT_LOGGING_OUT,
            [Description("callback error")] CALLBACK_ERROR,
            [Description("notification error")] NOTIFICATION_ERROR,
            [Description("inventory cache items loaded")] INVENTORY_CACHE_ITEMS_LOADED,
            [Description("inventory cache items saved")] INVENTORY_CACHE_ITEMS_SAVED,
            [Description("unable to load Corrade cache")] UNABLE_TO_LOAD_CORRADE_CACHE,
            [Description("unable to save Corrade cache")] UNABLE_TO_SAVE_CORRADE_CACHE,
            [Description("failed to manifest RLV behaviour")] FAILED_TO_MANIFEST_RLV_BEHAVIOUR,
            [Description("behaviour not implemented")] BEHAVIOUR_NOT_IMPLEMENTED,
            [Description("workers exceeded")] WORKERS_EXCEEDED,
            [Description("AIML bot configuration modified")] AIML_CONFIGURATION_MODIFIED,
            [Description("read AIML bot configuration")] READ_AIML_BOT_CONFIGURATION,
            [Description("reading AIML bot configuration")] READING_AIML_BOT_CONFIGURATION,
            [Description("wrote AIML bot configuration")] WROTE_AIML_BOT_CONFIGURATION,
            [Description("writing AIML bot configuration")] WRITING_AIML_BOT_CONFIGURATION,
            [Description("error loading AIML bot files")] ERROR_LOADING_AIML_BOT_FILES,
            [Description("error saving AIML bot files")] ERROR_SAVING_AIML_BOT_FILES,
            [Description("could not write to client log file")] COULD_NOT_WRITE_TO_CLIENT_LOG_FILE,
            [Description("could not write to group chat log file")] COULD_NOT_WRITE_TO_GROUP_CHAT_LOG_FILE,
            [Description("could not write to instant message log file")] COULD_NOT_WRITE_TO_INSTANT_MESSAGE_LOG_FILE,
            [Description("could not write to local message log file")] COULD_NOT_WRITE_TO_LOCAL_MESSAGE_LOG_FILE,
            [Description("could not write to region message log file")] COULD_NOT_WRITE_TO_REGION_MESSAGE_LOG_FILE,
            [Description("unknown IP address")] UNKNOWN_IP_ADDRESS,
            [Description("unable to save Corrade notifications state")] UNABLE_TO_SAVE_CORRADE_NOTIFICATIONS_STATE,
            [Description("unable to load Corrade notifications state")] UNABLE_TO_LOAD_CORRADE_NOTIFICATIONS_STATE,
            [Description("unable to save Corrade inventory offers state")] UNABLE_TO_SAVE_CORRADE_INVENTORY_OFFERS_STATE,
            [Description("unable to load Corrade inventory offers state")] UNABLE_TO_LOAD_CORRADE_INVENTORY_OFFERS_STATE
        }

        /// <summary>
        ///     Corrade's internal thread structure.
        /// </summary>
        public struct CorradeThread
        {
            private static readonly HashSet<Thread> WorkSet = new HashSet<Thread>();
            private static readonly object LockObject = new object();

            public void Spawn(ThreadStart s, int m)
            {
                lock (LockObject)
                {
                    WorkSet.RemoveWhere(o => !o.IsAlive);
                    if (WorkSet.Count > m)
                    {
                        return;
                    }
                }
                Thread t = new Thread(s) {IsBackground = true, Priority = ThreadPriority.BelowNormal};
                lock (LockObject)
                {
                    WorkSet.Add(t);
                }
                t.Start();
            }
        }

        /// <summary>
        ///     The type of threads managed by Corrade.
        /// </summary>
        private enum CorradeThreadType
        {
            COMMAND = 1,
            RLV = 2,
            NOTIFICATION = 3,
            INSTANT_MESSAGE = 4
        };

        /// <summary>
        ///     An inventory item.
        /// </summary>
        private struct DirItem
        {
            [Description("item")] public UUID Item;
            [Description("name")] public string Name;
            [Description("permissions")] public string Permissions;
            [Description("type")] public DirItemType Type;

            public static DirItem FromInventoryBase(InventoryBase inventoryBase)
            {
                DirItem item = new DirItem
                {
                    Name = inventoryBase.Name,
                    Item = inventoryBase.UUID,
                    Permissions = CORRADE_CONSTANTS.PERMISSIONS.NONE
                };

                if (inventoryBase is InventoryFolder)
                {
                    item.Type = DirItemType.FOLDER;
                    return item;
                }

                if (!(inventoryBase is InventoryItem)) return item;

                InventoryItem inventoryItem = inventoryBase as InventoryItem;
                item.Permissions = wasPermissionsToString(inventoryItem.Permissions);

                if (inventoryItem is InventoryWearable)
                {
                    item.Type = (DirItemType) typeof (DirItemType).GetFields(BindingFlags.Public |
                                                                             BindingFlags.Static)
                        .AsParallel().FirstOrDefault(
                            o =>
                                string.Equals(o.Name,
                                    Enum.GetName(typeof (WearableType),
                                        (inventoryItem as InventoryWearable).WearableType),
                                    StringComparison.InvariantCultureIgnoreCase)).GetValue(null);
                    return item;
                }

                if (inventoryItem is InventoryTexture)
                {
                    item.Type = DirItemType.TEXTURE;
                    return item;
                }

                if (inventoryItem is InventorySound)
                {
                    item.Type = DirItemType.SOUND;
                    return item;
                }

                if (inventoryItem is InventoryCallingCard)
                {
                    item.Type = DirItemType.CALLINGCARD;
                    return item;
                }

                if (inventoryItem is InventoryLandmark)
                {
                    item.Type = DirItemType.LANDMARK;
                    return item;
                }

                if (inventoryItem is InventoryObject)
                {
                    item.Type = DirItemType.OBJECT;
                    return item;
                }

                if (inventoryItem is InventoryNotecard)
                {
                    item.Type = DirItemType.NOTECARD;
                    return item;
                }

                if (inventoryItem is InventoryCategory)
                {
                    item.Type = DirItemType.CATEGORY;
                    return item;
                }

                if (inventoryItem is InventoryLSL)
                {
                    item.Type = DirItemType.LSL;
                    return item;
                }

                if (inventoryItem is InventorySnapshot)
                {
                    item.Type = DirItemType.SNAPSHOT;
                    return item;
                }

                if (inventoryItem is InventoryAttachment)
                {
                    item.Type = DirItemType.ATTACHMENT;
                    return item;
                }

                if (inventoryItem is InventoryAnimation)
                {
                    item.Type = DirItemType.ANIMATION;
                    return item;
                }

                if (inventoryItem is InventoryGesture)
                {
                    item.Type = DirItemType.GESTURE;
                    return item;
                }

                item.Type = DirItemType.NONE;
                return item;
            }
        }

        /// <summary>
        ///     Holds item types with the wearable inventory item type expanded to wearable types.
        /// </summary>
        private enum DirItemType : uint
        {
            [Description("none")] NONE = 0,
            [Description("texture")] TEXTURE,
            [Description("sound")] SOUND,
            [Description("callingcard")] CALLINGCARD,
            [Description("landmark")] LANDMARK,
            [Description("object")] OBJECT,
            [Description("notecard")] NOTECARD,
            [Description("category")] CATEGORY,
            [Description("LSL")] LSL,
            [Description("snapshot")] SNAPSHOT,
            [Description("attachment")] ATTACHMENT,
            [Description("animation")] ANIMATION,
            [Description("gesture")] GESTURE,
            [Description("folder")] FOLDER,
            [Description("shape")] SHAPE,
            [Description("skin")] SKIN,
            [Description("hair")] HAIR,
            [Description("eyes")] EYES,
            [Description("shirt")] SHIRT,
            [Description("pants")] PANTS,
            [Description("shoes")] SHOES,
            [Description("socks")] SOCKS,
            [Description("jacket")] JACKET,
            [Description("gloves")] GLOVES,
            [Description("undershirt")] UNDERSHIRT,
            [Description("underpants")] UNDERPANTS,
            [Description("skirt")] SKIRT,
            [Description("tattoo")] TATTOO,
            [Description("alpha")] ALPHA,
            [Description("physics")] PHYSICS
        }

        /// <summary>
        ///     Directions in 3D cartesian.
        /// </summary>
        private enum Direction : uint
        {
            [Description("none")] NONE = 0,
            [Description("back")] BACK,
            [Description("forward")] FORWARD,
            [Description("left")] LEFT,
            [Description("right")] RIGHT,
            [Description("up")] UP,
            [Description("down")] DOWN
        }

        /// <summary>
        ///     ENIGMA machine settings.
        /// </summary>
        private struct ENIGMA
        {
            public char[] plugs;
            public char reflector;
            public char[] rotors;
        }

        /// <summary>
        ///     Possible entities.
        /// </summary>
        private enum Entity : uint
        {
            [Description("none")] NONE = 0,
            [Description("avatar")] AVATAR,
            [Description("local")] LOCAL,
            [Description("group")] GROUP,
            [Description("estate")] ESTATE,
            [Description("region")] REGION,
            [Description("object")] OBJECT,
            [Description("parcel")] PARCEL,
            [Description("range")] RANGE,
            [Description("syntax")] SYNTAX,
            [Description("permission")] PERMISSION
        }

        /// <summary>
        ///     Possible input and output filters.
        /// </summary>
        private enum Filter : uint
        {
            [Description("none")] NONE = 0,
            [Description("rfc1738")] RFC1738,
            [Description("rfc3986")] RFC3986,
            [Description("enigma")] ENIGMA,
            [Description("vigenere")] VIGENERE,
            [Description("atbash")] ATBASH,
            [Description("base64")] BASE64
        }

        /// <summary>
        ///     Group structure.
        /// </summary>
        private struct Group
        {
            public string ChatLog;
            public bool ChatLogEnabled;
            public string DatabaseFile;
            public string Name;
            public uint NotificationMask;
            public string Password;
            public uint PermissionMask;
            public UUID UUID;
            public uint Workers;
        }

        /// <summary>
        ///     A structure for group invites.
        /// </summary>
        private struct GroupInvite
        {
            [Description("agent")] public Agent Agent;
            [Description("fee")] public int Fee;
            [Description("group")] public string Group;
            [Description("session")] public UUID Session;
        }

        /// <summary>
        ///     An event for the group membership notification.
        /// </summary>
        private class GroupMembershipEventArgs : EventArgs
        {
            public Action Action;
            public string AgentName;
            public UUID AgentUUID;
        }

        /// <summary>
        ///     An enumeration of various compression methods
        ///     supproted by Corrade's internal HTTP server.
        /// </summary>
        private enum HTTPCompressionMethod : uint
        {
            [Description("none")] NONE,
            [Description("deflate")] DEFLATE,
            [Description("gzip")] GZIP
        }

        /// <summary>
        ///     Linden constants.
        /// </summary>
        private struct LINDEN_CONSTANTS
        {
            public struct ALERTS
            {
                public const string NO_ROOM_TO_SIT_HERE = @"No room to sit here, try another spot.";

                public const string UNABLE_TO_SET_HOME =
                    @"You can only set your 'Home Location' on your land or at a mainland Infohub.";

                public const string HOME_SET = @"Home position set.";
            }

            public struct ASSETS
            {
                public struct NOTECARD
                {
                    public const string NEWLINE = "\n";
                }
            }

            public struct AVATARS
            {
                public const int SET_DISPLAY_NAME_SUCCESS = 200;
                public const string LASTNAME_PLACEHOLDER = @"Resident";
            }

            public struct DIRECTORY
            {
                public struct EVENT
                {
                    public const int SEARCH_RESULTS_COUNT = 200;
                }

                public struct GROUP
                {
                    public const int SEARCH_RESULTS_COUNT = 100;
                }

                public struct LAND
                {
                    public const int SEARCH_RESULTS_COUNT = 100;
                }

                public struct PEOPLE
                {
                    public const int SEARCH_RESULTS_COUNT = 100;
                }
            }

            public struct ESTATE
            {
                public const int REGION_RESTART_DELAY = 120;

                public struct MESSAGES
                {
                    public const string REGION_RESTART_MESSAGE = @"restart";
                }
            }

            public struct GRID
            {
                public const string SECOND_LIFE = @"Second Life";
            }

            public struct GROUPS
            {
                public const int MAXIMUM_NUMBER_OF_ROLES = 10;
            }

            public struct LSL
            {
                public const string CSV_DELIMITER = @", ";
                public const float SENSOR_RANGE = 96;
            }

            public struct REGION
            {
                public const float TELEPORT_MINIMUM_DISTANCE = 1;
            }

            public struct VIEWER
            {
                public const float MAXIMUM_DRAW_DISTANCE = 4096;
            }
        }

        /// <summary>
        ///     A structure to track LookAt effects.
        /// </summary>
        private struct LookAtEffect
        {
            [Description("effect")] public UUID Effect;
            [Description("offset")] public Vector3d Offset;
            [Description("source")] public UUID Source;
            [Description("target")] public UUID Target;
            [Description("type")] public LookAtType Type;
        }

        /// <summary>
        ///     Masters structure.
        /// </summary>
        private struct Master
        {
            public string FirstName;
            public string LastName;
        }

        /// <summary>
        ///     A Corrade notification.
        /// </summary>
        public struct Notification
        {
            public string GroupName;
            public SerializableDictionary<Notifications, HashSet<string>> NotificationDestination;
            public uint NotificationMask;
        }

        /// <summary>
        ///     An element from the notification queue waiting to be dispatched.
        /// </summary>
        private struct NotificationQueueElement
        {
            public Dictionary<string, string> message;
            public string URL;
        }

        /// <summary>
        ///     Corrade permissions.
        /// </summary>
        [Flags]
        private enum Permissions : uint
        {
            [Description("none")] PERMISSION_NONE = 0,
            [Description("movement")] PERMISSION_MOVEMENT = 1,
            [Description("economy")] PERMISSION_ECONOMY = 2,
            [Description("land")] PERMISSION_LAND = 4,
            [Description("grooming")] PERMISSION_GROOMING = 8,
            [Description("inventory")] PERMISSION_INVENTORY = 16,
            [Description("interact")] PERMISSION_INTERACT = 32,
            [Description("mute")] PERMISSION_MUTE = 64,
            [Description("database")] PERMISSION_DATABASE = 128,
            [Description("notifications")] PERMISSION_NOTIFICATIONS = 256,
            [Description("talk")] PERMISSION_TALK = 512,
            [Description("directory")] PERMISSION_DIRECTORY = 1024,
            [Description("system")] PERMISSION_SYSTEM = 2048,
            [Description("friendship")] PERMISSION_FRIENDSHIP = 4096,
            [Description("execute")] PERMISSION_EXECUTE = 8192,
            [Description("group")] PERMISSION_GROUP = 16384,
            [Description("filter")] PERMISSION_FILTER = 32768
        }

        /// <summary>
        ///     A structure to track PointAt effects.
        /// </summary>
        private struct PointAtEffect
        {
            [Description("effect")] public UUID Effect;
            [Description("offset")] public Vector3d Offset;
            [Description("source")] public UUID Source;
            [Description("target")] public UUID Target;
            [Description("type")] public PointAtType Type;
        }

        /// <summary>
        ///     Keys returned by Corrade.
        /// </summary>
        private enum ResultKeys : uint
        {
            [Description("none")] NONE = 0,
            [Description("data")] DATA,
            [Description("success")] SUCCESS,
            [Description("error")] ERROR
        }

        /// <summary>
        ///     A structure for script dialogs.
        /// </summary>
        private struct ScriptDialog
        {
            public Agent Agent;
            [Description("button")] public List<string> Button;
            [Description("channel")] public int Channel;
            [Description("item")] public UUID Item;
            [Description("message")] public string Message;
            [Description("name")] public string Name;
        }

        /// <summary>
        ///     Structure containing errors returned to scripts.
        /// </summary>
        private enum ScriptError
        {
            [Description("none")] NONE = 0,
            [Description("could not join group")] COULD_NOT_JOIN_GROUP,
            [Description("could not leave group")] COULD_NOT_LEAVE_GROUP,
            [Description("agent not found")] AGENT_NOT_FOUND,
            [Description("group not found")] GROUP_NOT_FOUND,
            [Description("already in group")] ALREADY_IN_GROUP,
            [Description("not in group")] NOT_IN_GROUP,
            [Description("role not found")] ROLE_NOT_FOUND,
            [Description("command not found")] COMMAND_NOT_FOUND,
            [Description("could not eject agent")] COULD_NOT_EJECT_AGENT,
            [Description("no group power for command")] NO_GROUP_POWER_FOR_COMMAND,
            [Description("cannot eject owners")] CANNOT_EJECT_OWNERS,
            [Description("inventory item not found")] INVENTORY_ITEM_NOT_FOUND,
            [Description("invalid pay amount")] INVALID_PAY_AMOUNT,
            [Description("insufficient funds")] INSUFFICIENT_FUNDS,
            [Description("invalid pay target")] INVALID_PAY_TARGET,
            [Description("teleport failed")] TELEPORT_FAILED,
            [Description("primitive not found")] PRIMITIVE_NOT_FOUND,
            [Description("could not sit")] COULD_NOT_SIT,
            [Description("no Corrade permissions")] NO_CORRADE_PERMISSIONS,
            [Description("could not create group")] COULD_NOT_CREATE_GROUP,
            [Description("could not create role")] COULD_NOT_CREATE_ROLE,
            [Description("no role name specified")] NO_ROLE_NAME_SPECIFIED,
            [Description("timeout getting group roles members")] TIMEOUT_GETING_GROUP_ROLES_MEMBERS,
            [Description("timeout getting group roles")] TIMEOUT_GETTING_GROUP_ROLES,
            [Description("timeout getting role powers")] TIMEOUT_GETTING_ROLE_POWERS,
            [Description("could not find parcel")] COULD_NOT_FIND_PARCEL,
            [Description("unable to set home")] UNABLE_TO_SET_HOME,
            [Description("unable to go home")] UNABLE_TO_GO_HOME,
            [Description("timeout getting profile")] TIMEOUT_GETTING_PROFILE,
            [Description("texture not found")] TEXTURE_NOT_FOUND,
            [Description("type can only be voice or text")] TYPE_CAN_BE_VOICE_OR_TEXT,
            [Description("agent not in group")] AGENT_NOT_IN_GROUP,
            [Description("empty attachments")] EMPTY_ATTACHMENTS,
            [Description("could not get land users")] COULD_NOT_GET_LAND_USERS,
            [Description("empty pick name")] EMPTY_PICK_NAME,
            [Description("unable to join group chat")] UNABLE_TO_JOIN_GROUP_CHAT,
            [Description("invalid position")] INVALID_POSITION,
            [Description("could not find title")] COULD_NOT_FIND_TITLE,
            [Description("fly action can only be start or stop")] FLY_ACTION_START_OR_STOP,
            [Description("invalid proposal text")] INVALID_PROPOSAL_TEXT,
            [Description("invalid proposal quorum")] INVALID_PROPOSAL_QUORUM,
            [Description("invalid proposal majority")] INVALID_PROPOSAL_MAJORITY,
            [Description("invalid proposal duration")] INVALID_PROPOSAL_DURATION,
            [Description("invalid mute target")] INVALID_MUTE_TARGET,
            [Description("unknown action")] UNKNOWN_ACTION,
            [Description("no database file configured")] NO_DATABASE_FILE_CONFIGURED,
            [Description("no database key specified")] NO_DATABASE_KEY_SPECIFIED,
            [Description("no database value specified")] NO_DATABASE_VALUE_SPECIFIED,
            [Description("unknown database action")] UNKNOWN_DATABASE_ACTION,
            [Description("cannot remove owner role")] CANNOT_REMOVE_OWNER_ROLE,
            [Description("cannot remove user from owner role")] CANNOT_REMOVE_USER_FROM_OWNER_ROLE,
            [Description("timeout getting picks")] TIMEOUT_GETTING_PICKS,
            [Description("maximum number of roles exceeded")] MAXIMUM_NUMBER_OF_ROLES_EXCEEDED,
            [Description("cannot delete a group member from the everyone role")] CANNOT_DELETE_A_GROUP_MEMBER_FROM_THE_EVERYONE_ROLE,
            [Description("group members are by default in the everyone role")] GROUP_MEMBERS_ARE_BY_DEFAULT_IN_THE_EVERYONE_ROLE,
            [Description("cannot delete the everyone role")] CANNOT_DELETE_THE_EVERYONE_ROLE,
            [Description("invalid url provided")] INVALID_URL_PROVIDED,
            [Description("invalid notification types")] INVALID_NOTIFICATION_TYPES,
            [Description("notification not allowed")] NOTIFICATION_NOT_ALLOWED,
            [Description("unknown directory search type")] UNKNOWN_DIRECTORY_SEARCH_TYPE,
            [Description("no search text provided")] NO_SEARCH_TEXT_PROVIDED,
            [Description("unknown restart action")] UNKNOWN_RESTART_ACTION,
            [Description("unknown move action")] UNKNOWN_MOVE_ACTION,
            [Description("timeout getting top scripts")] TIMEOUT_GETTING_TOP_SCRIPTS,
            [Description("timeout waiting for estate list")] TIMEOUT_WAITING_FOR_ESTATE_LIST,
            [Description("unknown top type")] UNKNOWN_TOP_TYPE,
            [Description("unknown estate list action")] UNKNOWN_ESTATE_LIST_ACTION,
            [Description("unknown estate list")] UNKNOWN_ESTATE_LIST,
            [Description("no item specified")] NO_ITEM_SPECIFIED,
            [Description("unknown animation action")] UNKNOWN_ANIMATION_ACTION,
            [Description("no channel specified")] NO_CHANNEL_SPECIFIED,
            [Description("no button index specified")] NO_BUTTON_INDEX_SPECIFIED,
            [Description("no button specified")] NO_BUTTON_SPECIFIED,
            [Description("no land rights")] NO_LAND_RIGHTS,
            [Description("unknown entity")] UNKNOWN_ENTITY,
            [Description("invalid rotation")] INVALID_ROTATION,
            [Description("could not set script state")] COULD_NOT_SET_SCRIPT_STATE,
            [Description("item is not a script")] ITEM_IS_NOT_A_SCRIPT,
            [Description("failed to get display name")] FAILED_TO_GET_DISPLAY_NAME,
            [Description("no name provided")] NO_NAME_PROVIDED,
            [Description("could not set display name")] COULD_NOT_SET_DISPLAY_NAME,
            [Description("timeout joining group")] TIMEOUT_JOINING_GROUP,
            [Description("timeout creating group")] TIMEOUT_CREATING_GROUP,
            [Description("timeout ejecting agent")] TIMEOUT_EJECTING_AGENT,
            [Description("timeout getting group role members")] TIMEOUT_GETTING_GROUP_ROLE_MEMBERS,
            [Description("timeout leaving group")] TIMEOUT_LEAVING_GROUP,
            [Description("timeout joining group chat")] TIMEOUT_JOINING_GROUP_CHAT,
            [Description("timeout during teleport")] TIMEOUT_DURING_TELEPORT,
            [Description("timeout requesting sit")] TIMEOUT_REQUESTING_SIT,
            [Description("timeout getting land users")] TIMEOUT_GETTING_LAND_USERS,
            [Description("timeout getting script state")] TIMEOUT_GETTING_SCRIPT_STATE,
            [Description("timeout updating mute list")] TIMEOUT_UPDATING_MUTE_LIST,
            [Description("timeout getting parcels")] TIMEOUT_GETTING_PARCELS,
            [Description("empty classified name")] EMPTY_CLASSIFIED_NAME,
            [Description("invalid price")] INVALID_PRICE,
            [Description("timeout getting classifieds")] TIMEOUT_GETTING_CLASSIFIEDS,
            [Description("could not find classified")] COULD_NOT_FIND_CLASSIFIED,
            [Description("invalid days")] INVALID_DAYS,
            [Description("invalid interval")] INVALID_INTERVAL,
            [Description("timeout getting group account summary")] TIMEOUT_GETTING_GROUP_ACCOUNT_SUMMARY,
            [Description("friend not found")] FRIEND_NOT_FOUND,
            [Description("the agent already is a friend")] AGENT_ALREADY_FRIEND,
            [Description("no friendship offer found")] NO_FRIENDSHIP_OFFER_FOUND,
            [Description("friend does not allow mapping")] FRIEND_DOES_NOT_ALLOW_MAPPING,
            [Description("timeout mapping friend")] TIMEOUT_MAPPING_FRIEND,
            [Description("friend offline")] FRIEND_OFFLINE,
            [Description("timeout getting region")] TIMEOUT_GETTING_REGION,
            [Description("region not found")] REGION_NOT_FOUND,
            [Description("no map items found")] NO_MAP_ITEMS_FOUND,
            [Description("no description provided")] NO_DESCRIPTION_PROVIDED,
            [Description("no folder specified")] NO_FOLDER_SPECIFIED,
            [Description("empty wearables")] EMPTY_WEARABLES,
            [Description("parcel not for sale")] PARCEL_NOT_FOR_SALE,
            [Description("unknown access list type")] UNKNOWN_ACCESS_LIST_TYPE,
            [Description("no task specified")] NO_TASK_SPECIFIED,
            [Description("timeout getting group members")] TIMEOUT_GETTING_GROUP_MEMBERS,
            [Description("group not open")] GROUP_NOT_OPEN,
            [Description("timeout downloading terrain")] TIMEOUT_DOWNLOADING_ASSET,
            [Description("timeout uploading terrain")] TIMEOUT_UPLOADING_ASSET,
            [Description("empty terrain data")] EMPTY_ASSET_DATA,
            [Description("the specified folder contains no equipable items")] NO_EQUIPABLE_ITEMS,
            [Description("inventory offer not found")] INVENTORY_OFFER_NOT_FOUND,
            [Description("no session specified")] NO_SESSION_SPECIFIED,
            [Description("folder not found")] FOLDER_NOT_FOUND,
            [Description("timeout creating item")] TIMEOUT_CREATING_ITEM,
            [Description("timeout uploading item")] TIMEOUT_UPLOADING_ITEM,
            [Description("unable to upload item")] UNABLE_TO_UPLOAD_ITEM,
            [Description("unable to create item")] UNABLE_TO_CREATE_ITEM,
            [Description("timeout uploading item data")] TIMEOUT_UPLOADING_ITEM_DATA,
            [Description("unable to upload item data")] UNABLE_TO_UPLOAD_ITEM_DATA,
            [Description("unknown direction")] UNKNOWN_DIRECTION,
            [Description("timeout requesting to set home")] TIMEOUT_REQUESTING_TO_SET_HOME,
            [Description("timeout traferring asset")] TIMEOUT_TRANSFERRING_ASSET,
            [Description("asset upload failed")] ASSET_UPLOAD_FAILED,
            [Description("failed to download asset")] FAILED_TO_DOWNLOAD_ASSET,
            [Description("unknown asset type")] UNKNOWN_ASSET_TYPE,
            [Description("invalid asset data")] INVALID_ASSET_DATA,
            [Description("unknown wearable type")] UNKNOWN_WEARABLE_TYPE,
            [Description("unknown inventory type")] UNKNOWN_INVENTORY_TYPE,
            [Description("could not compile regular expression")] COULD_NOT_COMPILE_REGULAR_EXPRESSION,
            [Description("no pattern provided")] NO_PATTERN_PROVIDED,
            [Description("no executable file provided")] NO_EXECUTABLE_FILE_PROVIDED,
            [Description("timeout waiting for execution")] TIMEOUT_WAITING_FOR_EXECUTION,
            [Description("unknown group invite session")] UNKNOWN_GROUP_INVITE_SESSION,
            [Description("unable to obtain money balance")] UNABLE_TO_OBTAIN_MONEY_BALANCE,
            [Description("timeout getting avatar data")] TIMEOUT_GETTING_AVATAR_DATA,
            [Description("timeout retrieving estate list")] TIMEOUT_RETRIEVING_ESTATE_LIST,
            [Description("destination too close")] DESTINATION_TOO_CLOSE,
            [Description("timeout getting group titles")] TIMEOUT_GETTING_GROUP_TITLES,
            [Description("no message provided")] NO_MESSAGE_PROVIDED,
            [Description("could not remove brain file")] COULD_NOT_REMOVE_BRAIN_FILE,
            [Description("unknown effect")] UNKNOWN_EFFECT,
            [Description("no effect UUID provided")] NO_EFFECT_UUID_PROVIDED,
            [Description("effect not found")] EFFECT_NOT_FOUND,
            [Description("invalid viewer effect")] INVALID_VIEWER_EFFECT,
            [Description("ambiguous path")] AMBIGUOUS_PATH,
            [Description("path not found")] PATH_NOT_FOUND,
            [Description("unexpected item in path")] UNEXPECTED_ITEM_IN_PATH,
            [Description("no path provided")] NO_PATH_PROVIDED,
            [Description("unable to create folder")] UNABLE_TO_CREATE_FOLDER,
            [Description("no permissions provided")] NO_PERMISSIONS_PROVIDED,
            [Description("setting permissions failed")] SETTING_PERMISSIONS_FAILED,
            [Description("timeout retrieving item")] TIMEOUT_RETRIEVING_ITEM,
            [Description("expected item as source")] EXPECTED_ITEM_AS_SOURCE,
            [Description("expected folder as target")] EXPECTED_FOLDER_AS_TARGET,
            [Description("unable to load configuration")] UNABLE_TO_LOAD_CONFIGURATION,
            [Description("unable to save configuration")] UNABLE_TO_SAVE_CONFIGURATION,
            [Description("invalid xml path")] INVALID_XML_PATH,
            [Description("no data provided")] NO_DATA_PROVIDED,
            [Description("unknown image format requested")] UNKNOWN_IMAGE_FORMAT_REQUESTED,
            [Description("unknown image format provided")] UNKNOWN_IMAGE_FORMAT_PROVIDED,
            [Description("unable to decode asset data")] UNABLE_TO_DECODE_ASSET_DATA,
            [Description("unable to convert to requested format")] UNABLE_TO_CONVERT_TO_REQUESTED_FORMAT,
            [Description("could not start process")] COULD_NOT_START_PROCESS,
            [Description("timeout getting primitive data")] TIMEOUT_GETTING_PRIMITIVE_DATA,
            [Description("item is not an object")] ITEM_IS_NOT_AN_OBJECT,
            [Description("timeout meshmerizing object")] COULD_NOT_MESHMERIZE_OBJECT,
            [Description("could not get primitive properties")] COULD_NOT_GET_PRIMITIVE_PROPERTIES,
            [Description("avatar not in range")] AVATAR_NOT_IN_RANGE,
            [Description("invalid scale")] INVALID_SCALE,
            [Description("could not get current groups")] COULD_NOT_GET_CURRENT_GROUPS,
            [Description("maximum number of groups reached")] MAXIMUM_NUMBER_OF_GROUPS_REACHED,
            [Description("unknown syntax type")] UNKNOWN_SYNTAX_TYPE
        }

        /// <summary>
        ///     Keys reconigzed by Corrade.
        /// </summary>
        private enum ScriptKeys : uint
        {
            [Description("none")] NONE = 0,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getcommand>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<syntax|permission>>&entity=syntax:<type=<input>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_NONE)] [Description("getcommand")] GETCOMMAND,
            [IsCommand(true)] [CommandInputSyntax("<command=listcommands>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_NONE)] [Description("listcommands")] LISTCOMMANDS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getconnectedregions>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("getconnectedregions")] GETCONNECTEDREGIONS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getnetworkdata>&<group=<UUID|STRING>>&<password=<STRING>>&[data=<NetworkManager[,NetworkManager...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("getnetworkdata")] GETNETWORKDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=typing>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("typing")] TYPING,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=busy>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("busy")] BUSY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=away>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("away")] AWAY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getobjectpermissions>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getobjectpermissions")] GETOBJECTPERMISSIONS,
            [Description("scale")] SCALE,
            [Description("uniform")] UNIFORM,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectscale>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<scale=<FLOAT>>&[uniform=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setobjectscale")] SETOBJECTSCALE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitivescale>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<scale=<FLOAT>>&[uniform=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setprimitivescale")] SETPRIMITIVESCALE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitiverotation>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<rotation=<QUATERNION>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setprimitiverotation")] SETPRIMITIVEROTATION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitiveposition>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<position=<VECTOR3>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setprimitiveposition")] SETPRIMITIVEPOSITION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=exportdae>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&[format=<ImageFormat>]&[path=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("exportdae")] EXPORTDAE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=exportxml>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&[format=<ImageFormat>]&[path=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("exportxml")] EXPORTXML,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitivesdata>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<range|parcel|region|avatar>>&entity=range:[range=<FLOAT>]&entity=parcel:[position=<VECTOR2>]&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[data=<Primitive[,Primitive...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getprimitivesdata")] GETPRIMITIVESDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getavatarsdata>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<range|parcel|region|avatar>>&entity=range:[range=<FLOAT>]&entity=parcel:[position=<VECTOR2>]&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[data=<Avatar[,Avatar...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getavatarsdata")] GETAVATARSDATA,
            [Description("format")] FORMAT,
            [Description("volume")] VOLUME,
            [Description("audible")] AUDIBLE,
            [Description("path")] PATH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=inventory>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<ls|cwd|cd|mkdir|chmod|rm|cp|mv|ln>>&action=ls|mkdir|chmod:[path=<STRING>]&action=cd,action=rm:<path=<STRING>>&action=mkdir:<name=<STRING>>&action=chmod:<permissions=<STRING>>&action=cp|mv|ln:<source=<STRING>>&action=cp|mv|ln:<target=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INVENTORY)] [Description("inventory")] INVENTORY,
            [Description("offset")] OFFSET,
            [Description("alpha")] ALPHA,
            [Description("color")] COLOR,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deleteviewereffect>&<group=<UUID|STRING>>&<password=<STRING>>&<effect=<Look|Point>>&<id=<UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("deleteviewereffect")] DELETEVIEWEREFFECT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getviewereffects>&<group=<UUID|STRING>>&<password=<STRING>>&<effect=<Look|Point|Sphere|Beam>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getviewereffects")] GETVIEWEREFFECTS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setviewereffect>&<group=<UUID|STRING>>&<password=<STRING>>&<effect=<Look|Point|Sphere|Beam>>&effect=Look:<item=<UUID|STRING>&<range=<FLOAT>>>|<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&effect=Look:<offset=<VECTOR3>>&effect=Look:<type=LookAt>&effect=Point:<item=<UUID|STRING>&<range=<FLOAT>>>|<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&effect=Point:<offset=<VECTOR3>>&effect=Point:<type=PointAt>&effect=Beam:<item=<UUID|STRING>&<range=<FLOAT>>>|<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&effect=Beam:<color=<VECTOR3>>&effect=Beam:<alpha=<FLOAT>>&effect=Beam:<duration=<FLOAT>>&effect=Beam:<offset=<VECTOR3>>&effect=Sphere:<color=<VECTOR3>>&effect=Sphere:<alpha=<FLOAT>>&effect=Sphere:<duration=<FLOAT>>&effect=Sphere:<offset=<VECTOR3>>&[id=<UUID>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setviewereffect")] SETVIEWEREFFECT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=ai>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<process|enable|disable|rebuild>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_TALK)] [Description("ai")] AI,
            [IsCommand(true)] [CommandInputSyntax("<command=gettitles>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("gettitles")] GETTITLES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=tag>&<group=<UUID|STRING>>&<password=<STRING>>&action=<set|get>&action=set:<title=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("tag")] TAG,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=filter>&<group=<UUID|STRING>>&<password=<STRING>>&action=<set|get>&action=get:<type=<input|output>>&action=set:<input=<STRING>>&action=set:<output=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_FILTER)] [Description("filter")] FILTER,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=run>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )
                              ] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("run")] RUN,
            [IsCommand(true)] [CommandInputSyntax("<command=relax>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("relax")] RELAX,
            [Description("sift")] SIFT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=rlv>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable>>&[callback=<STRING>]")
                              ] [CommandPermissionMask((uint) Permissions.PERMISSION_SYSTEM)] [Description("rlv")] RLV,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getinventorypath>&<group=<UUID|STRING>>&<password=<STRING>>&<pattern=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INVENTORY)] [Description("getinventorypath")] GETINVENTORYPATH,
            [Description("committed")] COMMITTED,
            [Description("credit")] CREDIT,
            [Description("success")] SUCCESS,
            [Description("transaction")] TRANSACTION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getscriptdialogs>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getscriptdialogs")] GETSCRIPTDIALOGS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getscriptpermissionrequests>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getscriptpermissionrequests")] GETSCRIPTPERMISSIONREQUESTS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getteleportlures>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("getteleportlures")] GETTELEPORTLURES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytogroupinvite>&<group=<UUID|STRING>>&<password=<STRING>>&[action=<accept|decline>]&<session=<UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP | (uint) Permissions.PERMISSION_ECONOMY)] [Description("replytogroupinvite")] REPLYTOGROUPINVITE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getgroupinvites>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("getgroupinvites")] GETGROUPINVITES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getmemberroles>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("getmemberroles")] GETMEMBERROLES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=execute>&<group=<UUID|STRING>>&<password=<STRING>>&<file=<STRING>>&[parameter=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_EXECUTE)] [Description("execute")] EXECUTE,
            [Description("parameter")] PARAMETER,
            [Description("file")] FILE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=cache>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<purge|load|save>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_SYSTEM)] [Description("cache")] CACHE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getgridregiondata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<GridRegion[,GridRegion...]>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("getgridregiondata")] GETGRIDREGIONDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getregionparcelsboundingbox>&<group=<UUID|STRING>>&<password=<STRING>>&[region=<STRING>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("getregionparcelsboundingbox")] GETREGIONPARCELSBOUNDINGBOX,
            [Description("pattern")] PATTERN,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=searchinventory>&<group=<UUID|STRING>>&<password=<STRING>>&<pattern=<STRING>>&[type=<AssetType>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INVENTORY)] [Description("searchinventory")] SEARCHINVENTORY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getterrainheight>&<group=<UUID|STRING>>&<password=<STRING>>&[southwest=<VECTOR>]&[northwest=<VECTOR>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("getterrainheight")] GETTERRAINHEIGHT,
            [Description("northeast")] NORTHEAST,
            [Description("southwest")] SOUTHWEST,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=configuration>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<read|write|get|set>>&action=write:<data=<STRING>>&action=get:<path=<STRING>>&action=set:<path=<STRING>>&action=set:<data=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_SYSTEM)] [Description("configuration")] CONFIGURATION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=upload>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<type=<Texture|Sound|Animation|Clothing|Bodypart|Landmark|Gesture|Notecard|LSLText>>&type=Clothing:[wear=<WearableType>]&type=Bodypart:[wear=<WearableType>]&<data=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INVENTORY | (uint) Permissions.PERMISSION_ECONOMY)] [Description("upload")] UPLOAD,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=download>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<type=<Texture|Sound|Animation|Clothing|Bodypart|Landmark|Gesture|Notecard|LSLText>>&type=Texture:[format=<ImageFormat>]&[path=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT | (uint) Permissions.PERMISSION_SYSTEM)] [Description("download")] DOWNLOAD,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setparceldata>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR>]&[data=<Parcel[,Parcel...]>]&[region=<STRING>]&[callback=<STRING>]"
                )
                              ] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("setparceldata")] SETPARCELDATA,
            [Description("new")] NEW,
            [Description("old")] OLD,
            [Description("aggressor")] AGGRESSOR,
            [Description("magnitude")] MAGNITUDE,
            [Description("time")] TIME,
            [Description("victim")] VICTIM,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=playgesture>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("playgesture")] PLAYGESTURE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=jump>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<start|stop>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("jump")] JUMP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=crouch>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<start|stop>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("crouch")] CROUCH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=turnto>&<group=<UUID|STRING>>&<password=<STRING>>&<position=<VECTOR3>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("turnto")] TURNTO,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=nudge>&<group=<UUID|STRING>>&<password=<STRING>>&<direction=<left|right|up|down|back|forward>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("nudge")] NUDGE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=createnotecard>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[text=<STRING>]&[description=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INVENTORY)] [Description("createnotecard")] CREATENOTECARD,
            [Description("direction")] DIRECTION,
            [Description("agent")] AGENT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytoinventoryoffer>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<accept|decline>>&<session=<UUID>>&[folder=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INVENTORY)] [Description("replytoinventoryoffer")] REPLYTOINVENTORYOFFER,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getinventoryoffers>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_INVENTORY)] [Description("getinventoryoffers")] GETINVENTORYOFFERS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=updateprimitiveinventory>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<add|remove|take>>&action=add:<entity=<UUID|STRING>>&action=remove:<entity=<UUID|STRING>>&action=take:<entity=<UUID|STRING>>&action=take:<folder=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("updateprimitiveinventory")] UPDATEPRIMITIVEINVENTORY,
            [IsCommand(true)] [CommandInputSyntax("<command=version>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_NONE)] [Description("version")] VERSION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=playsound>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[gain=<FLOAT>]&[position=<VECTOR3>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("playsound")] PLAYSOUND,
            [Description("gain")] GAIN,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getrolemembers>&<group=<UUID|STRING>>&<password=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("getrolemembers")] GETROLEMEMBERS,
            [Description("status")] STATUS,
            [IsCommand(true)] [CommandInputSyntax("<command=getmembers>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("getmembers")] GETMEMBERS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytoteleportlure>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<session=<UUID>>&<action=<accept|decline>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("replytoteleportlure")] REPLYTOTELEPORTLURE,
            [Description("session")] SESSION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytoscriptpermissionrequest>&<group=<UUID|STRING>>&<password=<STRING>>&<task=<UUID>>&<item=<UUID>>&<permissions=<ScriptPermission>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("replytoscriptpermissionrequest")] REPLYTOSCRIPTPERMISSIONREQUEST,
            [Description("task")] TASK,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getparcellist>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("getparcellist")] GETPARCELLIST,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parcelrelease>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("parcelrelease")] PARCELRELEASE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parcelbuy>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[forgroup=<BOOL>]&[removecontribution=<BOOL>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND | (uint) Permissions.PERMISSION_ECONOMY)] [Description("parcelbuy")] PARCELBUY,
            [Description("removecontribution")] REMOVECONTRIBUTION,
            [Description("forgroup")] FORGROUP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parceldeed>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("parceldeed")] PARCELDEED,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parcelreclaim>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("parcelreclaim")] PARCELRECLAIM,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=unwear>&<group=<UUID|STRING>>&<password=<STRING>>&<wearables=<STRING[,UUID...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("unwear")] UNWEAR,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=wear>&<group=<UUID|STRING>>&<password=<STRING>>&<wearables=<STRING[,UUID...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("wear")] WEAR,
            [Description("wearables")] WEARABLES,
            [IsCommand(true)] [CommandInputSyntax("<command=getwearables>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("getwearables")] GETWEARABLES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=changeappearance>&<group=<UUID|STRING>>&<password=<STRING>>&<folder=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("changeappearance")] CHANGEAPPEARANCE,
            [Description("folder")] FOLDER,
            [Description("replace")] REPLACE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectrotation>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<rotation=<QUARTERNION>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setobjectrotation")] SETOBJECTROTATION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitivedescription>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<description=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setprimitivedescription")] SETPRIMITIVEDESCRIPTION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitivename>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<name=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setprimitivename")] SETPRIMITIVENAME,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectposition>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<position=<VECTOR3>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setobjectposition")] SETOBJECTPOSITION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectsaleinfo>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<price=<INTEGER>>&<type=<SaleType>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setobjectsaleinfo")] SETOBJECTSALEINFO,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectgroup>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setobjectgroup")] SETOBJECTGROUP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=objectdeed>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("objectdeed")] OBJECTDEED,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectpermissions>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<permissions=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setobjectpermissions")] SETOBJECTPERMISSIONS,
            [Description("permissions")] PERMISSIONS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getavatarpositions>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<region|parcel>>&entity=parcel:<position=<VECTOR2>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getavatarpositions")] GETAVATARPOSITIONS,
            [Description("delay")] DELAY,
            [Description("asset")] ASSET,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setregiondebug>&<group=<UUID|STRING>>&<password=<STRING>>&<scripts=<BOOL>>&<collisions=<BOOL>>&<physics=<BOOL>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("setregiondebug")] SETREGIONDEBUG,
            [Description("scripts")] SCRIPTS,
            [Description("collisions")] COLLISIONS,
            [Description("physics")] PHYSICS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getmapavatarpositions>&<group=<UUID|STRING>>&<password=<STRING>>&<region=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getmapavatarpositions")] GETMAPAVATARPOSITIONS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=mapfriend>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_FRIENDSHIP)] [Description("mapfriend")] MAPFRIEND,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytofriendshiprequest>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<action=<accept|decline>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_FRIENDSHIP)] [Description("replytofriendshiprequest")] REPLYTOFRIENDSHIPREQUEST,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getfriendshiprequests>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_FRIENDSHIP)] [Description("getfriendshiprequests")] GETFRIENDSHIPREQUESTS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=grantfriendrights>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<rights=<FriendRights>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_FRIENDSHIP)] [Description("grantfriendrights")] GRANTFRIENDRIGHTS,
            [Description("rights")] RIGHTS,

            [IsCommand(true)] [CommandInputSyntax("<command=getfriendslist>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_FRIENDSHIP)] [Description("getfriendslist")] GETFRIENDSLIST,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=terminatefriendship>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_FRIENDSHIP)] [Description("terminatefriendship")] TERMINATEFRIENDSHIP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=offerfriendship>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_FRIENDSHIP)] [Description("offerfriendship")] OFFERFRIENDSHIP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getfrienddata>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<FriendInfo[,FriendInfo...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_FRIENDSHIP)] [Description("getfrienddata")] GETFRIENDDATA,
            [Description("days")] DAYS,
            [Description("interval")] INTERVAL,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getgroupaccountsummarydata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<GroupAccountSummary[,GroupAccountSummary...]>>&<days=<INTEGER>>&<interval=<INTEGER>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("getgroupaccountsummarydata")] GETGROUPACCOUNTSUMMARYDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getselfdata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<AgentManager[,AgentManager...]>>&[callback=<STRING>]"
                )
                              ] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("getselfdata")] GETSELFDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deleteclassified>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("deleteclassified")] DELETECLASSIFIED,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=addclassified>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<price=<INTEGER>>&<type=<Any|Shopping|LandRental|PropertyRental|SpecialAttraction|NewProducts|Employment|Wanted|Service|Personal>>&[item=<UUID|STRING>]&[description=<STRING>]&[renew=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING | (uint) Permissions.PERMISSION_ECONOMY)] [Description("addclassified")] ADDCLASSIFIED,
            [Description("price")] PRICE,
            [Description("renew")] RENEW,
            [IsCommand(true)] [CommandInputSyntax("<command=logout>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_SYSTEM)] [Description("logout")] LOGOUT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=displayname>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<get|set>>&action=set:<name=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("displayname")] DISPLAYNAME,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=returnprimitives>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<entity=<parcel|estate>>&<type=<Owner|Group|Other|Sell|ReturnScripted|ReturnOnOthersLand|ReturnScriptedAndOnOthers>>&type=Owner|Group|Other|Sell:[position=<VECTOR2>]&type=ReturnScripted|ReturnOnOthersLand|ReturnScriptedAndOnOthers:[all=<BOOL>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("returnprimitives")] RETURNPRIMITIVES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getgroupdata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<Group[,Group...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("getgroupdata")] GETGROUPDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getavatardata>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<Avatar[,Avatar...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getavatardata")] GETAVATARDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitiveinventory>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getprimitiveinventory")] GETPRIMITIVEINVENTORY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getinventorydata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<data=<InventoryItem[,InventoryItem...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INVENTORY)] [Description("getinventorydata")] GETINVENTORYDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitiveinventorydata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<data=<InventoryItem[,InventoryItem...]>>&<entity=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getprimitiveinventorydata")] GETPRIMITIVEINVENTORYDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getscriptrunning>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<entity=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getscriptrunning")] GETSCRIPTRUNNING,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setscriptrunning>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<entity=<STRING|UUID>>&<action=<start|stop>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("setscriptrunning")] SETSCRIPTRUNNING,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=derez>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[folder=<STRING|UUID>]&[type=<DeRezDestination>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("derez")] DEREZ,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getparceldata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<Parcel[,Parcel...]>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("getparceldata")] GETPARCELDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=rez>&<group=<UUID|STRING>>&<password=<STRING>>&<position=<VECTOR2>>&<item=<UUID|STRING>&[rotation=<QUARTERNION>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("rez")] REZ,
            [Description("rotation")] ROTATION,
            [Description("index")] INDEX,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytoscriptdialog>&<group=<UUID|STRING>>&<password=<STRING>>&<channel=<INTEGER>>&<index=<INTEGER>&<button=<STRING>>&<item=<UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("replytoscriptdialog")] REPLYTOSCRIPTDIALOG,
            [Description("owner")] OWNER,
            [Description("button")] BUTTON,

            [IsCommand(true)] [CommandInputSyntax("<command=getanimations>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")
                              ] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("getanimations")] GETANIMATIONS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=animation>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&<action=<start|stop>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("animation")] ANIMATION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setestatelist>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<ban|group|manager|user>>&<action=<add|remove>>&type=ban|manager|user,action=add|remove:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&type=group,action=add|remove:<target=<STRING|UUID>>&[all=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("setestatelist")] SETESTATELIST,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getestatelist>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<ban|group|manager|user>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("getestatelist")] GETESTATELIST,
            [Description("all")] ALL,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getregiontop>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<scripts|colliders>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("getregiontop")] GETREGIONTOP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=restartregion>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<scripts|colliders>>&[delay=<INTEGER>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("restartregion")] RESTARTREGION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=directorysearch>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<classified|event|group|land|people|places>>&type=classified:<data=<Classified[,Classified...]>>&type=classified:<name=<STRING>>&type=event:<data=<EventsSearchData[,EventSearchData...]>>&type=event:<name=<STRING>>&type=group:<data=<GroupSearchData[,GroupSearchData...]>>&type=land:<data=<DirectoryParcel[,DirectoryParcel...]>>&type=people:<data=<AgentSearchData[,AgentSearchData...]>>&type=places:<data=<DirectoryParcel[,DirectoryParcel...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_DIRECTORY)] [Description("directorysearch")] DIRECTORYSEARCH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprofiledata>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<AvatarProperties[,AvatarProperties...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getprofiledata")] GETPROFILEDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getparticlesystem>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getparticlesystem")] GETPARTICLESYSTEM,
            [Description("data")] DATA,
            [Description("range")] RANGE,
            [Description("balance")] BALANCE,
            [Description("key")] KEY,
            [Description("value")] VALUE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=database>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<get|set|delete>>&action=get|delete:<key=<STRING>>&action=set:<key=<STRING>>&action=set:<value=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_DATABASE)] [Description("database")] DATABASE,
            [Description("text")] TEXT,
            [Description("quorum")] QUORUM,
            [Description("majority")] MAJORITY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=startproposal>&<group=<UUID|STRING>>&<password=<STRING>>&<duration=<INTEGER>>&<majority=<FLOAT>>&<quorum=<INTEGER>>&<text=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("startproposal")] STARTPROPOSAL,
            [Description("duration")] DURATION,
            [Description("action")] ACTION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deletefromrole>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("deletefromrole")] DELETEFROMROLE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=addtorole>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("addtorole")] ADDTOROLE,
            [IsCommand(true)] [CommandInputSyntax("<command=leave>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("leave")] LEAVE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=updategroupdata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<[Charter<,STRING>][,ListInProfile<,BOOL>][,MembershipFee<,INTEGER>][,OpenEnrollment<,BOOL>][,ShowInList<,BOOL>]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("updategroupdata")] UPDATEGROUPDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=eject>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("eject")] EJECT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=invite>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[role=<UUID[,STRING...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("invite")] INVITE,
            [IsCommand(true)] [CommandInputSyntax("<command=join>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP | (uint) Permissions.PERMISSION_ECONOMY)] [Description("join")] JOIN,
            [Description("callback")] CALLBACK,
            [Description("group")] GROUP,
            [Description("password")] PASSWORD,
            [Description("firstname")] FIRSTNAME,
            [Description("lastname")] LASTNAME,
            [Description("command")] COMMAND,
            [Description("role")] ROLE,
            [Description("title")] TITLE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=tell>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<local|group|avatar|estate|region>>&entity=local:<type=<Normal|Whisper|Shout>>&entity=local,type=Normal|Whisper|Shout:[channel=<INTEGER>]&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_TALK)] [Description("tell")] TELL,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=notice>&<group=<UUID|STRING>>&<password=<STRING>>&<message=<STRING>>&[subject=<STRING>]&[item=<UUID|STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("notice")] NOTICE,
            [Description("message")] MESSAGE,
            [Description("subject")] SUBJECT,
            [Description("item")] ITEM,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=pay>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<avatar|object|group>>&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&entity=object:<target=<UUID>>&[reason=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_ECONOMY)] [Description("pay")] PAY,
            [Description("amount")] AMOUNT,
            [Description("target")] TARGET,
            [Description("reason")] REASON,
            [IsCommand(true)] [CommandInputSyntax("<command=getbalance>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_ECONOMY)] [Description("getbalance")] GETBALANCE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=teleport>&<group=<UUID|STRING>>&<password=<STRING>>&<region=<STRING>>&[position=<VECTOR3>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("teleport")] TELEPORT,
            [Description("region")] REGION,
            [Description("position")] POSITION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getregiondata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<Simulator[,Simulator...]>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("getregiondata")] GETREGIONDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=sit>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("sit")] SIT,
            [IsCommand(true)] [CommandInputSyntax("<command=stand>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("stand")] STAND,
            [Description("ban")] BAN,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parceleject>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[ban=<BOOL>]&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("parceleject")] PARCELEJECT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=creategroup>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<Group[,Group...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP | (uint) Permissions.PERMISSION_ECONOMY)] [Description("creategroup")] CREATEGROUP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parcelfreeze>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[freeze=<BOOL>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("parcelfreeze")] PARCELFREEZE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=createrole>&<group=<UUID|STRING>>&<password=<STRING>>&<role=<STRING>>&[powers=<GroupPowers[,GroupPowers...]>]&[title=<STRING>]&[description=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("createrole")] CREATEROLE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deleterole>&<group=<UUID|STRING>>&<password=<STRING>>&<role=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("deleterole")] DELETEROLE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getrolesmembers>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("getrolesmembers")] GETROLESMEMBERS,
            [IsCommand(true)] [CommandInputSyntax("<command=getroles>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("getroles")] GETROLES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getrolepowers>&<group=<UUID|STRING>>&<password=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("getrolepowers")] GETROLEPOWERS,
            [Description("powers")] POWERS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=lure>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("lure")] LURE,
            [Description("URL")] URL,
            [IsCommand(true)] [CommandInputSyntax("<command=sethome>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("sethome")] SETHOME,
            [IsCommand(true)] [CommandInputSyntax("<command=gohome>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("gohome")] GOHOME,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprofiledata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<AvatarProperties[,AvatarProperties...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("setprofiledata")] SETPROFILEDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=give>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<avatar|object>>&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&entity=avatar:<item=<UUID|STRING>&entity=object:<item=<UUID|STRING>&entity=object:[range=<FLOAT>]&entity=object:<target=<UUID|STRING>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INVENTORY)] [Description("give")] GIVE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deleteitem>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INVENTORY)] [Description("deleteitem")] DELETEITEM,
            [IsCommand(true)] [CommandInputSyntax("<command=emptytrash>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_INVENTORY)] [Description("emptytrash")] EMPTYTRASH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=fly>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<start|stop>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("fly")] FLY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=addpick>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[description=<STRING>]&[item=<STRING|UUID>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("addpick")] ADDPICK,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deletepick>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("deltepick")] DELETEPICK,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=touch>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("touch")] TOUCH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=moderate>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<type=<voice|text>>&<silence=<BOOL>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROUP)] [Description("moderate")] MODERATE,
            [Description("type")] TYPE,
            [Description("silence")] SILENCE,
            [Description("freeze")] FREEZE,
            [IsCommand(true)] [CommandInputSyntax("<command=rebake>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("rebake")] REBAKE,

            [IsCommand(true)] [CommandInputSyntax("<command=getattachments>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("getattachments")] GETATTACHMENTS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=attach>&<group=<UUID|STRING>>&<password=<STRING>>&<attachments=<AttachmentPoint<,<UUID|STRING>>[,AttachmentPoint<,<UUID|STRING>>...]>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("attach")] ATTACH,
            [Description("attachments")] ATTACHMENTS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=detach>&<group=<UUID|STRING>>&<password=<STRING>>&<attachments=<STRING[,UUID...]>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("detach")] DETACH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitiveowners>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("getprimitiveowners")] GETPRIMITIVEOWNERS,
            [Description("entity")] ENTITY,
            [Description("channel")] CHANNEL,
            [Description("name")] NAME,
            [Description("description")] DESCRIPTION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitivedata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<data=<Primitive[,Primitive...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_INTERACT)] [Description("getprimitivedata")] GETPRIMITIVEDATA,
            [IsCommand(true)] [CommandInputSyntax("<command=activate>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_GROOMING)] [Description("activate")] ACTIVATE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=autopilot>&<group=<UUID|STRING>>&<password=<STRING>>&<position=<VECTOR2>>&<action=<start|stop>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_MOVEMENT)] [Description("autopilot")] AUTOPILOT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=mute>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<target=<UUID>>&<action=<mute|unmute>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_MUTE)] [Description("mute")] MUTE,
            [IsCommand(true)] [CommandInputSyntax("<command=getmutes>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_MUTE)] [Description("getmutes")] GETMUTES,
            [IsCommand(true)] [CommandInputSyntax("<command=getmutes>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.PERMISSION_NOTIFICATIONS)] [Description("notify")] NOTIFY,
            [Description("source")] SOURCE,
            [Description("effect")] EFFECT,
            [Description("id")] ID,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=terrain>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<set|get>>&action=set:<data=<STRING>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.PERMISSION_LAND)] [Description("terrain")] TERRAIN,
            [Description("output")] OUTPUT,
            [Description("input")] INPUT
        }

        /// <summary>
        ///     The permission mask of a command.
        /// </summary>
        private class CommandPermissionMaskAttribute : Attribute
        {
            protected readonly uint permissionMask;

            public CommandPermissionMaskAttribute(uint permissionMask)
            {
                this.permissionMask = permissionMask;
            }

            public uint PermissionMask
            {
                get { return permissionMask; }
            }
        }

        /// <summary>
        ///     Whether this is a command or not.
        /// </summary>
        private class IsCommandAttribute : Attribute
        {
            protected readonly bool isCommand;

            public IsCommandAttribute(bool isCommand)
            {
                this.isCommand = isCommand;
            }

            public bool IsCommand
            {
                get { return isCommand; }
            }
        }

        /// <summary>
        ///     The syntax for a command.
        /// </summary>
        private class CommandInputSyntaxAttribute : Attribute
        {
            protected readonly string syntax;

            public CommandInputSyntaxAttribute(string syntax)
            {
                this.syntax = syntax;
            }

            public string Syntax
            {
                get { return syntax; }
            }
        }

        /// <summary>
        ///     A structure for script permission requests.
        /// </summary>
        private struct ScriptPermissionRequest
        {
            public Agent Agent;
            [Description("item")] public UUID Item;
            [Description("name")] public string Name;
            [Description("permission")] public ScriptPermission Permission;
            [Description("region")] public string Region;
            [Description("task")] public UUID Task;
        }

        /// <summary>
        ///     A serializable dictionary implementation.
        /// </summary>
        /// <typeparam name="TKey">the key</typeparam>
        /// <typeparam name="TVal">the value</typeparam>
        /// <remarks>Copyright (c) Dacris Software Inc. MIT license</remarks>
        [Serializable]
        public class SerializableDictionary<TKey, TVal> : Dictionary<TKey, TVal>, IXmlSerializable, ISerializable
        {
            #region Constants

            private const string DictionaryNodeName = "Dictionary";
            private const string ItemNodeName = "Item";
            private const string KeyNodeName = "Key";
            private const string ValueNodeName = "Value";

            #endregion

            #region Constructors

            public SerializableDictionary()
            {
            }

            public SerializableDictionary(IDictionary<TKey, TVal> dictionary)
                : base(dictionary)
            {
            }

            public SerializableDictionary(IEqualityComparer<TKey> comparer)
                : base(comparer)
            {
            }

            public SerializableDictionary(int capacity)
                : base(capacity)
            {
            }

            public SerializableDictionary(IDictionary<TKey, TVal> dictionary, IEqualityComparer<TKey> comparer)
                : base(dictionary, comparer)
            {
            }

            public SerializableDictionary(int capacity, IEqualityComparer<TKey> comparer)
                : base(capacity, comparer)
            {
            }

            #endregion

            #region ISerializable Members

            protected SerializableDictionary(SerializationInfo info, StreamingContext context)
            {
                int itemCount = info.GetInt32("ItemCount");
                for (int i = 0; i < itemCount; i++)
                {
                    KeyValuePair<TKey, TVal> kvp =
                        (KeyValuePair<TKey, TVal>)
                            info.GetValue(String.Format("Item{0}", i), typeof (KeyValuePair<TKey, TVal>));
                    Add(kvp.Key, kvp.Value);
                }
            }

            void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
            {
                info.AddValue("ItemCount", Count);
                int itemIdx = 0;
                foreach (KeyValuePair<TKey, TVal> kvp in this)
                {
                    info.AddValue(String.Format("Item{0}", itemIdx), kvp, typeof (KeyValuePair<TKey, TVal>));
                    itemIdx++;
                }
            }

            #endregion

            #region IXmlSerializable Members

            void IXmlSerializable.WriteXml(XmlWriter writer)
            {
                //writer.WriteStartElement(DictionaryNodeName);
                foreach (KeyValuePair<TKey, TVal> kvp in this)
                {
                    writer.WriteStartElement(ItemNodeName);
                    writer.WriteStartElement(KeyNodeName);
                    KeySerializer.Serialize(writer, kvp.Key);
                    writer.WriteEndElement();
                    writer.WriteStartElement(ValueNodeName);
                    ValueSerializer.Serialize(writer, kvp.Value);
                    writer.WriteEndElement();
                    writer.WriteEndElement();
                }
                //writer.WriteEndElement();
            }

            void IXmlSerializable.ReadXml(XmlReader reader)
            {
                if (reader.IsEmptyElement)
                {
                    return;
                }

                // Move past container
                if (!reader.Read())
                {
                    throw new XmlException("Error in Deserialization of Dictionary");
                }

                //reader.ReadStartElement(DictionaryNodeName);
                while (reader.NodeType != XmlNodeType.EndElement)
                {
                    reader.ReadStartElement(ItemNodeName);
                    reader.ReadStartElement(KeyNodeName);
                    TKey key = (TKey) KeySerializer.Deserialize(reader);
                    reader.ReadEndElement();
                    reader.ReadStartElement(ValueNodeName);
                    TVal value = (TVal) ValueSerializer.Deserialize(reader);
                    reader.ReadEndElement();
                    reader.ReadEndElement();
                    Add(key, value);
                    reader.MoveToContent();
                }
                //reader.ReadEndElement();

                reader.ReadEndElement(); // Read End Element to close Read of containing node
            }

            XmlSchema IXmlSerializable.GetSchema()
            {
                return null;
            }

            #endregion

            #region Private Properties

            protected XmlSerializer ValueSerializer
            {
                get
                {
                    if (valueSerializer == null)
                    {
                        valueSerializer = new XmlSerializer(typeof (TVal));
                    }
                    return valueSerializer;
                }
            }

            private XmlSerializer KeySerializer
            {
                get
                {
                    if (keySerializer == null)
                    {
                        keySerializer = new XmlSerializer(typeof (TKey));
                    }
                    return keySerializer;
                }
            }

            #endregion

            #region Private Members

            private XmlSerializer keySerializer;
            private XmlSerializer valueSerializer;

            #endregion
        }

        /// <summary>
        ///     A structure to track Sphere effects.
        /// </summary>
        private struct SphereEffect
        {
            [Description("alpha")] public float Alpha;
            [Description("color")] public Vector3 Color;
            [Description("duration")] public float Duration;
            [Description("effect")] public UUID Effect;
            [Description("offset")] public Vector3d Offset;
            [Description("termination")] public DateTime Termination;
        }

        /// <summary>
        ///     A structure for teleport lures.
        /// </summary>
        private struct TeleportLure
        {
            public Agent Agent;
            public UUID Session;
        }

        /// <summary>
        ///     Various types.
        /// </summary>
        private enum Type : uint
        {
            [Description("none")] NONE = 0,
            [Description("text")] TEXT,
            [Description("voice")] VOICE,
            [Description("scripts")] SCRIPTS,
            [Description("colliders")] COLLIDERS,
            [Description("ban")] BAN,
            [Description("group")] GROUP,
            [Description("user")] USER,
            [Description("manager")] MANAGER,
            [Description("classified")] CLASSIFIED,
            [Description("event")] EVENT,
            [Description("land")] LAND,
            [Description("people")] PEOPLE,
            [Description("place")] PLACE,
            [Description("input")] INPUT,
            [Description("output")] OUTPUT
        }

        /// <summary>
        ///     Possible viewer effects.
        /// </summary>
        private enum ViewerEffectType : uint
        {
            [Description("none")] NONE = 0,
            [Description("look")] LOOK,
            [Description("point")] POINT,
            [Description("sphere")] SPHERE,
            [Description("beam")] BEAM
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2013 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     An alarm class similar to the UNIX alarm with the added benefit
        ///     of a decaying timer that tracks the time between rescheduling.
        /// </summary>
        /// <remarks>
        ///     (C) Wizardry and Steamworks 2013 - License: GNU GPLv3
        /// </remarks>
        public class wasAdaptiveAlarm
        {
            [Flags]
            public enum DECAY_TYPE
            {
                [Description("none")] NONE = 0,
                [Description("arithmetic")] ARITHMETIC = 1,
                [Description("geometric")] GEOMETRIC = 2,
                [Description("harmonic")] HARMONIC = 4,
                [Description("weighted")] WEIGHTED = 5
            }

            private readonly DECAY_TYPE decay = DECAY_TYPE.NONE;
            private readonly Stopwatch elapsed = new Stopwatch();
            private readonly object LockObject = new object();
            private readonly HashSet<double> times = new HashSet<double>();
            private Timer alarm;

            /// <summary>
            ///     The default constructor using no decay.
            /// </summary>
            public wasAdaptiveAlarm()
            {
                Signal = new ManualResetEvent(false);
            }

            /// <summary>
            ///     The constructor for the wasAdaptiveAlarm class taking as parameter a decay type.
            /// </summary>
            /// <param name="decay">the type of decay: arithmetic, geometric, harmonic, heronian or quadratic</param>
            public wasAdaptiveAlarm(DECAY_TYPE decay)
            {
                Signal = new ManualResetEvent(false);
                this.decay = decay;
            }

            public ManualResetEvent Signal { get; set; }

            public void Alarm(double deadline)
            {
                lock (LockObject)
                {
                    if (alarm == null)
                    {
                        alarm = new Timer(deadline);
                        alarm.Elapsed += (o, p) =>
                        {
                            lock (LockObject)
                            {
                                Signal.Set();
                                elapsed.Stop();
                                times.Clear();
                                alarm = null;
                            }
                        };
                        elapsed.Start();
                        alarm.Start();
                        return;
                    }
                }
                elapsed.Stop();
                times.Add(elapsed.ElapsedMilliseconds);
                elapsed.Reset();
                elapsed.Start();
                lock (LockObject)
                {
                    if (alarm != null)
                    {
                        switch (decay)
                        {
                            case DECAY_TYPE.ARITHMETIC:
                                alarm.Interval = (deadline + times.Aggregate((a, b) => b + a))/(1f + times.Count);
                                break;
                            case DECAY_TYPE.GEOMETRIC:
                                alarm.Interval = Math.Pow(deadline*times.Aggregate((a, b) => b*a), 1f/(1f + times.Count));
                                break;
                            case DECAY_TYPE.HARMONIC:
                                alarm.Interval = (1f + times.Count)/
                                                 (1f/deadline + times.Aggregate((a, b) => 1f/b + 1f/a));
                                break;
                            case DECAY_TYPE.WEIGHTED:
                                HashSet<double> d = new HashSet<double>(times) {deadline};
                                double total = d.Aggregate((a, b) => b + a);
                                alarm.Interval = d.Aggregate((a, b) => Math.Pow(a, 2)/total + Math.Pow(b, 2)/total);
                                break;
                            default:
                                alarm.Interval = deadline;
                                break;
                        }
                    }
                }
            }
        }

        /// <summary>
        ///     Semaphores that sense the state of the connection. When any of these semaphores fail,
        ///     Corrade does not consider itself connected anymore and terminates.
        /// </summary>
        private static readonly Dictionary<char, ManualResetEvent> ConnectionSemaphores = new Dictionary
            <char, ManualResetEvent>
        {
            {'l', new ManualResetEvent(false)},
            {'s', new ManualResetEvent(false)},
            {'u', new ManualResetEvent(false)}
        };

        public static string InstalledServiceName;
        private static Thread programThread;
        private static readonly EventLog CorradeEventLog = new EventLog();
        private static readonly GridClient Client = new GridClient();

        private static readonly Bot AIMLBot = new Bot
        {
            TrustAIML = false
        };

        private static readonly User AIMLBotUser = new User(CORRADE_CONSTANTS.CORRADE, AIMLBot);
        private static readonly FileSystemWatcher AIMLBotConfigurationWatcher = new FileSystemWatcher();
        private static readonly object AIMLBotLock = new object();
        private static readonly object ClientInstanceGroupsLock = new object();
        private static readonly object ClientInstanceInventoryLock = new object();
        private static readonly object ClientInstanceAvatarsLock = new object();
        private static readonly object ClientInstanceSelfLock = new object();
        private static readonly object ClientInstanceConfigurationLock = new object();
        private static readonly object ClientInstanceParcelsLock = new object();
        private static readonly object ClientInstanceNetworkLock = new object();
        private static readonly object ClientInstanceGridLock = new object();
        private static readonly object ClientInstanceDirectoryLock = new object();
        private static readonly object ClientInstanceEstateLock = new object();
        private static readonly object ClientInstanceObjectsLock = new object();
        private static readonly object ClientInstanceFriendsLock = new object();
        private static readonly object ClientInstanceAssetsLock = new object();
        private static readonly object ClientInstanceAppearanceLock = new object();
        private static readonly object ConfigurationFileLock = new object();
        private static readonly object ClientLogFileLock = new object();
        private static readonly object GroupLogFileLock = new object();
        private static readonly object LocalLogFileLock = new object();
        private static readonly object RegionLogFileLock = new object();
        private static readonly object InstantMessageLogFileLock = new object();
        private static readonly object DatabaseFileLock = new object();
        private static readonly Dictionary<string, object> DatabaseLocks = new Dictionary<string, object>();
        private static readonly object GroupNotificationsLock = new object();
        public static HashSet<Notification> GroupNotifications = new HashSet<Notification>();

        private static readonly SerializableDictionary<InventoryObjectOfferedEventArgs, ManualResetEvent>
            InventoryOffers =
                new SerializableDictionary<InventoryObjectOfferedEventArgs, ManualResetEvent>();

        private static readonly object InventoryOffersLock = new object();

        private static readonly BlockingQueue<CallbackQueueElement> CallbackQueue =
            new BlockingQueue<CallbackQueueElement>();

        private static readonly object CallbackQueueLock = new object();

        private static readonly BlockingQueue<NotificationQueueElement> NotificationQueue =
            new BlockingQueue<NotificationQueueElement>();

        private static readonly object NotificationQueueLock = new object();
        private static readonly HashSet<GroupInvite> GroupInvites = new HashSet<GroupInvite>();
        private static readonly object GroupInviteLock = new object();
        private static readonly HashSet<TeleportLure> TeleportLures = new HashSet<TeleportLure>();
        private static readonly object TeleportLureLock = new object();

        private static readonly HashSet<ScriptPermissionRequest> ScriptPermissionRequests =
            new HashSet<ScriptPermissionRequest>();

        private static readonly object ScriptPermissionRequestLock = new object();
        private static readonly HashSet<ScriptDialog> ScriptDialogs = new HashSet<ScriptDialog>();
        private static readonly object ScriptDialogLock = new object();

        private static readonly Dictionary<UUID, HashSet<UUID>> GroupMembers =
            new Dictionary<UUID, HashSet<UUID>>();

        private static readonly object GroupMembersLock = new object();
        private static readonly Hashtable GroupWorkers = new Hashtable();
        private static readonly object GroupWorkersLock = new object();
        private static readonly Hashtable GroupDirectoryTrackers = new Hashtable();
        private static readonly object GroupDirectoryTrackersLock = new object();
        private static readonly HashSet<LookAtEffect> LookAtEffects = new HashSet<LookAtEffect>();
        private static readonly HashSet<PointAtEffect> PointAtEffects = new HashSet<PointAtEffect>();
        private static readonly HashSet<SphereEffect> SphereEffects = new HashSet<SphereEffect>();
        private static readonly object SphereEffectsLock = new object();
        private static readonly HashSet<BeamEffect> BeamEffects = new HashSet<BeamEffect>();
        private static readonly Dictionary<UUID, Primitive> RadarObjects = new Dictionary<UUID, Primitive>();
        private static readonly object RadarObjectsLock = new object();
        private static readonly object BeamEffectsLock = new object();
        private static readonly object InputFiltersLock = new object();
        private static readonly object OutputFiltersLock = new object();
        private static volatile bool EnableRLV;
        private static volatile bool EnableAIML;
        private static volatile bool AIMLBotBrainCompiled;

        /// <summary>
        ///     The various types of threads used by Corrade.
        /// </summary>
        private static readonly Dictionary<CorradeThreadType, CorradeThread> CorradeThreadPool =
            new Dictionary<CorradeThreadType, CorradeThread>
            {
                {CorradeThreadType.COMMAND, new CorradeThread()},
                {CorradeThreadType.RLV, new CorradeThread()},
                {CorradeThreadType.NOTIFICATION, new CorradeThread()},
                {CorradeThreadType.INSTANT_MESSAGE, new CorradeThread()}
            };

        /// <summary>
        ///     Group membership sweep thread.
        /// </summary>
        private static Thread GroupMembershipSweepThread;

        /// <summary>
        ///     Group membership sweep thread starter.
        /// </summary>
        private static readonly System.Action StartGroupMembershipSweepThread = () =>
        {
            if (GroupMembershipSweepThread != null &&
                (GroupMembershipSweepThread.ThreadState.Equals(ThreadState.Running) ||
                 GroupMembershipSweepThread.ThreadState.Equals(ThreadState.WaitSleepJoin))) return;
            runGroupMembershipSweepThread = true;
            GroupMembershipSweepThread = new Thread(GroupMembershipSweep)
            {
                IsBackground = true,
                Priority = ThreadPriority.BelowNormal
            };
            GroupMembershipSweepThread.Start();
        };

        /// <summary>
        ///     Group membership sweep thread stopper.
        /// </summary>
        private static readonly System.Action StopGroupMembershipSweepThread = () =>
        {
            // Stop the notification thread.
            runGroupMembershipSweepThread = false;
            if (GroupMembershipSweepThread == null ||
                (!GroupMembershipSweepThread.ThreadState.Equals(ThreadState.Running) &&
                 !GroupMembershipSweepThread.ThreadState.Equals(ThreadState.WaitSleepJoin))) return;
            if (GroupMembershipSweepThread.Join(1000)) return;
            try
            {
                GroupMembershipSweepThread.Abort();
                GroupMembershipSweepThread.Join();
            }
            catch (ThreadStateException)
            {
            }
        };

        /// <summary>
        ///     Schedules a load of the configuration file.
        /// </summary>
        private static readonly System.Threading.Timer ConfigurationChangedTimer =
            new System.Threading.Timer(ConfigurationChanged =>
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.CONFIGURATION_FILE_MODIFIED));
                Configuration.Load(CORRADE_CONSTANTS.CONFIGURATION_FILE);
            });

        /// <summary>
        ///     Schedules a load of the AIML configuration file.
        /// </summary>
        private static readonly System.Threading.Timer AIMLConfigurationChangedTimer =
            new System.Threading.Timer(AIMLConfigurationChanged =>
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.AIML_CONFIGURATION_MODIFIED));
                new Thread(
                    () =>
                    {
                        lock (AIMLBotLock)
                        {
                            LoadChatBotFiles.Invoke();
                        }
                    }) {IsBackground = true, Priority = ThreadPriority.BelowNormal}.Start();
            });

        /// <summary>
        ///     Global rebake timer.
        /// </summary>
        private static readonly System.Threading.Timer RebakeTimer = new System.Threading.Timer(Rebake =>
        {
            lock (ClientInstanceAppearanceLock)
            {
                ManualResetEvent AppearanceSetEvent = new ManualResetEvent(false);
                EventHandler<AppearanceSetEventArgs> HandleAppearanceSet = (sender, args) => AppearanceSetEvent.Set();
                Client.Appearance.AppearanceSet += HandleAppearanceSet;
                Client.Appearance.RequestSetAppearance(true);
                AppearanceSetEvent.WaitOne(Configuration.SERVICES_TIMEOUT, false);
                Client.Appearance.AppearanceSet -= HandleAppearanceSet;
            }
        });

        /// <summary>
        ///     Current land group activation timer.
        /// </summary>
        private static readonly System.Threading.Timer ActivateCurrentLandGroupTimer =
            new System.Threading.Timer(ActivateCurrentLandGroup =>
            {
                Parcel parcel = null;
                if (!GetParcelAtPosition(Client.Network.CurrentSim, Client.Self.SimPosition, ref parcel)) return;
                Group landGroup =
                    Configuration.GROUPS.AsParallel().FirstOrDefault(o => o.UUID.Equals(parcel.GroupID));
                if (landGroup.UUID.Equals(UUID.Zero)) return;
                Client.Groups.ActivateGroup(landGroup.UUID);
            });

        public static EventHandler ConsoleEventHandler;

        /// <summary>
        ///     Corrade's input filter function.
        /// </summary>
        private static readonly Func<string, string> wasInput = o =>
        {
            if (string.IsNullOrEmpty(o)) return string.Empty;

            List<Filter> safeFilters;
            lock (InputFiltersLock)
            {
                safeFilters = Configuration.INPUT_FILTERS;
            }
            foreach (Filter filter in safeFilters)
            {
                switch (filter)
                {
                    case Filter.RFC1738:
                        o = wasURLUnescapeDataString(o);
                        break;
                    case Filter.RFC3986:
                        o = wasURIUnescapeDataString(o);
                        break;
                    case Filter.ENIGMA:
                        o = wasEnigma(o, Configuration.ENIGMA.rotors.ToArray(), Configuration.ENIGMA.plugs.ToArray(),
                            Configuration.ENIGMA.reflector);
                        break;
                    case Filter.VIGENERE:
                        o = wasDecryptVIGENERE(o, Configuration.VIGENERE_SECRET);
                        break;
                    case Filter.ATBASH:
                        o = wasATBASH(o);
                        break;
                    case Filter.BASE64:
                        o = Encoding.UTF8.GetString(Convert.FromBase64String(o));
                        break;
                }
            }
            return o;
        };

        /// <summary>
        ///     Corrade's output filter function.
        /// </summary>
        private static readonly Func<string, string> wasOutput = o =>
        {
            if (string.IsNullOrEmpty(o)) return string.Empty;

            List<Filter> safeFilters;
            lock (OutputFiltersLock)
            {
                safeFilters = Configuration.OUTPUT_FILTERS;
            }
            foreach (Filter filter in safeFilters)
            {
                switch (filter)
                {
                    case Filter.RFC1738:
                        o = wasURLEscapeDataString(o);
                        break;
                    case Filter.RFC3986:
                        o = wasURIEscapeDataString(o);
                        break;
                    case Filter.ENIGMA:
                        o = wasEnigma(o, Configuration.ENIGMA.rotors.ToArray(), Configuration.ENIGMA.plugs.ToArray(),
                            Configuration.ENIGMA.reflector);
                        break;
                    case Filter.VIGENERE:
                        o = wasEncryptVIGENERE(o, Configuration.VIGENERE_SECRET);
                        break;
                    case Filter.ATBASH:
                        o = wasATBASH(o);
                        break;
                    case Filter.BASE64:
                        o = Convert.ToBase64String(Encoding.UTF8.GetBytes(o));
                        break;
                }
            }
            return o;
        };

        /// <summary>
        ///     Determines whether a string is a Corrade command.
        /// </summary>
        /// <returns>true if the string is a Corrade command</returns>
        private static readonly Func<string, bool> IsCorradeCommand = o =>
        {
            Dictionary<string, string> data = wasKeyValueDecode(o);
            return !data.Count.Equals(0) && data.ContainsKey(wasGetDescriptionFromEnumValue(ScriptKeys.COMMAND)) &&
                   data.ContainsKey(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP)) &&
                   data.ContainsKey(wasGetDescriptionFromEnumValue(ScriptKeys.PASSWORD));
        };

        /// <summary>
        ///     Gets the first name and last name from an avatar name.
        /// </summary>
        /// <returns>the firstname and the lastname or Resident</returns>
        private static readonly Func<string, IEnumerable<string>> GetAvatarNames =
            o => CORRADE_CONSTANTS.AvatarFullNameRegex.Matches(o)
                .Cast<Match>()
                .ToDictionary(p => new[]
                {
                    p.Groups["first"].Value,
                    p.Groups["last"].Value
                })
                .SelectMany(
                    p =>
                        new[]
                        {
                            p.Key[0].Trim(),
                            !string.IsNullOrEmpty(p.Key[1])
                                ? p.Key[1].Trim()
                                : LINDEN_CONSTANTS.AVATARS.LASTNAME_PLACEHOLDER
                        });

        /// <summary>
        ///     Updates the inventory starting from a folder recursively.
        /// </summary>
        private static readonly Action<InventoryFolder> UpdateInventoryRecursive = o =>
        {
            Thread updateInventoryRecursiveThread = new Thread(() =>
            {
                // Create the queue of folders.
                Dictionary<UUID, ManualResetEvent> inventoryFolders = new Dictionary<UUID, ManualResetEvent>();
                Dictionary<UUID, Stopwatch> inventoryStopwatch = new Dictionary<UUID, Stopwatch>();
                HashSet<long> times = new HashSet<long>(new[] {(long) Client.Settings.CAPS_TIMEOUT});
                // Enqueue the first folder (as the root).
                inventoryFolders.Add(o.UUID, new ManualResetEvent(false));
                inventoryStopwatch.Add(o.UUID, new Stopwatch());

                object LockObject = new object();

                EventHandler<FolderUpdatedEventArgs> FolderUpdatedEventHandler = (p, q) =>
                {
                    // Enqueue all the new folders.
                    Client.Inventory.Store.GetContents(q.FolderID).ForEach(r =>
                    {
                        if (r is InventoryFolder)
                        {
                            UUID inventoryFolderUUID = (r as InventoryFolder).UUID;
                            lock (LockObject)
                            {
                                inventoryFolders.Add(inventoryFolderUUID, new ManualResetEvent(false));
                                inventoryStopwatch.Add(inventoryFolderUUID, new Stopwatch());
                            }
                        }
                    });
                    inventoryFolders[q.FolderID].Set();
                    inventoryStopwatch[q.FolderID].Stop();
                    times.Add(inventoryStopwatch[q.FolderID].ElapsedMilliseconds);
                };

                do
                {
                    // Don't choke the chicken.
                    Thread.Yield();
                    Dictionary<UUID, ManualResetEvent> closureFolders;
                    lock (LockObject)
                    {
                        closureFolders =
                            new Dictionary<UUID, ManualResetEvent>(
                                inventoryFolders.Where(p => !p.Key.Equals(UUID.Zero))
                                    .ToDictionary(p => p.Key, q => q.Value));
                    }
                    lock (ClientInstanceInventoryLock)
                    {
                        Parallel.ForEach(closureFolders,
                            new ParallelOptions
                            {
                                MaxDegreeOfParallelism =
                                    Environment.ProcessorCount > 1 ? Environment.ProcessorCount - 1 : 1
                            },
                            p =>
                            {
                                Client.Inventory.FolderUpdated += FolderUpdatedEventHandler;
                                inventoryStopwatch[p.Key].Start();
                                Client.Inventory.RequestFolderContents(p.Key, Client.Self.AgentID, true, true,
                                    InventorySortOrder.ByDate);
                                closureFolders[p.Key].WaitOne((int) times.Average(), false);
                                Client.Inventory.FolderUpdated -= FolderUpdatedEventHandler;
                            });
                    }
                    Parallel.ForEach(closureFolders, new ParallelOptions
                    {
                        MaxDegreeOfParallelism = Environment.ProcessorCount > 1 ? Environment.ProcessorCount - 1 : 1
                    }, p =>
                    {
                        lock (LockObject)
                        {
                            if (inventoryFolders.ContainsKey(p.Key))
                            {
                                inventoryFolders.Remove(p.Key);
                            }
                            if (inventoryStopwatch.ContainsKey(p.Key))
                            {
                                inventoryStopwatch.Remove(p.Key);
                            }
                        }
                    });
                } while (!inventoryFolders.Count.Equals(0));
            }) {IsBackground = true, Priority = ThreadPriority.Lowest};

            updateInventoryRecursiveThread.Start();
            updateInventoryRecursiveThread.Join(Timeout.Infinite);
        };

        /// <summary>
        ///     Loads the OpenMetaverse inventory cache.
        /// </summary>
        private static readonly System.Action LoadInventoryCache = () =>
        {
            int itemsLoaded =
                Client.Inventory.Store.RestoreFromDisk(Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY,
                    CORRADE_CONSTANTS.INVENTORY_CACHE_FILE));

            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVENTORY_CACHE_ITEMS_LOADED),
                itemsLoaded < 0 ? "0" : itemsLoaded.ToString(CultureInfo.InvariantCulture));
        };

        /// <summary>
        ///     Saves the OpenMetaverse inventory cache.
        /// </summary>
        private static readonly System.Action SaveInventoryCache = () =>
        {
            string path = Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY,
                CORRADE_CONSTANTS.INVENTORY_CACHE_FILE);
            int itemsSaved = Client.Inventory.Store.Items.Count;
            Client.Inventory.Store.SaveToDisk(path);

            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVENTORY_CACHE_ITEMS_SAVED),
                itemsSaved.ToString(CultureInfo.InvariantCulture));
        };

        /// <summary>
        ///     Loads Corrade's caches.
        /// </summary>
        private static readonly System.Action LoadCorradeCache = () =>
        {
            lock (Cache.Locks.AgentCacheLock)
            {
                Cache.AgentCache =
                    Cache.Load(Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.AGENT_CACHE_FILE),
                        Cache.AgentCache);
            }
            lock (Cache.Locks.GroupCacheLock)
            {
                Cache.GroupCache =
                    Cache.Load(Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.GROUP_CACHE_FILE),
                        Cache.GroupCache);
            }
        };

        /// <summary>
        ///     Saves Corrade's caches.
        /// </summary>
        private static readonly System.Action SaveCorradeCache = () =>
        {
            lock (Cache.Locks.AgentCacheLock)
            {
                Cache.Save(Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.AGENT_CACHE_FILE),
                    Cache.AgentCache);
            }
            lock (Cache.Locks.GroupCacheLock)
            {
                Cache.Save(Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.GROUP_CACHE_FILE),
                    Cache.GroupCache);
            }
        };

        /// <summary>
        ///     Saves Corrade notifications.
        /// </summary>
        private static readonly System.Action SaveNotificationState = () =>
        {
            if (!GroupNotifications.Count.Equals(0))
            {
                try
                {
                    using (
                        StreamWriter writer =
                            new StreamWriter(Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                                CORRADE_CONSTANTS.NOTIFICATIONS_STATE_FILE)))
                    {
                        XmlSerializer serializer = new XmlSerializer(typeof (HashSet<Notification>));
                        serializer.Serialize(writer, GroupNotifications);
                        writer.Flush();
                    }
                }
                catch (Exception e)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_NOTIFICATIONS_STATE),
                        e.Message);
                }
            }
        };

        /// <summary>
        ///     Saves inventory offers.
        /// </summary>
        private static readonly System.Action SaveInventoryOffersState = () =>
        {
            if (!InventoryOffers.Count.Equals(0))
            {
                try
                {
                    using (
                        StreamWriter writer =
                            new StreamWriter(Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                                CORRADE_CONSTANTS.INVENTORY_OFFERS_STATE_FILE)))
                    {
                        XmlSerializer serializer = new XmlSerializer(typeof (HashSet<Notification>));
                        serializer.Serialize(writer, InventoryOffers);
                        writer.Flush();
                    }
                }
                catch (Exception e)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_INVENTORY_OFFERS_STATE),
                        e.Message);
                }
            }
        };

        /// <summary>
        ///     Loads Corrade notifications.
        /// </summary>
        private static readonly System.Action LoadNotificationState = () =>
        {
            string groupNotificationsStateFile = Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                CORRADE_CONSTANTS.NOTIFICATIONS_STATE_FILE);
            if (File.Exists(groupNotificationsStateFile))
            {
                try
                {
                    using (FileStream stream = File.OpenRead(groupNotificationsStateFile))
                    {
                        XmlSerializer serializer = new XmlSerializer(typeof (HashSet<Notification>));
                        Parallel.ForEach((HashSet<Notification>) serializer.Deserialize(stream),
                            o =>
                            {
                                if (!Configuration.GROUPS.AsParallel().Any(p => p.Name.Equals(o.GroupName)) ||
                                    GroupNotifications.Contains(o)) return;
                                GroupNotifications.Add(o);
                            });
                    }
                }
                catch (Exception ex)
                {
                    Feedback(
                        wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_CORRADE_NOTIFICATIONS_STATE),
                        ex.Message);
                }
            }
        };

        /// <summary>
        ///     Loads inventory offers.
        /// </summary>
        private static readonly System.Action LoadInventoryOffersState = () =>
        {
            string inventoryOffersStateFile = Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                CORRADE_CONSTANTS.INVENTORY_OFFERS_STATE_FILE);
            if (File.Exists(inventoryOffersStateFile))
            {
                try
                {
                    using (FileStream stream = File.OpenRead(inventoryOffersStateFile))
                    {
                        XmlSerializer serializer = new XmlSerializer(typeof (HashSet<Notification>));
                        Parallel.ForEach(
                            (SerializableDictionary<InventoryObjectOfferedEventArgs, ManualResetEvent>)
                                serializer.Deserialize(stream),
                            o => { InventoryOffers.Add(o.Key, o.Value); });
                    }
                }
                catch (Exception ex)
                {
                    Feedback(
                        wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_CORRADE_INVENTORY_OFFERS_STATE),
                        ex.Message);
                }
            }
        };

        /// <summary>
        ///     Loads the chatbot configuration and AIML files.
        /// </summary>
        private static readonly System.Action LoadChatBotFiles = () =>
        {
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.READING_AIML_BOT_CONFIGURATION));
            try
            {
                AIMLBot.isAcceptingUserInput = false;
                AIMLBot.loadSettings(wasPathCombine(
                    Directory.GetCurrentDirectory(), AIML_BOT_CONSTANTS.DIRECTORY,
                    AIML_BOT_CONSTANTS.CONFIG.DIRECTORY, AIML_BOT_CONSTANTS.CONFIG.SETTINGS_FILE));
                string AIMLBotBrain =
                    wasPathCombine(
                        Directory.GetCurrentDirectory(), AIML_BOT_CONSTANTS.DIRECTORY,
                        AIML_BOT_CONSTANTS.BRAIN.DIRECTORY, AIML_BOT_CONSTANTS.BRAIN_FILE);
                switch (File.Exists(AIMLBotBrain))
                {
                    case true:
                        AIMLBot.loadFromBinaryFile(AIMLBotBrain);
                        break;
                    default:
                        AIMLBot.loadAIMLFromFiles();
                        AIMLBot.saveToBinaryFile(AIMLBotBrain);
                        break;
                }
                string AIMLBotUserBrain =
                    wasPathCombine(
                        Directory.GetCurrentDirectory(), AIML_BOT_CONSTANTS.DIRECTORY,
                        AIML_BOT_CONSTANTS.BRAIN.DIRECTORY, AIML_BOT_CONSTANTS.BRAIN_SESSION_FILE);
                if (File.Exists(AIMLBotUserBrain))
                {
                    AIMLBotUser.Predicates.loadSettings(AIMLBotUserBrain);
                }
                AIMLBot.isAcceptingUserInput = true;
            }
            catch (Exception ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_LOADING_AIML_BOT_FILES), ex.Message);
                return;
            }
            finally
            {
                AIMLBotBrainCompiled = true;
            }
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.READ_AIML_BOT_CONFIGURATION));
        };

        /// <summary>
        ///     Saves the chatbot configuration and AIML files.
        /// </summary>
        private static readonly System.Action SaveChatBotFiles = () =>
        {
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.WRITING_AIML_BOT_CONFIGURATION));
            try
            {
                AIMLBot.isAcceptingUserInput = false;
                AIMLBotUser.Predicates.DictionaryAsXML.Save(wasPathCombine(
                    Directory.GetCurrentDirectory(), AIML_BOT_CONSTANTS.DIRECTORY,
                    AIML_BOT_CONSTANTS.BRAIN.DIRECTORY, AIML_BOT_CONSTANTS.BRAIN_SESSION_FILE));
                AIMLBot.isAcceptingUserInput = true;
            }
            catch (Exception ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_SAVING_AIML_BOT_FILES), ex.Message);
                return;
            }
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.WROTE_AIML_BOT_CONFIGURATION));
        };

        private static volatile bool runCallbackThread = true;
        private static volatile bool runGroupMembershipSweepThread = true;
        private static volatile bool runNotificationThread = true;
        private static volatile bool runEffectsExpirationThread = true;

        #region KEY-VALUE DATA

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Returns the value of a key from a key-value data string.
        /// </summary>
        /// <param name="key">the key of the value</param>
        /// <param name="data">the key-value data segment</param>
        /// <returns>true if the key was found in data</returns>
        private static string wasKeyValueGet(string key, string data)
        {
            return data.Split('&')
                .AsParallel()
                .Select(o => o.Split('=').ToList())
                .Where(o => o.Count.Equals(2))
                .Select(o => new
                {
                    k = o.First(),
                    v = o.Last()
                })
                .Where(o => o.k.Equals(key))
                .Select(o => o.v)
                .FirstOrDefault();
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Returns a key-value data string with a key set to a given value.
        /// </summary>
        /// <param name="key">the key of the value</param>
        /// <param name="value">the value to set the key to</param>
        /// <param name="data">the key-value data segment</param>
        /// <returns>
        ///     a key-value data string or the empty string if either key or
        ///     value are empty
        /// </returns>
        private static string wasKeyValueSet(string key, string value, string data)
        {
            HashSet<string> output = new HashSet<string>(data.Split('&')
                .AsParallel()
                .Select(o => o.Split('=').ToList())
                .Where(o => o.Count.Equals(2))
                .Select(o => new
                {
                    k = o.First(),
                    v = !o.First().Equals(key) ? o.Last() : value
                }).Select(o => string.Join("=", o.k, o.v)));
            string append = string.Join("=", key, value);
            if (!output.Contains(append))
            {
                output.Add(append);
            }
            return string.Join("&", output.ToArray());
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Deletes a key-value pair from a string referenced by a key.
        /// </summary>
        /// <param name="key">the key to search for</param>
        /// <param name="data">the key-value data segment</param>
        /// <returns>a key-value pair string</returns>
        private static string wasKeyValueDelete(string key, string data)
        {
            return string.Join("&", data.Split('&')
                .AsParallel()
                .Select(o => o.Split('=').ToList())
                .Where(o => o.Count.Equals(2))
                .Select(o => new
                {
                    k = o.First(),
                    v = o.Last()
                })
                .Where(o => !o.k.Equals(key))
                .Select(o => string.Join("=", o.k, o.v))
                .ToArray());
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Decodes key-value pair data to a dictionary.
        /// </summary>
        /// <param name="data">the key-value pair data</param>
        /// <returns>a dictionary containing the keys and values</returns>
        private static Dictionary<string, string> wasKeyValueDecode(string data)
        {
            return data.Split('&')
                .AsParallel()
                .Select(o => o.Split('=').ToList())
                .Where(o => o.Count.Equals(2))
                .Select(o => new
                {
                    k = o.First(),
                    v = o.Last()
                })
                .GroupBy(o => o.k)
                .ToDictionary(o => o.Key, p => p.First().v);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Serialises a dictionary to key-value data.
        /// </summary>
        /// <param name="data">a dictionary</param>
        /// <returns>a key-value data encoded string</returns>
        private static string wasKeyValueEncode(Dictionary<string, string> data)
        {
            return string.Join("&", data.AsParallel().Select(o => string.Join("=", o.Key, o.Value)));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>Escapes a dictionary's keys and values for sending as POST data.</summary>
        /// <param name="data">A dictionary containing keys and values to be escaped</param>
        private static Dictionary<string, string> wasKeyValueEscape(Dictionary<string, string> data)
        {
            return data.AsParallel().ToDictionary(o => wasOutput(o.Key), p => wasOutput(p.Value));
        }

        #endregion

        #region CRYPTOGRAPHY

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Gets an array element at a given modulo index.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="index">a positive or negative index of the element</param>
        /// <param name="data">the array</param>
        /// <return>an array element</return>
        public static T wasGetElementAt<T>(T[] data, int index)
        {
            switch (index < 0)
            {
                case true:
                    return data[((index%data.Length) + data.Length)%data.Length];
                default:
                    return data[index%data.Length];
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Gets a sub-array from an array.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="data">the array</param>
        /// <param name="start">the start index</param>
        /// <param name="stop">the stop index (-1 denotes the end)</param>
        /// <returns>the array slice between start and stop</returns>
        public static T[] wasGetSubArray<T>(T[] data, int start, int stop)
        {
            if (stop.Equals(-1))
                stop = data.Length - 1;
            T[] result = new T[stop - start + 1];
            Array.Copy(data, start, result, 0, stop - start + 1);
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Delete a sub-array and return the result.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="data">the array</param>
        /// <param name="start">the start index</param>
        /// <param name="stop">the stop index (-1 denotes the end)</param>
        /// <returns>the array without elements between start and stop</returns>
        public static T[] wasDeleteSubArray<T>(T[] data, int start, int stop)
        {
            if (stop.Equals(-1))
                stop = data.Length - 1;
            T[] result = new T[data.Length - (stop - start) - 1];
            Array.Copy(data, 0, result, 0, start);
            Array.Copy(data, stop + 1, result, start, data.Length - stop - 1);
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Concatenate multiple arrays.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="arrays">multiple arrays</param>
        /// <returns>a flat array with all arrays concatenated</returns>
        public static T[] wasConcatenateArrays<T>(params T[][] arrays)
        {
            int resultLength = 0;
            foreach (T[] o in arrays)
            {
                resultLength += o.Length;
            }
            T[] result = new T[resultLength];
            int offset = 0;
            for (int x = 0; x < arrays.Length; x++)
            {
                arrays[x].CopyTo(result, offset);
                offset += arrays[x].Length;
            }
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Permutes an array in reverse a given number of times.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="input">the array</param>
        /// <param name="times">the number of times to permute</param>
        /// <returns>the array with the elements permuted</returns>
        private static T[] wasReversePermuteArrayElements<T>(T[] input, int times)
        {
            if (times.Equals(0)) return input;
            T[] slice = new T[input.Length];
            Array.Copy(input, 1, slice, 0, input.Length - 1);
            Array.Copy(input, 0, slice, input.Length - 1, 1);
            return wasReversePermuteArrayElements(slice, --times);
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Permutes an array forward a given number of times.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="input">the array</param>
        /// <param name="times">the number of times to permute</param>
        /// <returns>the array with the elements permuted</returns>
        private static T[] wasForwardPermuteArrayElements<T>(T[] input, int times)
        {
            if (times.Equals(0)) return input;
            T[] slice = new T[input.Length];
            Array.Copy(input, input.Length - 1, slice, 0, 1);
            Array.Copy(input, 0, slice, 1, input.Length - 1);
            return wasForwardPermuteArrayElements(slice, --times);
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Encrypt or decrypt a message given a set of rotors, plugs and a reflector.
        /// </summary>
        /// <param name="message">the message to encyrpt or decrypt</param>
        /// <param name="rotors">any combination of: 1, 2, 3, 4, 5, 6, 7, 8, b, g</param>
        /// <param name="plugs">the letter representing the start character for the rotor</param>
        /// <param name="reflector">any one of: B, b, C, c</param>
        /// <returns>either a decrypted or encrypted string</returns>
        private static string wasEnigma(string message, char[] rotors, char[] plugs, char reflector)
        {
            Dictionary<char, char[]> def_rotors = new Dictionary<char, char[]>
            {
                {
                    '1', new[]
                    {
                        'e', 'k', 'm', 'f', 'l',
                        'g', 'd', 'q', 'v', 'z',
                        'n', 't', 'o', 'w', 'y',
                        'h', 'x', 'u', 's', 'p',
                        'a', 'i', 'b', 'r', 'c',
                        'j'
                    }
                },
                {
                    '2', new[]
                    {
                        'a', 'j', 'd', 'k', 's',
                        'i', 'r', 'u', 'x', 'b',
                        'l', 'h', 'w', 't', 'm',
                        'c', 'q', 'g', 'z', 'n',
                        'p', 'y', 'f', 'v', 'o',
                        'e'
                    }
                },
                {
                    '3', new[]
                    {
                        'b', 'd', 'f', 'h', 'j',
                        'l', 'c', 'p', 'r', 't',
                        'x', 'v', 'z', 'n', 'y',
                        'e', 'i', 'w', 'g', 'a',
                        'k', 'm', 'u', 's', 'q',
                        'o'
                    }
                },
                {
                    '4', new[]
                    {
                        'e', 's', 'o', 'v', 'p',
                        'z', 'j', 'a', 'y', 'q',
                        'u', 'i', 'r', 'h', 'x',
                        'l', 'n', 'f', 't', 'g',
                        'k', 'd', 'c', 'm', 'w',
                        'b'
                    }
                },
                {
                    '5', new[]
                    {
                        'v', 'z', 'b', 'r', 'g',
                        'i', 't', 'y', 'u', 'p',
                        's', 'd', 'n', 'h', 'l',
                        'x', 'a', 'w', 'm', 'j',
                        'q', 'o', 'f', 'e', 'c',
                        'k'
                    }
                },
                {
                    '6', new[]
                    {
                        'j', 'p', 'g', 'v', 'o',
                        'u', 'm', 'f', 'y', 'q',
                        'b', 'e', 'n', 'h', 'z',
                        'r', 'd', 'k', 'a', 's',
                        'x', 'l', 'i', 'c', 't',
                        'w'
                    }
                },
                {
                    '7', new[]
                    {
                        'n', 'z', 'j', 'h', 'g',
                        'r', 'c', 'x', 'm', 'y',
                        's', 'w', 'b', 'o', 'u',
                        'f', 'a', 'i', 'v', 'l',
                        'p', 'e', 'k', 'q', 'd',
                        't'
                    }
                },
                {
                    '8', new[]
                    {
                        'f', 'k', 'q', 'h', 't',
                        'l', 'x', 'o', 'c', 'b',
                        'j', 's', 'p', 'd', 'z',
                        'r', 'a', 'm', 'e', 'w',
                        'n', 'i', 'u', 'y', 'g',
                        'v'
                    }
                },
                {
                    'b', new[]
                    {
                        'l', 'e', 'y', 'j', 'v',
                        'c', 'n', 'i', 'x', 'w',
                        'p', 'b', 'q', 'm', 'd',
                        'r', 't', 'a', 'k', 'z',
                        'g', 'f', 'u', 'h', 'o',
                        's'
                    }
                },
                {
                    'g', new[]
                    {
                        'f', 's', 'o', 'k', 'a',
                        'n', 'u', 'e', 'r', 'h',
                        'm', 'b', 't', 'i', 'y',
                        'c', 'w', 'l', 'q', 'p',
                        'z', 'x', 'v', 'g', 'j',
                        'd'
                    }
                }
            };

            Dictionary<char, char[]> def_reflectors = new Dictionary<char, char[]>
            {
                {
                    'B', new[]
                    {
                        'a', 'y', 'b', 'r', 'c', 'u', 'd', 'h',
                        'e', 'q', 'f', 's', 'g', 'l', 'i', 'p',
                        'j', 'x', 'k', 'n', 'm', 'o', 't', 'z',
                        'v', 'w'
                    }
                },
                {
                    'b', new[]
                    {
                        'a', 'e', 'b', 'n', 'c', 'k', 'd', 'q',
                        'f', 'u', 'g', 'y', 'h', 'w', 'i', 'j',
                        'l', 'o', 'm', 'p', 'r', 'x', 's', 'z',
                        't', 'v'
                    }
                },
                {
                    'C', new[]
                    {
                        'a', 'f', 'b', 'v', 'c', 'p', 'd', 'j',
                        'e', 'i', 'g', 'o', 'h', 'y', 'k', 'r',
                        'l', 'z', 'm', 'x', 'n', 'w', 't', 'q',
                        's', 'u'
                    }
                },
                {
                    'c', new[]
                    {
                        'a', 'r', 'b', 'd', 'c', 'o', 'e', 'j',
                        'f', 'n', 'g', 't', 'h', 'k', 'i', 'v',
                        'l', 'm', 'p', 'w', 'q', 'z', 's', 'x',
                        'u', 'y'
                    }
                }
            };

            // Setup rotors from plugs.
            foreach (char rotor in rotors)
            {
                char plug = plugs[Array.IndexOf(rotors, rotor)];
                int i = Array.IndexOf(def_rotors[rotor], plug);
                if (i.Equals(0)) continue;
                def_rotors[rotor] = wasConcatenateArrays(new[] {plug},
                    wasGetSubArray(wasDeleteSubArray(def_rotors[rotor], i, i), i, -1),
                    wasGetSubArray(wasDeleteSubArray(def_rotors[rotor], i + 1, -1), 0, i - 1));
            }

            StringBuilder result = new StringBuilder();
            foreach (char c in message)
            {
                if (!char.IsLetter(c))
                {
                    result.Append(c);
                    continue;
                }

                // Normalize to lower.
                char l = char.ToLower(c);

                Action<char[]> rotate = o =>
                {
                    int i = o.Length - 1;
                    do
                    {
                        def_rotors[o[0]] = wasForwardPermuteArrayElements(def_rotors[o[0]], 1);
                        if (i.Equals(0))
                        {
                            rotors = wasReversePermuteArrayElements(o, 1);
                            continue;
                        }
                        l = wasGetElementAt(def_rotors[o[1]], Array.IndexOf(def_rotors[o[0]], l) - 1);
                        o = wasReversePermuteArrayElements(o, 1);
                    } while (--i > -1);
                };

                // Forward pass through the Enigma's rotors.
                rotate.Invoke(rotors);

                // Reflect
                int x = Array.IndexOf(def_reflectors[reflector], l);
                l = (x + 1)%2 == 0 ? def_reflectors[reflector][x - 1] : def_reflectors[reflector][x + 1];

                // Reverse the order of the rotors.
                Array.Reverse(rotors);

                // Reverse pass through the Enigma's rotors.
                rotate.Invoke(rotors);

                if (char.IsUpper(c))
                {
                    l = char.ToUpper(l);
                }
                result.Append(l);
            }

            return result.ToString();
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Expand the VIGENRE key to the length of the input.
        /// </summary>
        /// <param name="input">the input to expand to</param>
        /// <param name="enc_key">the key to expand</param>
        /// <returns>the expanded key</returns>
        private static string wasVigenereExpandKey(string input, string enc_key)
        {
            string exp_key = "";
            int i = 0, j = 0;
            do
            {
                char p = input[i];
                if (!char.IsLetter(p))
                {
                    exp_key += p;
                    ++i;
                    continue;
                }
                int m = j%enc_key.Length;
                exp_key += enc_key[m];
                ++j;
                ++i;
            } while (i < input.Length);
            return exp_key;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Encrypt using VIGENERE.
        /// </summary>
        /// <param name="input">the input to encrypt</param>
        /// <param name="enc_key">the key to encrypt with</param>
        /// <returns>the encrypted input</returns>
        private static string wasEncryptVIGENERE(string input, string enc_key)
        {
            char[] a =
            {
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
                'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
            };

            enc_key = wasVigenereExpandKey(input, enc_key);
            string result = "";
            int i = 0;
            do
            {
                char p = input[i];
                if (!char.IsLetter(p))
                {
                    result += p;
                    ++i;
                    continue;
                }
                char q =
                    wasReversePermuteArrayElements(a, Array.IndexOf(a, enc_key[i]))[
                        Array.IndexOf(a, char.ToLowerInvariant(p))];
                if (char.IsUpper(p))
                {
                    q = char.ToUpperInvariant(q);
                }
                result += q;
                ++i;
            } while (i < input.Length);
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Decrypt using VIGENERE.
        /// </summary>
        /// <param name="input">the input to decrypt</param>
        /// <param name="enc_key">the key to decrypt with</param>
        /// <returns>the decrypted input</returns>
        private static string wasDecryptVIGENERE(string input, string enc_key)
        {
            char[] a =
            {
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
                'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
            };

            enc_key = wasVigenereExpandKey(input, enc_key);
            string result = "";
            int i = 0;
            do
            {
                char p = input[i];
                if (!char.IsLetter(p))
                {
                    result += p;
                    ++i;
                    continue;
                }
                char q =
                    a[
                        Array.IndexOf(wasReversePermuteArrayElements(a, Array.IndexOf(a, enc_key[i])),
                            char.ToLowerInvariant(p))];
                if (char.IsUpper(p))
                {
                    q = char.ToUpperInvariant(q);
                }
                result += q;
                ++i;
            } while (i < input.Length);
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2015 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     An implementation of the ATBASH cypher for latin alphabets.
        /// </summary>
        /// <param name="data">the data to encrypt or decrypt</param>
        /// <returns>the encrypted or decrypted data</returns>
        private static string wasATBASH(string data)
        {
            char[] a =
            {
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
                'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
            };

            char[] input = data.ToArray();

            Parallel.ForEach(Enumerable.Range(0, data.Length), i =>
            {
                char e = input[i];
                if (!char.IsLetter(e)) return;
                int x = 25 - Array.BinarySearch(a, char.ToLowerInvariant(e));
                if (!char.IsUpper(e))
                {
                    input[i] = a[x];
                    return;
                }
                input[i] = char.ToUpperInvariant(a[x]);
            });

            return new string(input);
        }

        #endregion

        #region NAME AND UUID RESOLVERS

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Tries to build an UUID out of the data string.
        /// </summary>
        /// <param name="data">a string</param>
        /// <returns>an UUID or the supplied string in case data could not be resolved</returns>
        private static object StringOrUUID(string data)
        {
            if (string.IsNullOrEmpty(data))
            {
                return null;
            }
            UUID @UUID;
            if (!UUID.TryParse(data, out @UUID))
            {
                return data;
            }
            return @UUID;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Updates the current balance by requesting it from the grid.
        /// </summary>
        /// <param name="millisecondsTimeout">timeout for the request in milliseconds</param>
        /// <returns>true if the balance could be retrieved</returns>
        private static bool UpdateBalance(int millisecondsTimeout)
        {
            ManualResetEvent MoneyBalanceEvent = new ManualResetEvent(false);
            EventHandler<MoneyBalanceReplyEventArgs> MoneyBalanceEventHandler =
                (sender, args) => MoneyBalanceEvent.Set();
            lock (ClientInstanceSelfLock)
            {
                Client.Self.MoneyBalanceReply += MoneyBalanceEventHandler;
                Client.Self.RequestBalance();
                if (!MoneyBalanceEvent.WaitOne(millisecondsTimeout, false))
                {
                    Client.Self.MoneyBalanceReply -= MoneyBalanceEventHandler;
                    return false;
                }
                Client.Self.MoneyBalanceReply -= MoneyBalanceEventHandler;
            }
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Resolves a group name to an UUID by using the directory search.
        /// </summary>
        /// <param name="groupName">the name of the group to resolve</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="groupUUID">an object in which to store the UUID of the group</param>
        /// <returns>true if the group name could be resolved to an UUID</returns>
        private static bool directGroupNameToUUID(string groupName, int millisecondsTimeout, int dataTimeout,
            ref UUID groupUUID)
        {
            UUID localGroupUUID = UUID.Zero;
            wasAdaptiveAlarm DirGroupsReceivedAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
            EventHandler<DirGroupsReplyEventArgs> DirGroupsReplyDelegate = (sender, args) =>
            {
                DirGroupsReceivedAlarm.Alarm(dataTimeout);
                DirectoryManager.GroupSearchData groupSearchData =
                    args.MatchedGroups.AsParallel()
                        .FirstOrDefault(o => o.GroupName.Equals(groupName, StringComparison.Ordinal));
                if (groupSearchData.Equals(default(DirectoryManager.GroupSearchData))) return;
                localGroupUUID = groupSearchData.GroupID;
            };
            Client.Directory.DirGroupsReply += DirGroupsReplyDelegate;
            Client.Directory.StartGroupSearch(groupName, 0);
            if (!DirGroupsReceivedAlarm.Signal.WaitOne(millisecondsTimeout, false))
            {
                Client.Directory.DirGroupsReply -= DirGroupsReplyDelegate;
                return false;
            }
            Client.Directory.DirGroupsReply -= DirGroupsReplyDelegate;
            if (localGroupUUID.Equals(UUID.Zero)) return false;
            groupUUID = localGroupUUID;
            return true;
        }

        /// <summary>
        ///     A wrapper for resolving group names to UUIDs by using Corrade's internal cache.
        /// </summary>
        /// <param name="groupName">the name of the group to resolve</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="groupUUID">an object in which to store the UUID of the group</param>
        /// <returns>true if the group name could be resolved to an UUID</returns>
        private static bool GroupNameToUUID(string groupName, int millisecondsTimeout, int dataTimeout,
            ref UUID groupUUID)
        {
            lock (Cache.Locks.GroupCacheLock)
            {
                Cache.Groups @group = Cache.GroupCache.AsParallel().FirstOrDefault(o => o.Name.Equals(groupName));

                if (!@group.Equals(default(Cache.Groups)))
                {
                    groupUUID = @group.UUID;
                    return true;
                }
            }
            bool succeeded;
            lock (ClientInstanceDirectoryLock)
            {
                succeeded = directGroupNameToUUID(groupName, millisecondsTimeout, dataTimeout, ref groupUUID);
            }
            if (succeeded)
            {
                lock (Cache.Locks.GroupCacheLock)
                {
                    Cache.GroupCache.Add(new Cache.Groups
                    {
                        Name = groupName,
                        UUID = groupUUID
                    });
                }
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Resolves a group name to an UUID by using the directory search.
        /// </summary>
        /// <param name="groupName">a string to store the name to</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="groupUUID">the UUID of the group to resolve</param>
        /// <returns>true if the group UUID could be resolved to an name</returns>
        private static bool directGroupUUIDToName(UUID groupUUID, int millisecondsTimeout, int dataTimeout,
            ref string groupName)
        {
            string localGroupName = groupName;
            wasAdaptiveAlarm GroupProfileReceivedAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
            EventHandler<GroupProfileEventArgs> GroupProfileDelegate = (o, s) =>
            {
                GroupProfileReceivedAlarm.Alarm(dataTimeout);
                localGroupName = s.Group.Name;
            };
            Client.Groups.GroupProfile += GroupProfileDelegate;
            Client.Groups.RequestGroupProfile(groupUUID);
            if (!GroupProfileReceivedAlarm.Signal.WaitOne(millisecondsTimeout, false))
            {
                Client.Groups.GroupProfile -= GroupProfileDelegate;
                return false;
            }
            Client.Groups.GroupProfile -= GroupProfileDelegate;
            groupName = localGroupName;
            return true;
        }

        /// <summary>
        ///     A wrapper for resolving group names to UUIDs by using Corrade's internal cache.
        /// </summary>
        /// <param name="groupName">a string to store the name to</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="groupUUID">the UUID of the group to resolve</param>
        /// <returns>true if the group UUID could be resolved to an name</returns>
        private static bool GroupUUIDToName(UUID groupUUID, int millisecondsTimeout, int dataTimeout,
            ref string groupName)
        {
            lock (Cache.Locks.GroupCacheLock)
            {
                Cache.Groups @group = Cache.GroupCache.AsParallel().FirstOrDefault(o => o.UUID.Equals(groupUUID));

                if (!@group.Equals(default(Cache.Groups)))
                {
                    groupName = @group.Name;
                    return true;
                }
            }
            bool succeeded;
            lock (ClientInstanceGroupsLock)
            {
                succeeded = directGroupUUIDToName(groupUUID, millisecondsTimeout, dataTimeout, ref groupName);
            }
            if (succeeded)
            {
                lock (Cache.Locks.GroupCacheLock)
                {
                    Cache.GroupCache.Add(new Cache.Groups
                    {
                        Name = groupName,
                        UUID = groupUUID
                    });
                }
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Resolves an agent name to an agent UUID by searching the directory
        ///     services.
        /// </summary>
        /// <param name="agentFirstName">the first name of the agent</param>
        /// <param name="agentLastName">the last name of the agent</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="agentUUID">an object to store the agent UUID</param>
        /// <returns>true if the agent name could be resolved to an UUID</returns>
        private static bool directAgentNameToUUID(string agentFirstName, string agentLastName, int millisecondsTimeout,
            int dataTimeout,
            ref UUID agentUUID)
        {
            UUID localAgentUUID = UUID.Zero;
            wasAdaptiveAlarm DirPeopleReceivedAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
            EventHandler<DirPeopleReplyEventArgs> DirPeopleReplyDelegate = (sender, args) =>
            {
                DirPeopleReceivedAlarm.Alarm(dataTimeout);
                DirectoryManager.AgentSearchData agentSearchData =
                    args.MatchedPeople.AsParallel().FirstOrDefault(
                        o =>
                            o.FirstName.Equals(agentFirstName, StringComparison.OrdinalIgnoreCase) &&
                            o.LastName.Equals(agentLastName, StringComparison.OrdinalIgnoreCase));
                if (agentSearchData.Equals(default(DirectoryManager.AgentSearchData))) return;
                localAgentUUID = agentSearchData.AgentID;
            };
            Client.Directory.DirPeopleReply += DirPeopleReplyDelegate;
            Client.Directory.StartPeopleSearch(
                string.Format(CultureInfo.InvariantCulture, "{0} {1}", agentFirstName, agentLastName), 0);
            if (!DirPeopleReceivedAlarm.Signal.WaitOne(millisecondsTimeout, false))
            {
                Client.Directory.DirPeopleReply -= DirPeopleReplyDelegate;
                return false;
            }
            Client.Directory.DirPeopleReply -= DirPeopleReplyDelegate;
            if (localAgentUUID.Equals(UUID.Zero)) return false;
            agentUUID = localAgentUUID;
            return true;
        }

        /// <summary>
        ///     A wrapper for looking up an agent name using Corrade's internal cache.
        /// </summary>
        /// <param name="agentFirstName">the first name of the agent</param>
        /// <param name="agentLastName">the last name of the agent</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="agentUUID">an object to store the agent UUID</param>
        /// <returns>true if the agent name could be resolved to an UUID</returns>
        private static bool AgentNameToUUID(string agentFirstName, string agentLastName, int millisecondsTimeout,
            int dataTimeout,
            ref UUID agentUUID)
        {
            lock (Cache.Locks.AgentCacheLock)
            {
                Cache.Agents agent =
                    Cache.AgentCache.AsParallel().FirstOrDefault(
                        o => o.FirstName.Equals(agentFirstName) && o.LastName.Equals(agentLastName));

                if (!agent.Equals(default(Cache.Agents)))
                {
                    agentUUID = agent.UUID;
                    return true;
                }
            }
            bool succeeded;
            lock (ClientInstanceDirectoryLock)
            {
                succeeded = directAgentNameToUUID(agentFirstName, agentLastName, millisecondsTimeout, dataTimeout,
                    ref agentUUID);
            }
            if (succeeded)
            {
                lock (Cache.Locks.AgentCacheLock)
                {
                    Cache.AgentCache.Add(new Cache.Agents
                    {
                        FirstName = agentFirstName,
                        LastName = agentLastName,
                        UUID = agentUUID
                    });
                }
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Resolves an agent UUID to an agent name.
        /// </summary>
        /// <param name="agentUUID">the UUID of the agent</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="agentName">an object to store the name of the agent in</param>
        /// <returns>true if the UUID could be resolved to a name</returns>
        private static bool directAgentUUIDToName(UUID agentUUID, int millisecondsTimeout,
            ref string agentName)
        {
            if (agentUUID.Equals(UUID.Zero))
                return false;
            string localAgentName = string.Empty;
            ManualResetEvent UUIDNameReplyEvent = new ManualResetEvent(false);
            EventHandler<UUIDNameReplyEventArgs> UUIDNameReplyDelegate = (sender, args) =>
            {
                KeyValuePair<UUID, string> UUIDNameReply =
                    args.Names.AsParallel().FirstOrDefault(o => o.Key.Equals(agentUUID));
                if (!UUIDNameReply.Equals(default(KeyValuePair<UUID, string>)))
                    localAgentName = UUIDNameReply.Value;
                UUIDNameReplyEvent.Set();
            };
            Client.Avatars.UUIDNameReply += UUIDNameReplyDelegate;
            Client.Avatars.RequestAvatarName(agentUUID);
            if (!UUIDNameReplyEvent.WaitOne(millisecondsTimeout, false))
            {
                Client.Avatars.UUIDNameReply -= UUIDNameReplyDelegate;
                return false;
            }
            Client.Avatars.UUIDNameReply -= UUIDNameReplyDelegate;
            if (string.IsNullOrEmpty(localAgentName)) return false;
            agentName = localAgentName;
            return true;
        }

        /// <summary>
        ///     A wrapper for agent to UUID lookups using Corrade's internal cache.
        /// </summary>
        /// <param name="agentUUID">the UUID of the agent</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="agentName">an object to store the name of the agent in</param>
        /// <returns>true if the UUID could be resolved to a name</returns>
        private static bool AgentUUIDToName(UUID agentUUID, int millisecondsTimeout,
            ref string agentName)
        {
            lock (Cache.Locks.AgentCacheLock)
            {
                Cache.Agents agent = Cache.AgentCache.AsParallel().FirstOrDefault(o => o.UUID.Equals(agentUUID));

                if (!agent.Equals(default(Cache.Agents)))
                {
                    agentName = string.Join(" ", agent.FirstName, agent.LastName);
                    return true;
                }
            }
            bool succeeded;
            lock (ClientInstanceAvatarsLock)
            {
                succeeded = directAgentUUIDToName(agentUUID, millisecondsTimeout, ref agentName);
            }
            if (succeeded)
            {
                List<string> name = new List<string>(GetAvatarNames(agentName));
                lock (Cache.Locks.AgentCacheLock)
                {
                    Cache.AgentCache.Add(new Cache.Agents
                    {
                        FirstName = name.First(),
                        LastName = name.Last(),
                        UUID = agentUUID
                    });
                }
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// ///
        /// <summary>
        ///     Resolves a role name to a role UUID.
        /// </summary>
        /// <param name="roleName">the name of the role to be resolved to an UUID</param>
        /// <param name="groupUUID">the UUID of the group to query for the role UUID</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="roleUUID">an UUID object to store the role UUID in</param>
        /// <returns>true if the role could be found</returns>
        private static bool RoleNameToRoleUUID(string roleName, UUID groupUUID, int millisecondsTimeout,
            int dataTimeout,
            ref UUID roleUUID)
        {
            UUID localRoleUUID = UUID.Zero;
            wasAdaptiveAlarm GroupRoleDataReceivedAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
            EventHandler<GroupRolesDataReplyEventArgs> GroupRoleDataReplyDelegate = (sender, args) =>
            {
                GroupRoleDataReceivedAlarm.Alarm(dataTimeout);
                KeyValuePair<UUID, GroupRole> groupRole =
                    args.Roles.AsParallel()
                        .FirstOrDefault(o => o.Value.Name.Equals(roleName, StringComparison.Ordinal));
                if (groupRole.Equals(default(KeyValuePair<UUID, GroupRole>))) return;
                localRoleUUID = groupRole.Key;
            };
            lock (ClientInstanceGroupsLock)
            {
                Client.Groups.GroupRoleDataReply += GroupRoleDataReplyDelegate;
                Client.Groups.RequestGroupRoles(groupUUID);
                if (!GroupRoleDataReceivedAlarm.Signal.WaitOne(millisecondsTimeout, false))
                {
                    Client.Groups.GroupRoleDataReply -= GroupRoleDataReplyDelegate;
                    return false;
                }
                Client.Groups.GroupRoleDataReply -= GroupRoleDataReplyDelegate;
            }
            roleUUID = localRoleUUID;
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Resolves a role name to a role UUID.
        /// </summary>
        /// <param name="RoleUUID">the UUID of the role to be resolved to a name</param>
        /// <param name="GroupUUID">the UUID of the group to query for the role name</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="roleName">a string object to store the role name in</param>
        /// <returns>true if the role could be resolved</returns>
        private static bool RoleUUIDToName(UUID RoleUUID, UUID GroupUUID, int millisecondsTimeout, int dataTimeout,
            ref string roleName)
        {
            if (RoleUUID.Equals(UUID.Zero) || GroupUUID.Equals(UUID.Zero))
                return false;
            string localRoleName = string.Empty;
            wasAdaptiveAlarm GroupRoleDataReceivedAlarm = new wasAdaptiveAlarm(Configuration.DATA_DECAY_TYPE);
            EventHandler<GroupRolesDataReplyEventArgs> GroupRoleDataReplyDelegate = (sender, args) =>
            {
                GroupRoleDataReceivedAlarm.Alarm(dataTimeout);
                KeyValuePair<UUID, GroupRole> groupRole =
                    args.Roles.AsParallel().FirstOrDefault(o => o.Key.Equals(RoleUUID));
                if (groupRole.Equals(default(KeyValuePair<UUID, GroupRole>))) return;
                localRoleName = groupRole.Value.Name;
            };
            lock (ClientInstanceGroupsLock)
            {
                Client.Groups.GroupRoleDataReply += GroupRoleDataReplyDelegate;
                Client.Groups.RequestGroupRoles(GroupUUID);
                if (!GroupRoleDataReceivedAlarm.Signal.WaitOne(millisecondsTimeout, false))
                {
                    Client.Groups.GroupRoleDataReply -= GroupRoleDataReplyDelegate;
                    return false;
                }
                Client.Groups.GroupRoleDataReply -= GroupRoleDataReplyDelegate;
            }
            if (string.IsNullOrEmpty(localRoleName)) return false;
            roleName = localRoleName;
            return true;
        }

        #endregion

        #region RLV STRUCTURES

        /// <summary>
        ///     Holds all the active RLV rules.
        /// </summary>
        private static readonly HashSet<RLVRule> RLVRules = new HashSet<RLVRule>();

        /// <summary>
        ///     Locks down RLV for linear concurrent access.
        /// </summary>
        private static readonly object RLVRulesLock = new object();

        /// <summary>
        ///     RLV Wearables.
        /// </summary>
        private static readonly List<RLVWearable> RLVWearables = new List<RLVWearable>
        {
            new RLVWearable {Name = @"gloves", WearableType = WearableType.Gloves},
            new RLVWearable {Name = @"jacket", WearableType = WearableType.Jacket},
            new RLVWearable {Name = @"pants", WearableType = WearableType.Pants},
            new RLVWearable {Name = @"shirt", WearableType = WearableType.Shirt},
            new RLVWearable {Name = @"shoes", WearableType = WearableType.Shoes},
            new RLVWearable {Name = @"skirt", WearableType = WearableType.Skirt},
            new RLVWearable {Name = @"socks", WearableType = WearableType.Socks},
            new RLVWearable {Name = @"underpants", WearableType = WearableType.Underpants},
            new RLVWearable {Name = @"undershirt", WearableType = WearableType.Undershirt},
            new RLVWearable {Name = @"skin", WearableType = WearableType.Skin},
            new RLVWearable {Name = @"eyes", WearableType = WearableType.Eyes},
            new RLVWearable {Name = @"hair", WearableType = WearableType.Hair},
            new RLVWearable {Name = @"shape", WearableType = WearableType.Shape},
            new RLVWearable {Name = @"alpha", WearableType = WearableType.Alpha},
            new RLVWearable {Name = @"tattoo", WearableType = WearableType.Tattoo},
            new RLVWearable {Name = @"physics", WearableType = WearableType.Physics}
        };

        /// <summary>
        ///     RLV Attachments.
        /// </summary>
        private static readonly List<RLVAttachment> RLVAttachments = new List<RLVAttachment>
        {
            new RLVAttachment {Name = @"none", AttachmentPoint = AttachmentPoint.Default},
            new RLVAttachment {Name = @"chest", AttachmentPoint = AttachmentPoint.Chest},
            new RLVAttachment {Name = @"skull", AttachmentPoint = AttachmentPoint.Skull},
            new RLVAttachment {Name = @"left shoulder", AttachmentPoint = AttachmentPoint.LeftShoulder},
            new RLVAttachment {Name = @"right shoulder", AttachmentPoint = AttachmentPoint.RightShoulder},
            new RLVAttachment {Name = @"left hand", AttachmentPoint = AttachmentPoint.LeftHand},
            new RLVAttachment {Name = @"right hand", AttachmentPoint = AttachmentPoint.RightHand},
            new RLVAttachment {Name = @"left foot", AttachmentPoint = AttachmentPoint.LeftFoot},
            new RLVAttachment {Name = @"right foot", AttachmentPoint = AttachmentPoint.RightFoot},
            new RLVAttachment {Name = @"spine", AttachmentPoint = AttachmentPoint.Spine},
            new RLVAttachment {Name = @"pelvis", AttachmentPoint = AttachmentPoint.Pelvis},
            new RLVAttachment {Name = @"mouth", AttachmentPoint = AttachmentPoint.Mouth},
            new RLVAttachment {Name = @"chin", AttachmentPoint = AttachmentPoint.Chin},
            new RLVAttachment {Name = @"left ear", AttachmentPoint = AttachmentPoint.LeftEar},
            new RLVAttachment {Name = @"right ear", AttachmentPoint = AttachmentPoint.RightEar},
            new RLVAttachment {Name = @"left eyeball", AttachmentPoint = AttachmentPoint.LeftEyeball},
            new RLVAttachment {Name = @"right eyeball", AttachmentPoint = AttachmentPoint.RightEyeball},
            new RLVAttachment {Name = @"nose", AttachmentPoint = AttachmentPoint.Nose},
            new RLVAttachment {Name = @"r upper arm", AttachmentPoint = AttachmentPoint.RightUpperArm},
            new RLVAttachment {Name = @"r forearm", AttachmentPoint = AttachmentPoint.RightForearm},
            new RLVAttachment {Name = @"l upper arm", AttachmentPoint = AttachmentPoint.LeftUpperArm},
            new RLVAttachment {Name = @"l forearm", AttachmentPoint = AttachmentPoint.LeftForearm},
            new RLVAttachment {Name = @"right hip", AttachmentPoint = AttachmentPoint.RightHip},
            new RLVAttachment {Name = @"r upper leg", AttachmentPoint = AttachmentPoint.RightUpperLeg},
            new RLVAttachment {Name = @"r lower leg", AttachmentPoint = AttachmentPoint.RightLowerLeg},
            new RLVAttachment {Name = @"left hip", AttachmentPoint = AttachmentPoint.LeftHip},
            new RLVAttachment {Name = @"l upper leg", AttachmentPoint = AttachmentPoint.LeftUpperLeg},
            new RLVAttachment {Name = @"l lower leg", AttachmentPoint = AttachmentPoint.LeftLowerLeg},
            new RLVAttachment {Name = @"stomach", AttachmentPoint = AttachmentPoint.Stomach},
            new RLVAttachment {Name = @"left pec", AttachmentPoint = AttachmentPoint.LeftPec},
            new RLVAttachment {Name = @"right pec", AttachmentPoint = AttachmentPoint.RightPec},
            new RLVAttachment {Name = @"center 2", AttachmentPoint = AttachmentPoint.HUDCenter2},
            new RLVAttachment {Name = @"top right", AttachmentPoint = AttachmentPoint.HUDTopRight},
            new RLVAttachment {Name = @"top", AttachmentPoint = AttachmentPoint.HUDTop},
            new RLVAttachment {Name = @"top left", AttachmentPoint = AttachmentPoint.HUDTopLeft},
            new RLVAttachment {Name = @"center", AttachmentPoint = AttachmentPoint.HUDCenter},
            new RLVAttachment {Name = @"bottom left", AttachmentPoint = AttachmentPoint.HUDBottomLeft},
            new RLVAttachment {Name = @"bottom", AttachmentPoint = AttachmentPoint.HUDBottom},
            new RLVAttachment {Name = @"bottom right", AttachmentPoint = AttachmentPoint.HUDBottomRight},
            new RLVAttachment {Name = @"neck", AttachmentPoint = AttachmentPoint.Neck},
            new RLVAttachment {Name = @"root", AttachmentPoint = AttachmentPoint.Root}
        };

        /// <summary>
        ///     RLV attachment structure.
        /// </summary>
        private struct RLVAttachment
        {
            public AttachmentPoint AttachmentPoint;
            public string Name;
        }

        /// <summary>
        ///     Enumeration for supported RLV commands.
        /// </summary>
        private enum RLVBehaviour : uint
        {
            [Description("none")] NONE = 0,
            [Description("version")] VERSION,
            [Description("versionnew")] VERSIONNEW,
            [Description("versionnum")] VERSIONNUM,
            [Description("getgroup")] GETGROUP,
            [Description("setgroup")] SETGROUP,
            [Description("getsitid")] GETSITID,
            [Description("getstatusall")] GETSTATUSALL,
            [Description("getstatus")] GETSTATUS,
            [Description("sit")] SIT,
            [Description("unsit")] UNSIT,
            [Description("setrot")] SETROT,
            [Description("tpto")] TPTO,
            [Description("getoutfit")] GETOUTFIT,
            [Description("getattach")] GETATTACH,
            [Description("remattach")] REMATTACH,
            [Description("detach")] DETACH,
            [Description("detachme")] DETACHME,
            [Description("remoutfit")] REMOUTFIT,
            [Description("attach")] ATTACH,
            [Description("attachoverreplace")] ATTACHOVERORREPLACE,
            [Description("attachover")] ATTACHOVER,
            [Description("getinv")] GETINV,
            [Description("getinvworn")] GETINVWORN,
            [Description("getpath")] GETPATH,
            [Description("getpathnew")] GETPATHNEW,
            [Description("findfolder")] FINDFOLDER,
            [Description("clear")] CLEAR,
            [Description("accepttp")] ACCEPTTP,
            [Description("acceptpermission")] ACCEPTPERMISSION
        }

        private struct RLVRule
        {
            public string Behaviour;
            public UUID ObjectUUID;
            public string Option;
            public string Param;
        }

        /// <summary>
        ///     RLV wearable structure.
        /// </summary>
        private struct RLVWearable
        {
            public string Name;
            public WearableType WearableType;
        }

        /// <summary>
        ///     Structure for RLV constants.
        /// </summary>
        private struct RLV_CONSTANTS
        {
            public const string COMMAND_OPERATOR = @"@";
            public const string VIEWER = @"RestrainedLife viewer";
            public const string SHORT_VERSION = @"1.23";
            public const string LONG_VERSION = @"1230100";
            public const string FORCE = @"force";
            public const string FALSE_MARKER = @"0";
            public const string TRUE_MARKER = @"1";
            public const string CSV_DELIMITER = @",";
            public const string DOT_MARKER = @".";
            public const string TILDE_MARKER = @"~";
            public const string PROPORTION_SEPARATOR = @"|";
            public const string SHARED_FOLDER_NAME = @"#RLV";
            public const string AND_OPERATOR = @"&&";
            public const string PATH_SEPARATOR = @"/";
            public const string Y = @"y";
            public const string ADD = @"add";
            public const string N = @"n";
            public const string REM = @"rem";
            public const string STATUS_SEPARATOR = @";";

            /// <summary>
            ///     Regex used to match RLV commands.
            /// </summary>
            public static readonly Regex RLVRegEx = new Regex(@"(?<behaviour>[^:=]+)(:(?<option>[^=]*))?=(?<param>\w+)",
                RegexOptions.Compiled);
        }

        #endregion
    }

    public class NativeMethods
    {
        public enum CtrlType
        {
            CTRL_C_EVENT = 0,
            CTRL_BREAK_EVENT,
            CTRL_CLOSE_EVENT,
            CTRL_LOGOFF_EVENT = 5,
            CTRL_SHUTDOWN_EVENT
        }

        /// <summary>
        ///     Import console handler for windows.
        /// </summary>
        [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool SetConsoleCtrlHandler(Corrade.EventHandler handler,
            [MarshalAs(UnmanagedType.U1)] bool add);
    }
}